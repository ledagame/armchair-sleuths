/**
 * CaseGeneratorService.ts
 *
 * AI ê¸°ë°˜ ì¼€ì´ìŠ¤ ìƒì„± ì„œë¹„ìŠ¤
 * CaseElementLibrary + GeminiClientë¥¼ ê²°í•©í•˜ì—¬ í”Œë ˆì´ ê°€ëŠ¥í•œ ì¼€ì´ìŠ¤ ìƒì„±
 */

import { GeminiClient, type GeminiTextOptions } from '../gemini/GeminiClient';
import { CaseElementLibrary, type Weapon, type Motive, type Location, type Suspect } from './CaseElementLibrary';
import { CaseRepository, type CreateCaseInput } from '../repositories/kv/CaseRepository';
import { CaseValidator } from './CaseValidator';
import { WorkflowExecutor, DEFAULT_RETRY_POLICIES } from '../workflow/WorkflowExecutor';
import { TransactionManager, CaseCreationTransaction } from '../workflow/TransactionManager';
import { KVStoreManager } from '../repositories/kv/KVStoreManager';
import type { SuspectData, CaseData, ImageGenerationStatus } from '../repositories/kv/KVStoreManager';
import { CinematicImageService, type CinematicImages } from '../image/CinematicImageService';
import { LocationDiscoveryService } from '../discovery/LocationDiscoveryService';
import { DiscoveryStateManager } from '../discovery/DiscoveryStateManager';
import type { EvidenceItem } from '@/shared/types/Evidence';
import type { Location as DiscoveryLocation, APTopic, ActionPointsConfig } from '@/shared/types/Case';
import { generateDefaultAPTopics, validateAPTopics } from '../ap/APTopicGenerator';

export interface GenerateCaseOptions {
  date?: Date;
  includeImage?: boolean;
  includeSuspectImages?: boolean; // Generate profile images for suspects
  includeCinematicImages?: boolean; // Generate cinematic intro images (5 scenes)
  temperature?: number;
  customCaseId?: string; // Custom case ID for unique identification (timestamp-based)
}

export interface GeneratedCase {
  caseId: string;
  id: string;              // Alias for backward compatibility
  date: string;            // Date string in YYYY-MM-DD format
  victim: {
    name: string;
    background: string;
    relationship: string;
  };
  weapon: Weapon;
  location: Location;
  suspects: Array<{
    id: string;
    name: string;
    archetype: string;
    background: string;
    personality: string;
    isGuilty: boolean;
    profileImageUrl?: string; // Profile image URL
  }>;
  solution: {
    who: string;
    what: string;
    where: string;
    when: string;
    why: string;
    how: string;
  };
  imageUrl?: string;
  cinematicImages?: {
    establishing?: string;
    entry?: string;
    confrontation?: string;
    suspects?: string;
    action?: string;
  };
  introNarration?: {
    atmosphere: string;
    incident: string;
    stakes: string;
  };
  generatedAt: number;
  // Discovery system data
  locations?: DiscoveryLocation[]; // íƒìƒ‰ ê°€ëŠ¥í•œ ì¥ì†Œ ëª©ë¡
  evidence?: EvidenceItem[]; // ì¦ê±° ëª©ë¡
  evidenceDistribution?: any; // ì¦ê±° ë¶„ë°° ì •ë³´
}

/**
 * ì¼€ì´ìŠ¤ ìƒì„± ì„œë¹„ìŠ¤ (ê°œì„ ëœ ë²„ì „)
 *
 * ê°œì„ ì‚¬í•­:
 * - CaseValidatorë¡œ ì‚¬ì „/ì‚¬í›„ ê²€ì¦
 * - WorkflowExecutorë¡œ ì¬ì‹œë„ ë° ì—ëŸ¬ ì²˜ë¦¬
 * - TransactionManagerë¡œ ì•ˆì „í•œ ì €ì¥
 */
export class CaseGeneratorService {
  private geminiClient: GeminiClient;
  private workflowExecutor: WorkflowExecutor;
  private cinematicImageService: CinematicImageService;

  constructor(geminiClient: GeminiClient) {
    this.geminiClient = geminiClient;
    this.workflowExecutor = new WorkflowExecutor();
    this.cinematicImageService = new CinematicImageService(geminiClient);
  }

  /**
   * ìƒˆë¡œìš´ ì¼€ì´ìŠ¤ ìƒì„± (ê°œì„ ëœ ë²„ì „)
   *
   * ê°œì„ ì‚¬í•­:
   * - CaseValidatorë¡œ ì‚¬ì „/ì‚¬í›„ ê²€ì¦
   * - WorkflowExecutorë¡œ ì¬ì‹œë„ ë° ì—ëŸ¬ ì²˜ë¦¬
   * - TransactionManagerë¡œ ì•ˆì „í•œ ì €ì¥
   *
   * Phase 1: í…ìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë§Œ ìƒì„± (ì´ë¯¸ì§€ëŠ” ì„ íƒ)
   * Phase 2-3: ì´ë¯¸ì§€ í¬í•¨ ìƒì„±
   */
  async generateCase(options: GenerateCaseOptions = {}): Promise<GeneratedCase> {
    const {
      date = new Date(),
      includeImage = false,
      includeSuspectImages = false,
      includeCinematicImages = false,
      temperature = 0.8,
      customCaseId
    } = options;

    console.log(`ğŸ”„ Generating case for ${date.toISOString().split('T')[0]}...`);

    // 1. CaseElementLibraryì—ì„œ ì˜¤ëŠ˜ì˜ ìš”ì†Œ ì„ íƒ
    const elements = CaseElementLibrary.getTodaysCaseElements(date);

    console.log(`ğŸ“š Selected elements:
      - Weapon: ${elements.weapon.name}
      - Motive: ${elements.motive.category}
      - Location: ${elements.location.name}
      - Suspects: ${elements.suspects.map(s => s.archetype).join(', ')}`
    );

    // 1.5. ìš”ì†Œ ì‚¬ì „ ê²€ì¦ (NEW!)
    const elementValidation = CaseValidator.validateCaseElements(elements);
    CaseValidator.logValidationResult(elementValidation, 'Case Elements');

    if (!elementValidation.isValid) {
      throw new Error(`Case element validation failed: ${elementValidation.errors.map(e => e.message).join(', ')}`);
    }

    // 2. ì¼€ì´ìŠ¤ ìŠ¤í† ë¦¬ ìƒì„± (Gemini with Retry)
    const caseStory = await this.workflowExecutor.executeWithRetry(
      () => this.generateCaseStory(
        elements.weapon,
        elements.motive,
        elements.location,
        elements.suspects,
        temperature
      ),
      DEFAULT_RETRY_POLICIES.TEXT_GENERATION,
      'Generate Case Story'
    );

    console.log(`âœ… Case story generated`);

    // 2.5. ìƒì„±ëœ ì¼€ì´ìŠ¤ ì‚¬í›„ ê²€ì¦ (NEW!)
    const storyValidation = CaseValidator.validateGeneratedCase(caseStory);
    CaseValidator.logValidationResult(storyValidation, 'Generated Case Story');

    if (!storyValidation.isValid) {
      throw new Error(`Generated case validation failed: ${storyValidation.errors.map(e => e.message).join(', ')}`);
    }

    // 3. ì¸íŠ¸ë¡œ ë‚˜ë ˆì´ì…˜ ìƒì„± (with Fallback)
    const introNarration = await this.workflowExecutor.executeWithFallback(
      () => this.generateIntroNarration(
        caseStory,
        elements.weapon,
        elements.location,
        temperature
      ),
      () => this.generateFallbackNarration(
        caseStory,
        elements.weapon,
        elements.location
      ),
      'Generate Intro Narration'
    );

    console.log(`âœ… Intro narration generated`);

    // 4. ì¼€ì´ìŠ¤ ì´ë¯¸ì§€ ìƒì„± (ì„ íƒ, with Retry)
    let imageUrl: string | undefined;
    if (includeImage) {
      try {
        imageUrl = await this.workflowExecutor.executeWithRetry(
          () => this.generateCaseImage(
            elements.location,
            elements.weapon,
            caseStory.victim.name
          ),
          DEFAULT_RETRY_POLICIES.IMAGE_GENERATION,
          'Generate Case Image'
        );
        console.log(`âœ… Case image generated`);
      } catch (error) {
        console.warn('âš ï¸  Case image generation failed after retries, continuing without image', error);
        // ì´ë¯¸ì§€ ì‹¤íŒ¨í•´ë„ ì¼€ì´ìŠ¤ëŠ” ìƒì„± (Phase 1 ì² í•™)
      }
    }

    // 5. ìš©ì˜ì í”„ë¡œí•„ ì´ë¯¸ì§€ ìƒì„± (ì„ íƒ)
    const suspectsWithImages = includeSuspectImages
      ? await this.generateSuspectProfileImages(
          caseStory.suspects,
          elements.suspects,
          includeSuspectImages
        )
      : caseStory.suspects;

    // 5.5. ì‹œë„¤ë§ˆí‹± ì¸íŠ¸ë¡œ ì´ë¯¸ì§€ëŠ” ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìƒì„±ë¨ (ìƒíƒœ: pending)
    console.log(`âœ… All generation steps completed (cinematic images will be generated in background)`);

    // 5.6. ì¦ê±° ë°œê²¬ ë°ì´í„° ìƒì„± (saveCaseWithTransaction ì „ì— ìƒì„±)
    const locations = this.generateLocationsForCase(elements.location, elements.weapon);
    const evidence = this.generateEvidenceForCase(
      elements.weapon,
      elements.motive,
      caseStory.suspects
    );

    console.log(`âœ… Discovery data generated: ${locations.length} locations, ${evidence.length} evidence`);

    // 6. íŠ¸ëœì­ì…˜ìœ¼ë¡œ ë°ì´í„° ì €ì¥ (locationsì™€ evidence í¬í•¨)
    const savedCase = await this.saveCaseWithTransaction(
      caseStory,
      elements,
      suspectsWithImages,
      imageUrl,
      introNarration,
      date,
      customCaseId,
      locations,
      evidence
    );

    console.log(`âœ… Case saved with transaction: ${savedCase.id}`);

    // 6.5. ì¦ê±°ë¥¼ ì¥ì†Œì— ë¶„ë°°
    const locationDiscovery = new LocationDiscoveryService();
    const distribution = locationDiscovery.distributeEvidence(
      savedCase.id,
      locations,
      evidence
    );

    // 6.6. ë¶„ë°° ë°ì´í„°ë¥¼ KV Storeì— ì €ì¥ (ë³„ë„ í‚¤ì™€ caseData ì–‘ìª½ì— ì €ì¥)
    await DiscoveryStateManager.saveDistribution(distribution);

    // 6.7. caseDataì—ë„ evidenceDistribution ì¶”ê°€í•˜ê³  ì¬ì €ì¥
    savedCase.evidenceDistribution = distribution;
    // ğŸ”§ FIX: Explicitly preserve locations and evidence fields before re-saving
    // This ensures the second save doesn't lose data from the transaction
    savedCase.locations = locations;
    savedCase.evidence = evidence;
    await KVStoreManager.saveCase(savedCase);

    console.log(`âœ… Evidence distribution saved: ${distribution.totalEvidence} evidence across ${distribution.locations.length} locations`);

    // 7. GeneratedCase í˜•ì‹ìœ¼ë¡œ ë°˜í™˜
    return {
      caseId: savedCase.id,
      id: savedCase.id,        // Alias for backward compatibility
      date: savedCase.date,    // Date string
      victim: savedCase.victim,
      weapon: elements.weapon,
      location: elements.location,
      suspects: savedCase.suspects.map((s, index) => ({
        id: s.id,
        name: s.name,
        archetype: s.archetype,
        background: suspectsWithImages[index].background,
        personality: suspectsWithImages[index].personality,
        isGuilty: s.isGuilty,
        profileImageUrl: suspectsWithImages[index].profileImageUrl
      })),
      solution: savedCase.solution,
      imageUrl: savedCase.imageUrl,
      cinematicImages: undefined, // Will be generated in background
      introNarration: savedCase.introNarration,
      generatedAt: savedCase.generatedAt,
      locations: savedCase.locations,
      evidence: savedCase.evidence,
      evidenceDistribution: savedCase.evidenceDistribution
    };
  }

  /**
   * íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì¼€ì´ìŠ¤ ì €ì¥ (NEW!)
   *
   * TransactionManagerë¥¼ ì‚¬ìš©í•˜ì—¬ ì›ìì  ì €ì¥ ë° ë¡¤ë°± ë³´ì¥
   */
  private async saveCaseWithTransaction(
    caseStory: {
      victim: { name: string; background: string; relationship: string };
      suspects: Array<{ name: string; background: string; personality: string; isGuilty: boolean; profileImageUrl?: string }>;
      solution: {
        who: string;
        what: string;
        where: string;
        when: string;
        why: string;
        how: string;
      };
    },
    elements: {
      weapon: Weapon;
      motive: Motive;
      location: Location;
      suspects: Suspect[];
    },
    suspectsWithImages: Array<{ name: string; background: string; personality: string; isGuilty: boolean; profileImageUrl?: string }>,
    imageUrl: string | undefined,
    introNarration: { atmosphere: string; incident: string; stakes: string },
    date: Date,
    customCaseId?: string,
    locations?: DiscoveryLocation[],
    evidence?: EvidenceItem[]
  ): Promise<CaseData> {
    const targetDate = date;
    const dateStr = targetDate.toISOString().split('T')[0];
    const caseId = customCaseId || `case-${dateStr}`;

    const suspectsWithIds = suspectsWithImages.map((suspect, index) => ({
      id: `${caseId}-suspect-${index + 1}`,
      name: suspect.name,
      archetype: elements.suspects[index].archetype,
      isGuilty: suspect.isGuilty
    }));

    const caseData: CaseData = {
      id: caseId,
      date: dateStr,
      victim: caseStory.victim,
      weapon: { name: elements.weapon.name, description: elements.weapon.description },
      location: { name: elements.location.name, description: elements.location.description },
      suspects: suspectsWithIds,
      solution: caseStory.solution,
      generatedAt: Date.now(),
      imageUrl,
      introNarration,
      locations,
      evidence,
      // ì‹œë„¤ë§ˆí‹± ì´ë¯¸ì§€ëŠ” ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìƒì„±
      cinematicImages: null,
      imageGenerationStatus: 'pending' as ImageGenerationStatus,
      imageGenerationMeta: {
        startedAt: undefined,
        retryCount: 0
      }
    };

    const suspectDataList: SuspectData[] = suspectsWithImages.map((suspect, index) => {
    // Generate AP topics for each suspect
    const apTopics = generateDefaultAPTopics(suspect.isGuilty);

    return {
      id: suspectsWithIds[index].id,
      caseId: caseId,
      name: suspect.name,
      archetype: elements.suspects[index].archetype,
      background: suspect.background,
      personality: suspect.personality,
      isGuilty: suspect.isGuilty,
      emotionalState: {
        suspicionLevel: 0,
        tone: 'cooperative',
        lastUpdated: Date.now()
      },
      profileImageUrl: suspect.profileImageUrl
    }));

    // íŠ¸ëœì­ì…˜ ë‹¨ê³„ ìƒì„±
    const steps = CaseCreationTransaction.createSteps(caseData, suspectDataList, KVStoreManager);

    // íŠ¸ëœì­ì…˜ ì‹¤í–‰ (ì‹¤íŒ¨ ì‹œ ìë™ ë¡¤ë°±)
    const transactionManager = new TransactionManager();
    await transactionManager.executeTransaction(steps);

    console.log(`âœ… Transaction completed in ${transactionManager.getDuration()}ms`);

    return caseData;
  }

  /**
   * ì¸íŠ¸ë¡œ ë‚˜ë ˆì´ì…˜ ìƒì„± (Gemini API)
   */
  private async generateIntroNarration(
    caseStory: {
      victim: { name: string; background: string };
      suspects: Array<{ name: string }>;
    },
    weapon: Weapon,
    location: Location,
    temperature: number
  ): Promise<{ atmosphere: string; incident: string; stakes: string }> {
    const prompt = this.buildIntroNarrationPrompt(
      caseStory,
      weapon,
      location
    );

    const response = await this.geminiClient.generateText(prompt, {
      temperature,
      maxTokens: 1024
    });

    return this.geminiClient.parseJsonResponse(response.text);
  }

  /**
   * Enhanced ì¸íŠ¸ë¡œ ë‚˜ë ˆì´ì…˜ í”„ë¡¬í”„íŠ¸ ìƒì„±
   *
   * Anthropic best practices + literary devices ì ìš©
   * 4 few-shot examples, êµ¬ì²´ì  literary techniques ì§€ì‹œ
   *
   * @see https://github.com/anthropics/courses - Prompt Engineering Best Practices
   */
  private buildIntroNarrationPrompt(
    caseStory: {
      victim: { name: string; background: string };
      suspects: Array<{ name: string }>;
    },
    weapon: Weapon,
    location: Location
  ): string {
    return `# ROLE & EXPERTISE

You are a master detective fiction writer specializing in atmospheric murder mystery narratives. Your work is known for:
- Sensory-rich descriptions that transport readers into the scene
- Psychological tension that builds with each sentence
- Literary devices (metaphor, personification, foreshadowing) seamlessly woven into prose
- Genre-specific vocabulary that evokes classic noir, gothic, or psychological thriller moods

Your influences include Raymond Chandler's hard-boiled prose, Agatha Christie's locked-room mysteries, and Gillian Flynn's psychological depth.

# TONE & STYLE

**Writing Style Requirements:**
- **Immersive**: Every sentence should engage multiple senses
- **Cinematic**: Write as if directing a cameraâ€”what does the reader SEE, HEAR, SMELL?
- **Economical**: Maximum impact with minimum words (no purple prose)
- **Active Voice**: Prefer "The wind clawed at the windows" over "The windows were clawed by the wind"

**Forbidden ClichÃ©s:**
âŒ "It was a dark and stormy night"
âŒ "Little did they know"
âŒ "The calm before the storm"
âŒ Generic descriptions: "beautiful mansion", "scary atmosphere"

# CASE DETAILS

<case_info>
Victim: ${caseStory.victim.name}
Background: ${caseStory.victim.background}
Location: ${location.name} - ${location.description}
Weapon: ${weapon.name}
Suspects: ${caseStory.suspects.length} individuals
</case_info>

# TASK: Generate 3-Phase Narration in Korean

## Phase 1: ATMOSPHERE (50-80 words in Korean)
**Required Elements:**
1. One striking visual hook that defines the scene
2. At least 3 different senses (sight, sound, smell, touch, temperature)
3. Specific time marker (when is this happening?)
4. At least one metaphor, simile, or personification

**Don't**: Explain the mood. **Do**: Show it through concrete details.

## Phase 2: INCIDENT (50-80 words in Korean)
**Required Elements:**
1. Victim's name + position description with visual precision
2. Specific weapon/method with one vivid detail
3. One impossible element (locked from inside, no footprints, evidence contradiction)
4. Forensic poetry (describe violence without being gratuitous)

**Pattern**:
- Discovery (who, where)
- Death details (how)
- The impossibility (locked-room mystery element)
- Evidence contradiction

## Phase 3: STAKES (50-90 words in Korean)
**Required Elements:**
1. Detective identity ("ë‹¹ì‹ ì€...")
2. Specific suspect count with one detail about them
3. Time pressure (why must this be solved NOW?)
4. Challenge framing (what makes this difficult?)
5. Call to action (end with urgency)

**Don't**: Say "ë²”ì¸ì„ ì°¾ì•„ë¼". **Do**: "ê±°ì§“ë§ì˜ ê·¸ë¬¼ì„ í’€ì–´ë‚´ë¼, ê·¸ ì „ì—..."

# FEW-SHOT EXAMPLES (for quality reference)

<example id="gothic">
<atmosphere>
The Blackwood Estate loomed against the storm-torn sky, its gargoyles weeping rainwater like stone tears. Lightning carved the darkness, revealing ivy-choked windows that hadn't seen light in decades. Inside, candles guttered in their holders, throwing monstrous shadows across oil paintings of the long-dead Blackwood lineageâ€”their eyes seeming to follow every movement through the gloom.
</atmosphere>
<incident>
Lord Edmund Blackwood lay sprawled across the library's Persian rug, his silk cravat soaked crimson. The letter openerâ€”family heirloom, silver and jadeâ€”protruded from between his ribs at an impossible angle. Yet the study door remained locked from the inside, its key still clutched in the victim's cooling hand. No footprints marred the dust. No windows stood open to the howling night.
</incident>
<stakes>
You are Detective Inspector Sarah Chen, summoned from London at midnight. Seven family members sheltered within these walls when the scream rang out. The storm has washed out the only roadâ€”no one can leave, no reinforcements can arrive. One of them is a murderer. One of them is lying. And somewhere in this labyrinth of secrets, the truth waits to be unearthed before the killer strikes again.
</stakes>
</example>

<example id="noir">
<atmosphere>
Rain hammered the city like bullets on tin, turning the alley into a river of neon reflections. Cigarette smoke curled from the jazz club's back door, mixing with the stench of wet garbage and something darker. The kind of darkness that clings to your coat and follows you home. A solo saxophone wailed somewhere above, playing a funeral dirge for a city that had forgotten how to mourn.
</atmosphere>
<incident>
Vincent "Ace" Romano would never deal another hand. The casino owner lay face-down in a puddle that wasn't just rainwater, a .38 slug in his backâ€”clean shot, professional work. His diamond pinky ring gleamed under the streetlight, untouched. No robbery, then. This was personal. The murder weapon lay three feet away, wiped clean, almost mocking. Someone wanted to send a message.
</incident>
<stakes>
You're a private eye who owes Ace a favorâ€”the kind that doesn't die with a man. Three suspects were seen leaving the club minutes before the body dropped: his trophy wife, his business partner, and the enforcer he'd just fired. Each has an alibi. Each has a motive. The cops will be here in twenty minutes. That's all the time you've got to read between the lies before this case gets buried under red tape and corruption.
</stakes>
</example>

<example id="psychological">
<atmosphere>
The psychiatric hospital's east wing breathed with unnatural quiet. Fluorescent lights hummed their anxiety-inducing frequency, casting everything in sickly green. Dr. Morrison's office door stood ajarâ€”unusual for a man who locked even his desk drawers. The air tasted of antiseptic and something underneath it, something wrong. A patient's scream echoed from Ward C, then cut off abruptly. Too abruptly.
</atmosphere>
<incident>
Dr. Marcus Morrison, the institution's head psychiatrist, sat rigid in his leather chair, eyes frozen in expression of profound terror. No visible wounds. No signs of struggle. Just a man who'd seen something that stopped his heart. On his desk: patient files scattered, one session recording still playing on loopâ€”a patient's voice whispering, 'He knows. He knows what we did.' The timestamp: three hours before his estimated time of death.
</incident>
<stakes>
You're the detective called in when hospital security found something that doesn't make medical sense. Five patients had appointments with Morrison today. Three have violent histories. Two claimed Morrison was 'getting too close to the truth.' One insists they can't remember their session at all. The hospital director is pressuring for quick resolutionâ€”bad for business, you understand. But in a place where everyone is lying to survive, how do you find the one lie that killed?
</stakes>
</example>

<example id="modern">
<atmosphere>
The penthouse apartment was all glass and chromeâ€”a monument to success that now felt like a display case for death. City lights glittered forty stories below, indifferent witnesses to what happened here. Everything in its place, everything pristine. Except for the body.
</atmosphere>
<incident>
Tech mogul Jennifer Park lay on her designer sofa, champagne flute still gripped in her hand. Poisonâ€”subtle, sophisticated, untraceable without a lab. The security system showed no breaches. The smart locks reported no unauthorized entries. Even the AI assistant had nothing to report. Yet someone had gotten close enough to slip death into her evening drink.
</incident>
<stakes>
You're the detective in a world where technology records everythingâ€”except the truth. Three people had access to this fortress: her business rival, her ex-lover who couldn't let go, and her assistant who knew all her secrets. Each has a digital alibi. Each has a flesh-and-blood motive. In sixty minutes, the lawyers arrive and the evidence gets locked behind NDAs and corporate interests. The clock is ticking, and in this game, the smartest player wins.
</stakes>
</example>

# LITERARY TECHNIQUES TO EMPLOY

**Metaphor Examples:**
- Building as character: "ì €íƒì´ ì¬íŒê´€ì˜ ë§ì¹˜ì²˜ëŸ¼ ìš°ëš ì„°ë‹¤"
- Weather as emotion: "ë¹„ê°€ ë§í•˜ì§€ ëª»í•œ ì§„ì‹¤ì„ ìœ„í•´ ìš¸ì—ˆë‹¤"
- Time as threat: "ì‹œê³„ì˜ ê° ë˜‘ë”± ì†Œë¦¬ê°€ ë˜ í•˜ë‚˜ì˜ ê´€ì„ ëª»ì§ˆí–ˆë‹¤"

**Sensory Details (choose 3+ per phase):**
- Sight: ì¡°ëª…, ê·¸ë¦¼ì, ìƒ‰ ìƒì§•, ì›€ì§ì„
- Sound: í™˜ê²½ìŒ, ëŒë°œìŒ, ì¹¨ë¬µ, ë©”ì•„ë¦¬
- Smell: ë¶€íŒ¨, í–¥ìˆ˜, ìŒì‹, ì—°ê¸°
- Touch: ì˜¨ë„, ì§ˆê°, ìŠµê¸°
- Taste: ë‘ë ¤ì›€ì˜ ê¸ˆì† ë§›, ì“´ ê³µê¸° (rarely)

# OUTPUT FORMAT

Respond ONLY with valid JSON in **KOREAN**:

\`\`\`json
{
  "atmosphere": "[í•œêµ­ì–´ë¡œ 50-80 ë‹¨ì–´, Phase 1 ìš”êµ¬ì‚¬í•­ ì¶©ì¡±]",
  "incident": "[í•œêµ­ì–´ë¡œ 50-80 ë‹¨ì–´, Phase 2 ìš”êµ¬ì‚¬í•­ ì¶©ì¡±]",
  "stakes": "[í•œêµ­ì–´ë¡œ 50-90 ë‹¨ì–´, Phase 3 ìš”êµ¬ì‚¬í•­ ì¶©ì¡±]"
}
\`\`\`

**IMPORTANT**: Generate the narration in KOREAN (í•œêµ­ì–´), using the same quality, literary techniques, and emotional impact as the English examples above.

Generate the narration now.`;
  }

  /**
   * ê¸°ë³¸ ë‚˜ë ˆì´ì…˜ ìƒì„± (Fallback)
   */
  private generateFallbackNarration(
    caseStory: {
      victim: { name: string; background: string };
      suspects: Array<{ name: string }>;
    },
    weapon: Weapon,
    location: Location
  ): { atmosphere: string; incident: string; stakes: string } {
    return {
      atmosphere: `${location.name}. ì–´ë‘ ì´ ë‚´ë ¤ì•‰ì€ ë°¤, ê¸´ì¥ê°ì´ ê°ëˆë‹¤. ë¬´ì–¸ê°€ ë”ì°í•œ ì¼ì´ ì¼ì–´ë‚¬ë‹¤.`,
      incident: `${caseStory.victim.name}ì´(ê°€) ${location.name}ì—ì„œ ì‚¬ë§í•œ ì±„ ë°œê²¬ë˜ì—ˆë‹¤. ${weapon.name}ì´(ê°€) í˜„ì¥ì— ìˆë‹¤. ì¹¨ì… í”ì ì€ ì—†ë‹¤.`,
      stakes: `ë‹¹ì‹ ì€ í˜•ì‚¬ë‹¤. ${caseStory.suspects.length}ëª…ì˜ ìš©ì˜ìê°€ ìˆë‹¤. ì§„ì‹¤ì„ ë°í˜€ë‚´ì•¼ í•œë‹¤.`
    };
  }

  /**
   * ì¼€ì´ìŠ¤ ìŠ¤í† ë¦¬ ìƒì„± (Gemini)
   */
  private async generateCaseStory(
    weapon: Weapon,
    motive: Motive,
    location: Location,
    suspectArchetypes: Suspect[],
    temperature: number
  ): Promise<{
    victim: { name: string; background: string; relationship: string };
    suspects: Array<{
      name: string;
      background: string;
      personality: string;
      isGuilty: boolean;
    }>;
    solution: {
      who: string;
      what: string;
      where: string;
      when: string;
      why: string;
      how: string;
    };
  }> {
    const prompt = this.buildCaseStoryPrompt(weapon, motive, location, suspectArchetypes);

    const response = await this.geminiClient.generateText(prompt, {
      temperature,
      maxTokens: 4096
    });

    // JSON íŒŒì‹±
    return this.geminiClient.parseJsonResponse(response.text);
  }

  /**
   * ì¼€ì´ìŠ¤ ìŠ¤í† ë¦¬ ìƒì„± í”„ë¡¬í”„íŠ¸
   */
  private buildCaseStoryPrompt(
    weapon: Weapon,
    motive: Motive,
    location: Location,
    suspectArchetypes: Suspect[]
  ): string {
    return `ë‹¹ì‹ ì€ íƒì • ì†Œì„¤ ì‘ê°€ì…ë‹ˆë‹¤. ë‹¤ìŒ ìš”ì†Œë“¤ì„ ì‚¬ìš©í•˜ì—¬ í”Œë ˆì´ ê°€ëŠ¥í•œ ì‚´ì¸ ë¯¸ìŠ¤í„°ë¦¬ ì¼€ì´ìŠ¤ë¥¼ ìƒì„±í•˜ì„¸ìš”.

**ì œì•½ ì¡°ê±´:**
- ë¬´ê¸°: ${weapon.name} (${weapon.description})
- ë™ê¸°: ${motive.category} (${motive.description})
- ì¥ì†Œ: ${location.name} (${location.description})
- ì¥ì†Œ ì†Œí’ˆ: ${location.props.join(', ')}
- ìš©ì˜ì ì›í˜•: ${suspectArchetypes.map((s, i) => `${i + 1}. ${s.archetype}`).join(', ')}

**ìƒì„± ê·œì¹™:**
1. **í”¼í•´ì**: í•œêµ­ ì´ë¦„, ì„¤ë“ë ¥ ìˆëŠ” ë°°ê²½ ìŠ¤í† ë¦¬, ìš©ì˜ìë“¤ê³¼ì˜ ê´€ê³„
2. **ìš©ì˜ì 3ëª…**:
   - ê°ê° í•œêµ­ ì´ë¦„
   - ì œê³µëœ ì›í˜•ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ìƒì„¸í•œ ë°°ê²½
   - ë…íŠ¹í•œ ì„±ê²© íŠ¹ì„±
   - í•œ ëª…ë§Œ ì§„ë²” (isGuilty: true)
3. **í•´ê²°ì±… (5W1H)**:
   - WHO: ë²”ì¸ì˜ ì´ë¦„
   - WHAT: ì •í™•í•œ ì‚´ì¸ ë°©ë²•
   - WHERE: êµ¬ì²´ì ì¸ ì¥ì†Œ (${location.props.join(' ë˜ëŠ” ')} ì¤‘ í•˜ë‚˜)
   - WHEN: ì‹œê°„ëŒ€
   - WHY: ëª…í™•í•œ ë™ê¸°
   - HOW: ìƒì„¸í•œ ì‹¤í–‰ ë°©ë²•

**ì¤‘ìš”**:
- ì§„ë²”ì€ 3ëª… ì¤‘ ì •í™•íˆ 1ëª…ë§Œ
- ë‹¤ë¥¸ 2ëª…ì€ ì•Œë¦¬ë°”ì´ê°€ ìˆê±°ë‚˜ ì˜ì‹¬ìŠ¤ëŸ½ì§€ë§Œ ê²°ë°±í•¨
- í•´ê²°ì±…ì€ ë…¼ë¦¬ì ì´ê³  ì¦ëª… ê°€ëŠ¥í•´ì•¼ í•¨

**ì‘ë‹µ í˜•ì‹ (JSON):**
\`\`\`json
{
  "victim": {
    "name": "ê¹€ëª…ìˆ˜",
    "background": "50ëŒ€ ì¤‘ë°˜ì˜ ì„±ê³µí•œ ì‚¬ì—…ê°€...",
    "relationship": "ìš©ì˜ìë“¤ê³¼ì˜ ê´€ê³„ ì„¤ëª…..."
  },
  "suspects": [
    {
      "name": "ì´ì„œì—°",
      "background": "í”¼í•´ìì˜ ë¹„ì¦ˆë‹ˆìŠ¤ íŒŒíŠ¸ë„ˆë¡œ...",
      "personality": "ëƒ‰ì² í•˜ê³  ê³„ì‚°ì ì´ë©°...",
      "isGuilty": false
    },
    {
      "name": "ë°•ì¤€í˜¸",
      "background": "í”¼í•´ìì˜ ì˜¤ëœ ì¹œêµ¬ì´ì...",
      "personality": "ì¶©ë™ì ì´ê³  ê°ì •ì ì´ë©°...",
      "isGuilty": true
    },
    {
      "name": "ìµœë¯¼ì§€",
      "background": "í”¼í•´ìì˜ ì „ ë¶€ì¸ìœ¼ë¡œ...",
      "personality": "ì°¨ë¶„í•˜ì§€ë§Œ ë³µìˆ˜ì‹¬ì´...",
      "isGuilty": false
    }
  ],
  "solution": {
    "who": "ë°•ì¤€í˜¸",
    "what": "${weapon.name}ì„(ë¥¼) ì‚¬ìš©í•œ ì‚´ì¸",
    "where": "${location.name}ì˜ ${location.props[0]} ê·¼ì²˜",
    "when": "2024ë…„ 1ì›” 15ì¼ ì˜¤í›„ 11ì‹œ 30ë¶„ê²½",
    "why": "${motive.category} - êµ¬ì²´ì ì¸ ì´ìœ ...",
    "how": "ìƒì„¸í•œ ë²”í–‰ ë°©ë²•..."
  }
}
\`\`\`

JSONë§Œ ì‘ë‹µí•˜ì„¸ìš”. ë‹¤ë¥¸ ì„¤ëª…ì€ í•„ìš” ì—†ìŠµë‹ˆë‹¤.`;
  }

  /**
   * ì¼€ì´ìŠ¤ ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸
   */
  private async generateCaseImage(
    location: Location,
    weapon: Weapon,
    victimName: string
  ): Promise<string> {
    const imagePrompt = this.buildImagePrompt(location, weapon, victimName);

    const response = await this.geminiClient.generateImage(imagePrompt);

    return response.imageUrl;
  }

  /**
   * ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸
   */
  private buildImagePrompt(
    location: Location,
    weapon: Weapon,
    victimName: string
  ): string {
    return `Crime scene illustration: ${location.name}, ${location.atmosphere}.
Scene includes ${location.props.slice(0, 3).join(', ')}.
Evidence of ${weapon.name}.
Dark, moody lighting.
Professional detective game art style.
No text, no people visible.
High quality, detailed, atmospheric.`;
  }

  /**
   * ìš©ì˜ì í”„ë¡œí•„ ì´ë¯¸ì§€ ìƒì„± (ìˆœì°¨ ì²˜ë¦¬)
   *
   * Phase 1 ìˆ˜ì •: ë³‘ë ¬ â†’ ìˆœì°¨ ì‹¤í–‰ìœ¼ë¡œ ë³€ê²½
   * - Gemini API rate limiting ìš°íšŒ
   * - ê° ì´ë¯¸ì§€ê°€ ì™„ì „íˆ ìƒì„±ëœ í›„ ë‹¤ìŒ ì´ë¯¸ì§€ ìƒì„±
   * - ì‹œê°„ì€ ëŠ˜ì–´ë‚˜ì§€ë§Œ(~15ì´ˆ) ì„±ê³µë¥  í–¥ìƒ
   */
  private async generateSuspectProfileImages(
    suspects: Array<{
      name: string;
      background: string;
      personality: string;
      isGuilty: boolean;
    }>,
    archetypes: Suspect[],
    shouldGenerate: boolean
  ): Promise<Array<{
    name: string;
    background: string;
    personality: string;
    isGuilty: boolean;
    profileImageUrl?: string;
  }>> {
    if (!shouldGenerate) {
      console.log('â­ï¸  Skipping suspect profile image generation');
      return suspects;
    }

    console.log('ğŸ¨ Generating profile images for suspects (sequential)...');

    // ìˆœì°¨ ì²˜ë¦¬ë¡œ Gemini API rate limiting ìš°íšŒ
    const results: Array<{
      name: string;
      background: string;
      personality: string;
      isGuilty: boolean;
      profileImageUrl?: string;
    }> = [];

    for (let index = 0; index < suspects.length; index++) {
      const suspect = suspects[index];
      try {
        console.log(`ğŸ¨ Generating image ${index + 1}/${suspects.length}: ${suspect.name}...`);

        const prompt = this.buildSuspectProfilePrompt(
          suspect,
          archetypes[index]
        );

        const response = await this.geminiClient.generateImage(prompt);

        console.log(`âœ… Profile image generated for ${suspect.name}`);

        results.push({
          ...suspect,
          profileImageUrl: response.imageUrl
        });
      } catch (error) {
        console.error(`âŒ Profile image generation failed for ${suspect.name}:`, error);
        // ì´ë¯¸ì§€ ì‹¤íŒ¨í•´ë„ ìš©ì˜ì ë°ì´í„°ëŠ” ìœ ì§€
        results.push(suspect);
      }
    }

    console.log(`âœ… Suspect profile images generated: ${results.filter(r => r.profileImageUrl).length}/${suspects.length}`);

    return results;
  }

  /**
   * ìš©ì˜ì í”„ë¡œí•„ ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ ìƒì„±
   */
  private buildSuspectProfilePrompt(
    suspect: {
      name: string;
      background: string;
      personality: string;
    },
    archetype: Suspect
  ): string {
    return `Professional portrait photograph of a ${archetype.archetype}.
Character: ${suspect.name}
Background: ${suspect.background}
Personality: ${suspect.personality}
Style: Professional headshot, cinematic lighting, shallow depth of field, neutral background.
Focus: Face and upper shoulders, direct eye contact with camera.
Quality: Photorealistic, high detail, professional photography.
Format: 512x512 portrait photograph.
Mood: Mystery, intrigue, subtle emotional expression.`;
  }

  /**
   * ì¼€ì´ìŠ¤ì— ëŒ€í•œ ì¥ì†Œ ìƒì„±
   *
   * @param location - ë²”ì£„ í˜„ì¥ ì •ë³´
   * @param weapon - ì‚¬ìš©ëœ ë¬´ê¸°
   * @returns 4ê°œì˜ íƒìƒ‰ ê°€ëŠ¥í•œ ì¥ì†Œ
   */
  private generateLocationsForCase(
    location: Location,
    weapon: Weapon
  ): DiscoveryLocation[] {
    return [
      {
        id: 'crime-scene',
        name: location.name,
        description: `ë²”ì£„ í˜„ì¥. ${location.description}`,
        emoji: 'ğŸ”'
      },
      {
        id: 'victim-residence',
        name: 'í”¼í•´ìì˜ ê±°ì£¼ì§€',
        description: 'í”¼í•´ìê°€ ì‚´ë˜ ê³³. ê°œì¸ì ì¸ ë¬¼ê±´ê³¼ í”ì ì´ ë‚¨ì•„ìˆë‹¤.',
        emoji: 'ğŸ '
      },
      {
        id: 'suspect-location',
        name: 'ìš©ì˜ì ê´€ë ¨ ì¥ì†Œ',
        description: 'ë²”ì¸ê³¼ ì—°ê´€ëœ ì¥ì†Œ. ì¤‘ìš”í•œ ë‹¨ì„œê°€ ìˆì„ ìˆ˜ ìˆë‹¤.',
        emoji: 'ğŸ“'
      },
      {
        id: 'witness-area',
        name: 'ëª©ê²©ì ì§€ì—­',
        description: 'ì‚¬ê±´ ë‹¹ì‹œ ëª©ê²©ìë“¤ì´ ìˆë˜ êµ¬ì—­. ì¶”ê°€ ì •ë³´ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤.',
        emoji: 'ğŸ‘¥'
      }
    ];
  }

  /**
   * ì¼€ì´ìŠ¤ì— ëŒ€í•œ ì¦ê±° ìƒì„±
   *
   * @param weapon - ì‚¬ìš©ëœ ë¬´ê¸°
   * @param motive - ë²”í–‰ ë™ê¸°
   * @param suspects - ìš©ì˜ì ëª©ë¡
   * @returns 10ê°œì˜ ì¦ê±° (4 critical, 3 supporting, 3 red herrings)
   */
  private generateEvidenceForCase(
    weapon: Weapon,
    motive: Motive,
    suspects: Array<{ name: string; isGuilty: boolean }>
  ): EvidenceItem[] {
    // ë²”ì¸ ì°¾ê¸°
    const guiltyIndex = suspects.findIndex(s => s.isGuilty);
    const guiltyName = suspects[guiltyIndex]?.name || 'ì•Œ ìˆ˜ ì—†ìŒ';

    const evidence: EvidenceItem[] = [];

    // Critical Evidence (4ê°œ) - ë²”ì¸ì„ ê°€ë¦¬í‚¤ëŠ” ê²°ì •ì  ì¦ê±°
    evidence.push({
      id: 'evidence-critical-1',
      type: 'physical',
      name: `${weapon.name} ë°œê²¬`,
      description: `ë²”í–‰ì— ì‚¬ìš©ëœ ${weapon.name}ì´(ê°€) ë°œê²¬ë˜ì—ˆë‹¤. ${weapon.description}`,
      discoveryHint: 'ë²”ì£„ í˜„ì¥ì„ ì£¼ì˜ ê¹Šê²Œ ì‚´í´ë³´ì„¸ìš”.',
      interpretationHint: `ì´ ë¬´ê¸°ëŠ” ${guiltyName}ì˜ ì†Œìœ ë¬¼ë¡œ ì¶”ì •ë©ë‹ˆë‹¤.`,
      relevance: 'critical',
      pointsToSuspect: guiltyIndex
    });

    evidence.push({
      id: 'evidence-critical-2',
      type: 'forensic',
      name: 'ì§€ë¬¸ ë¶„ì„ ê²°ê³¼',
      description: 'ë²”í–‰ í˜„ì¥ì—ì„œ ì±„ì·¨í•œ ì§€ë¬¸ì´ íŠ¹ì • ì¸ë¬¼ê³¼ ì¼ì¹˜í•©ë‹ˆë‹¤.',
      discoveryHint: 'ê°ì‹íŒ€ì˜ ë³´ê³ ì„œë¥¼ í™•ì¸í•˜ì„¸ìš”.',
      interpretationHint: `ì§€ë¬¸ì€ ${guiltyName}ì˜ ê²ƒìœ¼ë¡œ í™•ì¸ë˜ì—ˆìŠµë‹ˆë‹¤.`,
      relevance: 'critical',
      pointsToSuspect: guiltyIndex
    });

    evidence.push({
      id: 'evidence-critical-3',
      type: 'communication',
      name: 'í˜‘ë°• ë©”ì‹œì§€',
      description: `í”¼í•´ìì—ê²Œ ë³´ë‚¸ í˜‘ë°• ë©”ì‹œì§€ê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤. ë™ê¸°: ${motive.category}`,
      discoveryHint: 'í”¼í•´ìì˜ íœ´ëŒ€í°ì„ ì¡°ì‚¬í•˜ì„¸ìš”.',
      interpretationHint: `ë°œì‹ ìëŠ” ${guiltyName}ì…ë‹ˆë‹¤.`,
      relevance: 'critical',
      pointsToSuspect: guiltyIndex
    });

    evidence.push({
      id: 'evidence-critical-4',
      type: 'alibi',
      name: 'ëª©ê²©ì ì§„ìˆ ',
      description: 'ì‚¬ê±´ ë‹¹ì‹œ íŠ¹ì • ì¸ë¬¼ì´ í˜„ì¥ ê·¼ì²˜ì— ìˆì—ˆë‹¤ëŠ” ëª©ê²© ì¦ì–¸.',
      discoveryHint: 'ì£¼ë³€ ëª©ê²©ìë“¤ê³¼ ëŒ€í™”í•˜ì„¸ìš”.',
      interpretationHint: `ëª©ê²©ìëŠ” ${guiltyName}ì„(ë¥¼) ë´¤ë‹¤ê³  ì§„ìˆ í–ˆìŠµë‹ˆë‹¤.`,
      relevance: 'critical',
      pointsToSuspect: guiltyIndex
    });

    // Supporting Evidence (3ê°œ) - ë³´ì¡° ì¦ê±°
    evidence.push({
      id: 'evidence-supporting-1',
      type: 'financial',
      name: 'ê¸ˆìœµ ê±°ë˜ ê¸°ë¡',
      description: 'ìˆ˜ìƒí•œ ê¸ˆìœµ ê±°ë˜ ë‚´ì—­ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.',
      discoveryHint: 'í”¼í•´ìì˜ ì€í–‰ ê³„ì¢Œë¥¼ ì¶”ì í•˜ì„¸ìš”.',
      interpretationHint: 'ë²”í–‰ ë™ê¸°ì™€ ì—°ê´€ì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
      relevance: 'important'
    });

    evidence.push({
      id: 'evidence-supporting-2',
      type: 'documentary',
      name: 'ê³„ì•½ì„œ ì‚¬ë³¸',
      description: 'í”¼í•´ìì™€ ìš©ì˜ì ê°„ì˜ ê³„ì•½ ë¬¸ì„œê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.',
      discoveryHint: 'í”¼í•´ìì˜ ì„œë¥˜ë¥¼ ê²€í† í•˜ì„¸ìš”.',
      interpretationHint: 'ê´€ê³„ì˜ ì„±ê²©ì„ íŒŒì•…í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤.',
      relevance: 'important'
    });

    evidence.push({
      id: 'evidence-supporting-3',
      type: 'testimony',
      name: 'ì£¼ë³€ì¸ ì¦ì–¸',
      description: 'í”¼í•´ìì™€ ìš©ì˜ìì˜ ê´€ê³„ì— ëŒ€í•œ ì œ3ì ì¦ì–¸.',
      discoveryHint: 'ì£¼ë³€ ì‚¬ëŒë“¤ê³¼ ì¸í„°ë·°í•˜ì„¸ìš”.',
      interpretationHint: 'ì‚¬ê±´ ë°°ê²½ì„ ì´í•´í•˜ëŠ” ë° ìœ ìš©í•©ë‹ˆë‹¤.',
      relevance: 'important'
    });

    // Red Herrings (3ê°œ) - í˜¼ë€ì„ ì£¼ëŠ” ì¦ê±°
    const innocentIndices = suspects
      .map((s, i) => ({ index: i, guilty: s.isGuilty }))
      .filter(s => !s.guilty)
      .map(s => s.index);

    evidence.push({
      id: 'evidence-redherring-1',
      type: 'physical',
      name: 'ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë¬¼ê±´',
      description: 'í˜„ì¥ì—ì„œ ë°œê²¬ëœ ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë¬¼ê±´ì´ì§€ë§Œ ë²”í–‰ê³¼ëŠ” ë¬´ê´€í•©ë‹ˆë‹¤.',
      discoveryHint: 'í˜„ì¥ì„ ì² ì €íˆ ìˆ˜ìƒ‰í•˜ì„¸ìš”.',
      interpretationHint: 'ì´ ì¦ê±°ëŠ” ì‹¤ì œ ë²”ì¸ê³¼ ê´€ë ¨ì´ ì—†ìŠµë‹ˆë‹¤.',
      relevance: 'minor',
      pointsToSuspect: innocentIndices[0]
    });

    evidence.push({
      id: 'evidence-redherring-2',
      type: 'alibi',
      name: 'ì˜ëª»ëœ ëª©ê²© ì •ë³´',
      description: 'ì‚¬ê±´ê³¼ ë¬´ê´€í•œ ì‹œê°„ëŒ€ì˜ ëª©ê²© ì •ë³´ì…ë‹ˆë‹¤.',
      discoveryHint: 'ëª©ê²©ìë“¤ì˜ ì§„ìˆ ì„ ìˆ˜ì§‘í•˜ì„¸ìš”.',
      interpretationHint: 'ì´ ì •ë³´ëŠ” ì‚¬ê±´ê³¼ ë¬´ê´€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
      relevance: 'minor',
      pointsToSuspect: innocentIndices[1]
    });

    evidence.push({
      id: 'evidence-redherring-3',
      type: 'communication',
      name: 'ì˜¤í•´ì˜ ì†Œì§€ê°€ ìˆëŠ” ëŒ€í™”',
      description: 'ì˜ì‹¬ìŠ¤ëŸ¬ì›Œ ë³´ì´ì§€ë§Œ ì‹¤ì œë¡œëŠ” ë¬´ê´€í•œ ëŒ€í™” ê¸°ë¡.',
      discoveryHint: 'í†µì‹  ê¸°ë¡ì„ ë¶„ì„í•˜ì„¸ìš”.',
      interpretationHint: 'ë§¥ë½ì„ ê³ ë ¤í•˜ë©´ ë²”í–‰ê³¼ ë¬´ê´€í•©ë‹ˆë‹¤.',
      relevance: 'minor',
      pointsToSuspect: innocentIndices[0]
    });

    return evidence;
  }

  /**
   * ì˜¤ëŠ˜ì˜ ì¼€ì´ìŠ¤ ì¡°íšŒ ë˜ëŠ” ìƒì„±
   */
  async getTodaysCase(options: { includeImage?: boolean; includeSuspectImages?: boolean } = {}): Promise<GeneratedCase> {
    // ì´ë¯¸ ìƒì„±ëœ ì¼€ì´ìŠ¤ê°€ ìˆëŠ”ì§€ í™•ì¸
    const existingCase = await CaseRepository.getTodaysCase();

    if (existingCase) {
      console.log(`âœ… Today's case already exists: ${existingCase.id}`);

      // GeneratedCase í˜•ì‹ìœ¼ë¡œ ë³€í™˜
      const suspects = await CaseRepository.getCaseSuspects(existingCase.id);

      return {
        caseId: existingCase.id,
        id: existingCase.id,        // Alias for backward compatibility
        date: existingCase.date,    // Date string
        victim: existingCase.victim,
        weapon: existingCase.weapon as Weapon,
        location: existingCase.location as Location,
        suspects: suspects.map(s => ({
          id: s.id,
          name: s.name,
          archetype: s.archetype,
          background: s.background,
          personality: s.personality,
          isGuilty: s.isGuilty,
          profileImageUrl: s.profileImageUrl
        })),
        solution: existingCase.solution,
        imageUrl: existingCase.imageUrl,
        introNarration: existingCase.introNarration,
        generatedAt: existingCase.generatedAt,
        locations: existingCase.locations,
        evidence: existingCase.evidence,
        evidenceDistribution: existingCase.evidenceDistribution
      };
    }

    // ìƒˆë¡œ ìƒì„±
    console.log(`ğŸ”„ Generating today's case...`);
    return await this.generateCase({
      date: new Date(),
      includeImage: options.includeImage,
      includeSuspectImages: options.includeSuspectImages
    });
  }

  /**
   * íŠ¹ì • ë‚ ì§œì˜ ì¼€ì´ìŠ¤ ì¡°íšŒ ë˜ëŠ” ìƒì„±
   */
  async getCaseForDate(
    date: Date,
    options: { includeImage?: boolean; includeSuspectImages?: boolean } = {}
  ): Promise<GeneratedCase> {
    const dateStr = date.toISOString().split('T')[0];
    const existingCase = await CaseRepository.getCaseByDate(dateStr);

    if (existingCase) {
      console.log(`âœ… Case already exists for ${dateStr}: ${existingCase.id}`);

      const suspects = await CaseRepository.getCaseSuspects(existingCase.id);

      return {
        caseId: existingCase.id,
        id: existingCase.id,        // Alias for backward compatibility
        date: existingCase.date,    // Date string
        victim: existingCase.victim,
        weapon: existingCase.weapon as Weapon,
        location: existingCase.location as Location,
        suspects: suspects.map(s => ({
          id: s.id,
          name: s.name,
          archetype: s.archetype,
          background: s.background,
          personality: s.personality,
          isGuilty: s.isGuilty,
          profileImageUrl: s.profileImageUrl
        })),
        solution: existingCase.solution,
        imageUrl: existingCase.imageUrl,
        introNarration: existingCase.introNarration,
        generatedAt: existingCase.generatedAt,
        locations: existingCase.locations,
        evidence: existingCase.evidence,
        evidenceDistribution: existingCase.evidenceDistribution
      };
    }

    // ìƒˆë¡œ ìƒì„±
    console.log(`ğŸ”„ Generating case for ${dateStr}...`);
    return await this.generateCase({
      date,
      includeImage: options.includeImage,
      includeSuspectImages: options.includeSuspectImages
    });
  }
}

/**
 * ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± í—¬í¼
 */
export function createCaseGeneratorService(geminiClient: GeminiClient): CaseGeneratorService {
  return new CaseGeneratorService(geminiClient);
}
