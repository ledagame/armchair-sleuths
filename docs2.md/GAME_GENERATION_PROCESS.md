# 게임 생성 프로세스 완전 가이드

**작성일**: 2025-01-15  
**버전**: 1.0  
**목적**: Murder Mystery 게임이 어떻게 생성되는지 전체 프로세스 문서화

---

## 📋 목차

1. [핵심 질문과 답변](#핵심-질문과-답변)
2. [MECE 분해: 3대 핵심 단계](#mece-분해-3대-핵심-단계)
3. [Level 2: 세부 프로세스](#level-2-세부-프로세스)
4. [실제 실행 시나리오](#실제-실행-시나리오)
5. [전체 아키텍처](#전체-아키텍처)
6. [핵심 포인트 정리](#핵심-포인트-정리)

---

## 핵심 질문과 답변

### Q: `npx tsx scripts/test-game-flow.ts`를 실행하면 새로운 게임이 생성되는가?

**A: 부분적으로 새로운 게임이 생성됩니다.**

- ✅ **같은 부분**: 무기, 장소, 용의자 원형 (날짜 기반으로 고정)
- 🎲 **다른 부분**: 피해자 이름, 용의자 이름, 배경 스토리, 성격, 구체적인 해결책 (AI가 매번 새로 생성)

### Q: 매일 게임이 바뀌는가?

**A: 네, 날짜가 바뀌면 완전히 다른 게임이 생성됩니다.**

- 다른 날짜 = 다른 무기, 장소, 용의자 원형
- 같은 날짜 = 같은 요소, 하지만 AI가 다른 스토리 생성 가능

---

## MECE 분해: 3대 핵심 단계

```
게임 생성 프로세스
├─ A. 요소 선택 (Deterministic - 결정론적)
├─ B. 스토리 생성 (Non-deterministic - 비결정론적)
└─ C. 저장 및 재사용 (Caching - 캐싱)
```

### A. 요소 선택 (Deterministic)

**특징**: 날짜를 기반으로 일관된 게임 요소 선택

- ✅ 같은 날짜 = 같은 시드 = 같은 요소
- ✅ 다른 날짜 = 다른 시드 = 다른 요소
- ✅ 완전히 결정론적 (예측 가능)

### B. 스토리 생성 (Non-deterministic)

**특징**: AI를 사용하여 구체적인 스토리 생성

- 🎲 같은 프롬프트라도 매번 다른 스토리
- 🎲 Temperature 0.8 (높은 창의성)
- 🎲 피해자 이름, 용의자 이름, 배경, 성격 모두 다름

### C. 저장 및 재사용 (Caching)

**특징**: 같은 날짜에 중복 생성 방지

- ✅ 프로덕션: 하루에 한 번만 생성
- ✅ 테스트: 매번 새로 생성 (덮어쓰기)

---

## Level 2: 세부 프로세스

### A. 요소 선택 (Deterministic)

#### A1. 날짜 시드 계산

```typescript
seed = year * 10000 + (month + 1) * 100 + day
// 예: 2025-01-15 → 20250115
```

**특징**:
- 같은 날짜 = 같은 시드
- 다른 날짜 = 다른 시드
- 완전히 결정론적

#### A2. 요소 라이브러리에서 선택

**선택 방법**:

| 요소 | 개수 | 선택 공식 |
|------|------|-----------|
| 무기 (Weapon) | 6종 | `seed % 6` |
| 동기 (Motive) | 5종 | `seed % 5` |
| 장소 (Location) | 5종 | `seed % 5` |
| 용의자 원형 | 5종 중 3개 | `(seed + i*7) % 5` |
| 증거 타입 | 5종 중 4개 | `(seed + i*7) % 5` |

**라이브러리 내용**:

```typescript
// 무기 6종
['독극물', '둔기', '날카로운 흉기', '총기', '질식', '추락']

// 동기 5종
['금전', '복수', '질투', '비밀 은폐', '우발적']

// 장소 5종
['밀실 서재', '저택 정원', '미술관 전시실', '호화 요트', '극장 무대 뒤']

// 용의자 원형 5종
['부유한 상속자', '충실한 집사', '예술가', '사업 동업자', '전직 경찰']
```

**결과**:
- 2025-01-15에 실행 → 항상 같은 무기, 장소, 용의자 원형
- 2025-01-16에 실행 → 다른 조합

---

### B. 스토리 생성 (Non-deterministic)

#### B1. AI 프롬프트 구성

**입력 데이터**:
```typescript
{
  weapon: "독극물",
  motive: "금전",
  location: "밀실 서재",
  suspectArchetypes: ["부유한 상속자", "충실한 집사", "예술가"]
}
```

**프롬프트 구조**:
```
당신은 탐정 소설 작가입니다.

제약 조건:
- 무기: [선택된 무기]
- 동기: [선택된 동기]
- 장소: [선택된 장소]
- 용의자 원형: [선택된 3개 원형]

생성 규칙:
1. 피해자: 한국 이름, 배경, 관계
2. 용의자 3명: 각각 이름, 배경, 성격, 진범 여부
3. 해결책 (5W1H): WHO, WHAT, WHERE, WHEN, WHY, HOW

응답 형식: JSON
```

#### B2. Gemini API 호출

**설정**:
```typescript
{
  temperature: 0.8,  // 🎲 창의성 높음 (0.0~1.0)
  maxTokens: 4096
}
```

**Temperature의 의미**:
- `0.0`: 완전히 결정론적 (항상 같은 답변)
- `0.8`: 높은 창의성 (매번 다른 답변) ← 현재 설정
- `1.0`: 최대 무작위성

**결과**:
- 🎲 같은 프롬프트라도 매번 다른 스토리 생성
- 🎲 피해자 이름, 용의자 이름, 배경, 성격 모두 다름
- 🎲 진범도 3명 중 무작위로 선택됨

#### B3. JSON 파싱

**생성되는 데이터 구조**:
```json
{
  "victim": {
    "name": "김명수",
    "background": "50대 중반의 성공한 사업가...",
    "relationship": "용의자들과의 관계..."
  },
  "suspects": [
    {
      "name": "이서연",
      "background": "피해자의 비즈니스 파트너로...",
      "personality": "냉철하고 계산적이며...",
      "isGuilty": false
    },
    {
      "name": "박준호",
      "background": "피해자의 오랜 친구이자...",
      "personality": "충동적이고 감정적이며...",
      "isGuilty": true
    },
    {
      "name": "최민지",
      "background": "피해자의 전 부인으로...",
      "personality": "차분하지만 복수심이...",
      "isGuilty": false
    }
  ],
  "solution": {
    "who": "박준호",
    "what": "독극물을 사용한 살인",
    "where": "밀실 서재의 책장 근처",
    "when": "2024년 1월 15일 오후 11시 30분경",
    "why": "금전 - 유산 상속 문제...",
    "how": "상세한 범행 방법..."
  }
}
```

---

### C. 저장 및 재사용 (Caching)

#### C1. 기존 케이스 확인

**프로덕션 환경** (`getTodaysCase()` 사용 시):
```typescript
// 1. 오늘 날짜로 케이스 조회
const existingCase = await CaseRepository.getTodaysCase();

if (existingCase) {
  // 이미 있으면 재사용
  return existingCase;
}

// 2. 없으면 새로 생성
return await generateCase();
```

**테스트 스크립트** (`generateCase()` 직접 호출 시):
```typescript
// 캐시 확인 없이 무조건 새로 생성
const caseData = await caseGenerator.generateCase({ date: testDate });
```

#### C2. 새 케이스 저장

**저장 위치**:
```
local-data/
├─ case_case-2025-01-15.json          # 케이스 메타데이터
├─ case_case-2025-01-15_suspects.json # 용의자 목록
└─ case_case-2025-01-15_submissions.json # 제출 답안
```

**저장 데이터**:
```typescript
{
  id: "case-2025-01-15",
  date: "2025-01-15",
  victim: { ... },
  weapon: { ... },
  location: { ... },
  suspects: [ ... ],
  solution: { ... },
  imageUrl: "...",
  generatedAt: 1705305600000
}
```

#### C3. 케이스 반환

**반환 형식**:
```typescript
interface GeneratedCase {
  caseId: string;
  id: string;
  date: string;
  victim: { ... };
  weapon: Weapon;
  location: Location;
  suspects: Suspect[];
  solution: Solution;
  imageUrl?: string;
  generatedAt: number;
}
```

---

## 실제 실행 시나리오

### 시나리오 1: 테스트 스크립트 (현재)

```bash
npx tsx scripts/test-game-flow.ts
```

**실행 흐름**:
```
1. generateCase() 직접 호출
   ↓
2. 날짜 시드로 요소 선택 (같은 날짜 = 같은 요소)
   - 무기: 독극물
   - 장소: 밀실 서재
   - 용의자 원형: [상속자, 집사, 예술가]
   ↓
3. Gemini AI로 스토리 생성 (매번 다름)
   - 피해자: "김명수" (첫 실행)
   - 피해자: "박철수" (두 번째 실행)
   - 용의자 이름, 배경, 성격 모두 다름
   ↓
4. 저장 (덮어쓰기)
   ↓
5. 반환
```

**결과**:
- ✅ 같은 날짜에 여러 번 실행 가능
- 🎲 매번 다른 스토리 생성 (같은 요소 사용)
- ⚠️ 이전 케이스 덮어쓰기

### 시나리오 2: 프로덕션 환경

```typescript
const caseData = await caseGenerator.getTodaysCase();
```

**실행 흐름**:
```
1. getTodaysCase() 호출
   ↓
2. 기존 케이스 확인
   ├─ 있음 → 재사용 (생성 안 함)
   └─ 없음 → 새로 생성
       ↓
       3. 날짜 시드로 요소 선택
       ↓
       4. Gemini AI로 스토리 생성
       ↓
       5. 저장
       ↓
       6. 반환
```

**결과**:
- ✅ 하루에 한 번만 생성
- ✅ 같은 날짜에는 항상 같은 게임
- ✅ 다음 날 자정에 새 게임 생성

---

## 전체 아키텍처

```
┌─────────────────────────────────────────────────────────┐
│                    게임 생성 시스템                        │
└─────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
   ┌────▼────┐        ┌────▼────┐        ┌────▼────┐
   │ 요소 선택 │        │ 스토리   │        │ 저장/재사용│
   │(결정론적)│        │ 생성     │        │(캐싱)    │
   └────┬────┘        │(비결정론적)│       └────┬────┘
        │             └────┬────┘             │
        │                  │                  │
   ┌────▼────────────┐    │    ┌─────────────▼──────┐
   │CaseElementLibrary│    │    │  CaseRepository    │
   │                  │    │    │                    │
   │- 무기 6종        │    │    │- getTodaysCase()   │
   │- 동기 5종        │    │    │- createCase()      │
   │- 장소 5종        │    │    │- getCaseByDate()   │
   │- 용의자 5종      │    │    │                    │
   │                  │    │    │저장 위치:          │
   │날짜 시드:        │    │    │local-data/         │
   │YYYYMMDD         │    │    │                    │
   └─────────────────┘    │    └────────────────────┘
                          │
                    ┌─────▼─────┐
                    │GeminiClient│
                    │            │
                    │temperature:│
                    │0.8 (높음)  │
                    │            │
                    │매번 다른   │
                    │스토리 생성 │
                    └────────────┘
```

---

## 핵심 포인트 정리

### 1. 날짜별 일관성

**같은 날짜**:
- ✅ 무기: 항상 같음
- ✅ 장소: 항상 같음
- ✅ 용의자 원형: 항상 같음
- 🎲 피해자 이름: 다를 수 있음
- 🎲 용의자 이름: 다를 수 있음
- 🎲 배경 스토리: 다를 수 있음

**다른 날짜**:
- ✅ 모든 요소가 다름

### 2. 테스트 vs 프로덕션

| 구분 | 테스트 스크립트 | 프로덕션 |
|------|----------------|----------|
| 호출 방법 | `generateCase()` | `getTodaysCase()` |
| 캐시 확인 | ❌ 없음 | ✅ 있음 |
| 중복 생성 | ✅ 가능 | ❌ 불가능 |
| 덮어쓰기 | ✅ 발생 | ❌ 발생 안 함 |

### 3. AI의 역할

**Temperature = 0.8의 의미**:
- 같은 프롬프트라도 매번 다른 답변
- 창의성과 다양성 보장
- 예측 불가능성

**결과**:
- 같은 요소로도 무한한 스토리 생성 가능
- 매일 신선한 게임 경험

---

## 요약

### 게임 생성은 3단계로 구성됩니다

1. **요소 선택** (결정론적)
   - 날짜 기반 시드로 무기, 장소, 용의자 원형 선택
   - 같은 날짜 = 같은 요소

2. **스토리 생성** (비결정론적)
   - Gemini AI가 구체적인 스토리 생성
   - Temperature 0.8로 높은 창의성
   - 매번 다른 이름, 배경, 성격

3. **저장 및 재사용** (캐싱)
   - 프로덕션: 하루에 한 번만 생성
   - 테스트: 매번 새로 생성 (덮어쓰기)

### 결론

**현재 테스트 스크립트는 "부분적으로 새로운 게임"을 생성합니다.**

- 같은 요소(무기, 장소, 용의자 원형)를 사용
- AI가 매번 다른 스토리를 만들어냄
- 프로덕션에서는 하루에 한 번만 생성되어 모든 플레이어가 같은 게임을 플레이

---

**문서 버전**: 1.0  
**최종 수정**: 2025-01-15  
**작성자**: AI Assistant  
**검토자**: 프로젝트 팀
