# 레딧 탐정 사무소 성공을 위한 핵심 게임 요소 및 베스트프랙티스 설계

본 문서는 모든 리서치 문서를 종합하여 게임 성공에 필수적인 핵심 요소와 각 요소별 구체적인 구현 방법론을 제시합니다.

---

## I. 핵심 게임 요소 정의

### 1.1. 6가지 핵심 기둥 (Core Pillars)

문서 분석 결과, 게임 성공을 위한 6가지 핵심 요소를 도출했습니다:

**① 매력적인 일일 사건 시나리오**

- 짧은 시간(2분) 내 이해 가능한 한입 크기 미스터리
- 논리적으로 해결 가능하면서도 흥미로운 서사
- 공정한 단서 제공과 red herring 균형

**② AI 기반 동적 콘텐츠 생성**

- RAG 기반 용의자 봇의 일관성 있는 대화
- 실시간 증거 생성 및 반응형 상호작용
- 컨텍스트 인지 서사 엔진

**③ 피드 친화적 UX 디자인**

- 강력한 첫인상 (썸네일, 제목)
- 즉각적인 참여 가능성 (클릭 → 플레이까지 3초 이내)
- 모바일/웹 반응형 디자인

**④ 경쟁과 협력의 균형**

- 개인 점수 시스템 + 커뮤니티 집단 추리
- 리더보드를 통한 경쟁 동기
- 토론과 이론 공유를 통한 협력 장려

**⑤ 콘텐츠 플라이휠 구조**

- 사용자 참여가 새로운 콘텐츠를 생성
- 우수 추리가 다음 날 단서에 반영
- 지속 가능한 콘텐츠 순환 구조

**⑥ 점진적 보상 시스템**

- 즉각적 피드백 (정답/오답)
- 중기 목표 (주간 리더보드)
- 장기 목표 (누적 랭크, Flair)

---

## II. 핵심 요소별 베스트프랙티스 설계

### 2.1. 매력적인 '오늘의 사건' 시나리오 제작 방법론

### A. 시나리오 구조 템플릿

**3막 구조 적용**

```
1막 (발견): 사건 발생, 초기 단서, 용의자 소개
2막 (조사): 심문, 모순 발견, 정오 반전
3막 (해결): 투표, 정답 공개, 해설
```

**필수 구성 요소 체크리스트**

- [ ]  **후크 (Hook)**: 첫 문장에서 흥미 유발
    - 예: "벤처 캐피털 CEO가 자신의 오피스 빌딩 옥상에서 추락사했습니다."
- [ ]  **닫힌 원 (Closed Circle)**: 용의자 3-4명으로 제한
- [ ]  **동기-수단-기회 (Motive-Means-Opportunity)**: 모든 용의자가 3요소 보유
- [ ]  **공정한 단서**: 제공된 정보만으로 해결 가능
- [ ]  **Red Herring**: 1-2개의 오도 단서
- [ ]  **결정적 단서**: 정오에 공개될 게임 체인저

### B. AI 지원 시나리오 생성 파이프라인

**Spirit of Kiro 방식 차용**

```tsx
// 1단계: 시드 및 테마 결정
const caseGenerator = {
  dateSeed: '2025-10-14',
  theme: randomTheme(['밀실', '독극물', '알리바이 트릭', '다잉 메시지']),
  difficulty: 'medium',
  tropes: ['신뢰할 수 없는 화자', '이중 정체성']
};

// 2단계: 구조화된 프롬프트 생성
const systemPrompt = `
당신은 추리 소설 작가입니다. 다음 규칙에 따라 사건을 YAML 형식으로 생성하세요:

## 필수 요소
- 제목: 15자 이내의 매력적인 사건명
- 피해자: 이름, 직업, 배경 (50자)
- 용의자 3명:
  - 각자 이름, 관계, 동기 (각 100자)
  - 알리바이 (각 150자, 하나는 거짓)
- 초기 단서 5개: 각 50자 이내
- 정오 반전 단서 1개: 게임을 뒤집을 결정적 정보
- 해결책: 범인, 방법, 증명 과정 (200자)

## 제약 조건
- 범인은 단 1명
- 모든 단서는 논리적으로 범인을 가리켜야 함
- Red herring은 최대 2개
- 한국 독자 대상 (한국 문화 컨텍스트)
`;

const userPrompt = `
날짜: ${caseGenerator.dateSeed}
테마: ${caseGenerator.theme}
난이도: ${caseGenerator.difficulty}
트로프: ${caseGenerator.tropes.join(', ')}

위 정보를 바탕으로 사건을 생성하세요.
`;
```

**3단계: 품질 검증 자동화**

```tsx
interface CaseValidation {
  hasAllSuspects: boolean;      // 용의자 3명 존재
  hasMotives: boolean;           // 모든 용의자 동기 보유
  hasAlibis: boolean;            // 모든 용의자 알리바이 보유
  hasFairClues: boolean;         // 해결 가능한 단서
  hasRedHerring: boolean;        // Red herring 존재
  logicalConsistency: number;    // 논리 일관성 점수 (0-100)
}

async function validateCase(caseData: any): Promise<CaseValidation> {
  // 자동 검증 로직
  // LLM에게 "이 사건이 공정하게 해결 가능한가?" 질의
  const validation = await llm.analyze({
    prompt: `다음 사건 시나리오를 분석하고 공정성을 평가하세요:
    
    ${JSON.stringify(caseData)}
    
    평가 기준:
    1. 제공된 단서만으로 범인을 특정할 수 있는가?
    2. Red herring이 너무 강력하여 오도하지 않는가?
    3. 모든 용의자가 신빙성 있는 동기를 가지는가?
    
    점수: 0-100
    이유: [설명]`
  });
  
  return validation;
}
```

### C. 난이도 조절 시스템

**Spirit of Kiro의 페르소나 조절 기법 활용**

```tsx
const difficultySettings = {
  easy: {
    suspectCount: 3,
    clueCount: 7,
    redHerringCount: 1,
    alibiComplexity: 'simple',
    GMHintLevel: 'explicit', // "용의자 B의 알리바이를 주의 깊게 살펴보세요"
  },
  medium: {
    suspectCount: 3,
    clueCount: 5,
    redHerringCount: 2,
    alibiComplexity: 'moderate',
    GMHintLevel: 'suggestive', // "시간대에 모순이 있는 것 같습니다"
  },
  hard: {
    suspectCount: 4,
    clueCount: 4,
    redHerringCount: 3,
    alibiComplexity: 'complex',
    GMHintLevel: 'cryptic', // "모든 것이 보이는 그대로는 아닙니다"
  }
};
```

### D. 시나리오 뱅크 구축 전략

**2주 치 콘텐츠 사전 제작**

| 주차 | 월 | 화 | 수 | 목 | 금 |
| --- | --- | --- | --- | --- | --- |
| 1주차 | Easy
독극물 | Medium
밀실 | Medium
알리바이 | Hard
트릭 | Medium
원한 |
| 2주차 | Easy
단순 | Hard
복합 | Medium
현장 | Medium
증언 | Special
이벤트 |

**재사용 가능한 시나리오 컴포넌트**

```yaml
# /scenario-components/motives.yaml
motives:
  - id: financial_gain
    description: "거액의 보험금/유산 상속"
    tension_level: high
  - id: revenge
    description: "과거의 배신에 대한 복수"
    tension_level: high
  - id: jealousy
    description: "연인 또는 지위에 대한 질투"
    tension_level: medium

# /scenario-components/settings.yaml
settings:
  - id: corporate_office
    description: "고층 빌딩 사무실"
    props: ["노트북", "계약서", "CCTV"]
  - id: mansion
    description: "외딴 저택"
    props: ["서재", "비밀 통로", "골동품"]
```

**조합 생성 로직**

```tsx
function generateCase() {
  const setting = randomPick(settings);
  const victim = generateVictim(setting);
  const suspects = generateSuspects(3, victim);
  const motive = assignMotives(suspects);
  const clues = generateClues(setting.props, motive);
  
  return assembleCaseFile({
    setting,
    victim,
    suspects,
    clues
  });
}
```

---

### 2.2. RAG 기반 AI 용의자 시스템 설계

### A. 아키텍처 설계

**Spirit of Kiro의 아이템 상호작용 패턴 차용**

```
[사용자 질문] → [컨텍스트 검색] → [프롬프트 구성] → [LLM 호출] → [답변 생성]
       ↓                 ↓
   질문 분석      사건 정보 + 용의자 프로필 + 대화 기록
```

**컨텍스트 계층 구조**

```tsx
interface SuspectContext {
  // Layer 1: 불변 정보 (사건 내내 동일)
  core: {
    suspectId: string;
    name: string;
    role: string;        // "피해자의 배우자"
    personality: string; // "다혈질, 방어적"
  };
  
  // Layer 2: 사건 정보 (모두가 아는 사실)
  publicKnowledge: {
    victim: string;
    timeOfDeath: string;
    location: string;
    initialClues: string[];
  };
  
  // Layer 3: 용의자 전용 정보 (이 용의자만 아는 것)
  privateKnowledge: {
    alibi: string;
    secret: string;      // "실제로 9시에 현장 근처에 있었음"
    guilt: boolean;      // 범인 여부
    emotionalState: string;
  };
  
  // Layer 4: 대화 메모리 (이 심문에서 공개된 것)
  conversationMemory: {
    revealedFacts: string[];
    caughtLies: string[];
    suspicionLevel: number; // 0-100
  };
}
```

### B. 프롬프트 엔지니어링 패턴

**계층적 페르소나 프레임워크**

```tsx
function buildSuspectPrompt(context: SuspectContext, question: string) {
  const systemPrompt = `
## 당신의 정체성
당신은 ${[context.core.name](http://context.core.name)}입니다. ${context.core.role}.
성격: ${context.core.personality}

## 행동 지침
1. 당신의 목표는 자신을 유죄로 만들지 않는 것입니다.
2. 진실을 말해야 하지만, 불리한 정보는 최대한 숨기세요.
3. 거짓말이 들통났을 때는 당황하거나 이야기를 바꾸세요.
4. 답변은 50-100자로 간결하게 유지하세요.
5. 한국어 존댓말을 사용하세요.

## 당신만 아는 비밀
- 알리바이: ${context.privateKnowledge.alibi}
- 숨기고 있는 것: ${context.privateKnowledge.secret}
${context.privateKnowledge.guilt ? '- **중요**: 당신이 범인입니다. 절대 들키지 마세요.' : ''}

## 지금까지 심문에서 드러난 것
${context.conversationMemory.revealedFacts.join('\n')}
${context.conversationMemory.caughtLies.length > 0 ? 
  `\n⚠️ 거짓말이 들통남: ${context.conversationMemory.caughtLies.join(', ')}` : ''}
`;

  const userPrompt = `
탐정의 질문: "${question}"

위 지침에 따라 ${[context.core.name](http://context.core.name)}으로서 답변하세요.
`;

  return { systemPrompt, userPrompt };
}
```

**감정 상태 반영**

```tsx
function adjustEmotionalTone(suspicionLevel: number) {
  if (suspicionLevel > 70) {
    return "당신은 매우 당황하고 방어적입니다. 말을 더듬거나 공격적으로 반응할 수 있습니다.";
  } else if (suspicionLevel > 40) {
    return "당신은 약간 긴장하고 있지만 침착함을 유지하려 합니다.";
  } else {
    return "당신은 자신감 있고 협조적입니다.";
  }
}
```

### C. 벡터 기반 대화 메모리

**Spirit of Kiro의 벡터 캐싱 패턴 활용**

```tsx
interface ConversationEntry {
  timestamp: string;
  question: string;
  answer: string;
  embedding: number[];  // 벡터 임베딩
  importance: number;   // 0-1, 중요도 점수
}

class ConversationMemory {
  private entries: ConversationEntry[] = [];
  
  async addEntry(question: string, answer: string) {
    const embedding = await generateEmbedding(question + answer);
    const importance = await assessImportance(answer);
    
    this.entries.push({
      timestamp: new Date().toISOString(),
      question,
      answer,
      embedding,
      importance
    });
  }
  
  // 현재 질문과 가장 관련 있는 과거 대화 검색
  async retrieveRelevant(currentQuestion: string, k: number = 3) {
    const currentEmbedding = await generateEmbedding(currentQuestion);
    
    // 코사인 유사도 계산
    const scored = [this.entries.map](http://this.entries.map)(entry => ({
      ...entry,
      similarity: cosineSimilarity(currentEmbedding, entry.embedding)
    }));
    
    // 유사도 * 중요도로 정렬
    return scored
      .sort((a, b) => (b.similarity * b.importance) - (a.similarity * a.importance))
      .slice(0, k);
  }
}
```

### D. 답변 일관성 검증

```tsx
async function verifyConsistency(newAnswer: string, context: SuspectContext) {
  const previousStatements = context.conversationMemory.revealedFacts;
  
  const verificationPrompt = `
다음 진술들이 서로 모순되는지 평가하세요:

이전 진술들:
${previousStatements.join('\n')}

새 진술:
${newAnswer}

모순 여부: [예/아니오]
모순 이유: [설명]
`;
  
  const result = await llm.analyze(verificationPrompt);
  
  if (result.contradiction) {
    // 용의자의 신뢰도 하락
    context.conversationMemory.suspicionLevel += 15;
    context.conversationMemory.caughtLies.push(result.reason);
  }
  
  return result;
}
```

---

### 2.3. 동적 증거 생성 시스템

### A. 이미지 생성 아키텍처

**Spirit of Kiro의 마이크로서비스 패턴**

```
[Devvit 앱] → [외부 이미지 서비스] → [벡터 캐시 확인] → [생성 or 캐시 반환]
                        ↓
              [AWS Lambda / Vercel]
                        ↓
              [Gemini Image API]
                        ↓
              [S3 저장 + MemoryDB 벡터]
```

**비용 최적화 전략**

```tsx
class ImageGenerationService {
  private vectorStore: VectorStore;
  
  async generateOrRetrieve(prompt: string): Promise<string> {
    // 1. 프롬프트 벡터화
    const embedding = await generateEmbedding(prompt);
    
    // 2. 유사한 프롬프트가 있는지 검색
    const similar = await this.vectorStore.nearestMatch(embedding, threshold: 0.95);
    
    if (similar) {
      console.log('💰 Cache hit! 비용 절약');
      return similar.imageUrl;
    }
    
    // 3. 새로 생성
    console.log('🎨 새 이미지 생성 중...');
    const imageUrl = await geminiImageAPI.generate(prompt);
    
    // 4. 캐시에 저장
    await [this.vectorStore.store](http://this.vectorStore.store)({
      embedding,
      prompt,
      imageUrl,
      timestamp: [Date.now](http://Date.now)()
    });
    
    return imageUrl;
  }
}
```

### B. 키워드 기반 증거 요청 파서

```tsx
interface EvidenceRequest {
  action: 'zoom' | 'show' | 'analyze';
  target: string;
  isValid: boolean;
}

class EvidenceRequestParser {
  private allowedObjects: string[];
  
  constructor(caseData: CaseData) {
    // 사건에서 언급된 물체만 허용
    this.allowedObjects = caseData.clues
      .flatMap(clue => extractNouns(clue));
  }
  
  parse(comment: string): EvidenceRequest | null {
    const normalized = comment.toLowerCase();
    
    // 액션 감지
    const actions = {
      zoom: ['확대', '자세히', '클로즈업', 'zoom', 'close-up'],
      show: ['보여줘', '보여주세요', 'show', 'display'],
      analyze: ['분석', '검사', 'analyze', 'examine']
    };
    
    let detectedAction: string | null = null;
    for (const [action, keywords] of Object.entries(actions)) {
      if (keywords.some(kw => normalized.includes(kw))) {
        detectedAction = action;
        break;
      }
    }
    
    if (!detectedAction) return null;
    
    // 대상 물체 감지
    const detectedObject = this.allowedObjects.find(obj => 
      normalized.includes(obj)
    );
    
    if (!detectedObject) return null;
    
    return {
      action: detectedAction as any,
      target: detectedObject,
      isValid: true
    };
  }
}
```

### C. 프롬프트 템플릿 라이브러리

```tsx
const imagePromptTemplates = {
  crime_scene: (target: string, setting: string) => `
Photorealistic, forensic photography style,
a ${target} at a ${setting},
cinematic lighting, noir atmosphere,
high detail, 4K,
professional crime scene documentation
`,
  
  close_up: (target: string, detail: string) => `
Macro shot, extreme close-up,
a ${target} showing ${detail},
forensic detail, sharp focus,
evidence photography style,
hyper-realistic texture
`,
  
  document: (type: string, content: string) => `
Flat lay photography,
a ${type} document with ${content},
official paperwork style,
clear and legible,
top-down view, professional lighting
`
};

function buildImagePrompt(request: EvidenceRequest, caseData: CaseData) {
  const template = imagePromptTemplates[request.action];
  const detail = caseData.getObjectDetail([request.target](http://request.target));
  
  return template([request.target](http://request.target), detail);
}
```

---

### 2.4. 피드 친화적 UX 설계

### A. 첫인상 최적화 (First Impression)

**3초 법칙: 클릭 유도 요소**

```tsx
interface PostPreview {
  // 1. 강력한 비주얼
  thumbnail: {
    image: string;        // AI 생성 현장 사진
    overlayText: string;  // "사건 발생!"
    badge: string;        // "🔴 LIVE" 또는 "⏰ 6시간 남음"
  };
  
  // 2. 매력적인 제목
  title: {
    emoji: string;        // "🔍"
    hook: string;         // "[긴급] 펜트하우스 추락사 사건"
    metadata: string;     // "난이도: ⭐⭐ | 참가자: 127명"
  };
  
  // 3. 명확한 CTA
  callToAction: {
    primary: string;      // "지금 조사 시작"
    secondary: string;    // "용의자 심문하기"
  };
}
```

**모범 사례: r/ChessQuiz 분석**

| 요소 | ChessQuiz 구현 | 탐정 사무소 적용 |
| --- | --- | --- |
| 썸네일 | 체스보드 이미지 | 범죄 현장 이미지 + 경찰 테이프 오버레이 |
| 제목 | "Puzzle #1234 - White to move" | "[2025-10-14] 사건 #042: 밀실의 비밀" |
| 상태 | "해결률 65%" | "현재 127명 조사 중 · 정답률 48%" |
| CTA | 게시물 자체가 플레이 가능 | "🔍 조사 시작" 버튼 |

### B. 인터랙션 플로우

```
[피드 스크롤]
     ↓
[썸네일 + 제목 노출] ← 2초
     ↓
[클릭]
     ↓
[사건 브리핑 로드] ← 1초 (Devvit Blocks)
     ↓
[핵심 정보 파악] ← 30초 (피해자, 용의자, 초기 단서)
     ↓
[용의자 선택 + 질문 작성] ← 1분
     ↓
[AI 답변 수신] ← 3초 (스트리밍)
     ↓
[추가 심문 or 투표]
```

**병목 제거 전략**

- 로딩 시간 < 1초: Devvit Blocks 활용
- AI 응답 < 3초: Gemini Flash 모델 + 스트리밍
- 이미지 로딩 < 2초: CDN + lazy loading

### C. 모바일 최적화

```css
/* 반응형 사건 파일 카드 */
.case-file {
  /* 모바일 (< 768px) */
  @media (max-width: 768px) {
    padding: 12px;
    font-size: 14px;
    
    .thumbnail {
      height: 200px;
      object-fit: cover;
    }
    
    .suspect-card {
      display: block; /* 세로 스택 */
      margin-bottom: 16px;
    }
  }
  
  /* 데스크톱 */
  @media (min-width: 769px) {
    padding: 24px;
    font-size: 16px;
    
    .suspect-card {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
    }
  }
}
```

---

### 2.5. 경쟁과 협력의 균형 시스템

### A. 듀얼 스코어링 시스템

```tsx
interface UserScore {
  // 개인 경쟁 지표
  individual: {
    correctGuesses: number;      // 정답 맞힌 횟수
    solveSpeed: number;          // 평균 해결 시간 (빠를수록 좋음)
    streak: number;              // 연속 정답 기록
    rank: string;                // "전설의 명탐정"
  };
  
  // 커뮤니티 협력 지표
  community: {
    insightScore: number;        // 통찰력 있는 댓글 업보트 수
    helpfulQuestions: number;    // 다른 사람에게 도움이 된 질문
    theoryContributions: number; // 집단 추리에 기여한 이론
  };
}
```

**포인트 배분 로직**

```tsx
function calculateDailyPoints(user: User, caseResult: CaseResult) {
  let points = 0;
  
  // 1. 정답 기본 점수
  if (caseResult.correctGuess) {
    points += 10;
    
    // 2. 속도 보너스 (선착순 20% 안에 들면)
    if (caseResult.rank <= caseResult.totalParticipants * 0.2) {
      points += 5;
    }
  }
  
  // 3. 통찰력 보너스 (비록 오답이어도)
  const upvotes = caseResult.comments
    .filter(c => c.authorId === [user.id](http://user.id))
    .reduce((sum, c) => sum + c.upvotes, 0);
    
  if (upvotes >= 50) {
    points += 8; // 높은 업보트 = 커뮤니티에 기여
  } else if (upvotes >= 20) {
    points += 5;
  } else if (upvotes >= 5) {
    points += 2;
  }
  
  // 4. 결정적 질문 보너스
  if (caseResult.hasCriticalQuestion) {
    points += 15; // 게임의 흐름을 바꾼 질문
  }
  
  return points;
}
```

### B. 리더보드 전략

**롤링 윈도우 방식 (Spirit of Kiro 권장)**

```tsx
class LeaderboardManager {
  // 신규 유저도 경쟁 가능하도록 30일 롤링 윈도우
  async getRollingLeaderboard(days: number = 30) {
    const cutoffDate = [Date.now](http://Date.now)() - (days * 24 * 60 * 60 * 1000);
    
    const recentScores = await kvStore.query(
      `SELECT userId, SUM(points) as total
       FROM scores
       WHERE timestamp > ${cutoffDate}
       GROUP BY userId
       ORDER BY total DESC
       LIMIT 10`
    );
    
    return recentScores;
  }
  
  // 주간 리더보드 (매주 월요일 리셋)
  async getWeeklyLeaderboard() {
    const weekStart = getThisWeekMonday();
    // ...
  }
}
```

**시각화 디자인**

```tsx
const leaderboardUI = {
  // 상위 3명은 특별 디자인
  topThree: {
    first: { emoji: '🥇', color: '#FFD700', effect: 'glow' },
    second: { emoji: '🥈', color: '#C0C0C0', effect: 'shine' },
    third: { emoji: '🥉', color: '#CD7F32', effect: 'shimmer' }
  },
  
  // 나머지는 간결하게
  others: {
    displayFormat: '#{rank}. {username} - {score}점',
    highlightCurrentUser: true
  },
  
  // 하단에 개인 통계
  userStats: {
    currentRank: number,
    nextMilestone: { rank: number, pointsNeeded: number },
    recentTrend: 'up' | 'down' | 'stable'
  }
};
```

---

### 2.6. 콘텐츠 플라이휠 구현

### A. 사용자 참여 → 콘텐츠 전환 메커니즘

```tsx
class ContentFlywheel {
  // 1. 우수 추리 수집
  async collectTopTheories(caseId: string) {
    const theories = await reddit.getComments({
      postId: caseId,
      sort: 'top',
      limit: 10
    });
    
    return theories.filter(t => t.upvotes > 50);
  }
  
  // 2. 다음 날 사건에 반영
  async incorporateIntoNextCase(theories: Comment[]) {
    const insights = [theories.map](http://theories.map)(t => extractInsight(t.body));
    
    // AI에게 이 통찰을 다음 사건에 녹이도록 지시
    const enhancedPrompt = `
다음 커뮤니티 통찰을 참고하여 새 사건을 생성하세요:

커뮤니티가 좋아한 요소:
${insights.join('\n')}

이러한 요소를 새 사건에 창의적으로 통합하세요.
    `;
    
    return enhancedPrompt;
  }
  
  // 3. 메타 인정 (커뮤니티에 피드백)
  async acknowledgeContribution(userId: string, contribution: string) {
    await reddit.comment({
      parentId: nextDayPost,
      body: `📣 어제 ${userId}님의 통찰이 오늘 사건에 영감을 주었습니다: "${contribution}"`
    });
    
    // 특별 Flair 부여
    await reddit.setUserFlair({
      userId,
      text: '💡 영감 제공자',
      duration: '7days'
    });
  }
}
```

### B. 플라이휠 루프 시각화

```
[Day 1: 사건 게시]
       ↓
[사용자들 조사 + 이론 제시]
       ↓
[우수 이론 자동 수집]
       ↓
[AI가 다음 사건 생성 시 참고]
       ↓
[Day 2: 커뮤니티 영향 받은 사건 게시]
       ↓
["어제 여러분의 추리가 오늘 사건에 반영되었습니다!" 공지]
       ↓
[사용자 만족도 ↑, 참여 동기 ↑]
       ↓
[더 적극적인 이론 제시]
       ↓
[플라이휠 가속]
```

---

## III. 기술 구현 우선순위 및 로드맵

### 3.1. MVP (해커톤 기간: 17일)

### Week 1: 핵심 루프 구현

```tsx
const week1Tasks = [
  // Day 1-3: 인프라
  {
    task: 'Devvit 프로젝트 설정 + 스케줄러 구현',
    priority: 'P0',
    estimatedHours: 8,
    deliverable: '일일 게시물 자동 생성 작동'
  },
  
  // Day 4-5: AI 통합
  {
    task: 'Gemini LLM 연동 + 기본 프롬프트',
    priority: 'P0',
    estimatedHours: 12,
    deliverable: '용의자 봇 1명이 질문에 답변'
  },
  
  // Day 6-7: 게임 로직
  {
    task: '투표 수집 + 점수 계산 + KV Store',
    priority: 'P0',
    estimatedHours: 10,
    deliverable: '전체 게임 루프 1회 완료 가능'
  }
];
```

### Week 2: 사용자 경험 + 세련화

```tsx
const week2Tasks = [
  // Day 8-10: UX
  {
    task: '리더보드 UI + Flair 자동화',
    priority: 'P1',
    estimatedHours: 12,
    deliverable: '리더보드 표시 + 자동 랭크업'
  },
  
  // Day 11-12: 콘텐츠
  {
    task: '사건 시나리오 5개 제작',
    priority: 'P0',
    estimatedHours: 10,
    deliverable: '데모용 사건 완료'
  },
  
  // Day 13-14: 이미지
  {
    task: '이미지 생성 서비스 (선택)',
    priority: 'P2',
    estimatedHours: 8,
    deliverable: '범죄 현장 이미지 생성'
  },
  
  // Day 15-17: 마무리
  {
    task: '테스트 + 데모 비디오 + 문서',
    priority: 'P0',
    estimatedHours: 12,
    deliverable: '제출 준비 완료'
  }
];
```

### 3.2. Post-MVP (해커톤 이후)

### Phase 2: 고도화 (1-2개월)

- [ ]  **RAG 시스템 완성**: 벡터 기반 대화 메모리
- [ ]  **동적 증거 생성**: 키워드 기반 이미지 요청
- [ ]  **정오 반전 자동화**: 게임 흐름 분석 후 최적 타이밍에 단서 공개
- [ ]  **주간 리더보드**: 매주 월요일 리셋 + 우승자 발표

### Phase 3: 커뮤니티 기능 (3-4개월)

- [ ]  **탐정 사무소 (길드)**: 팀 구성 + 협력 모드
- [ ]  **사용자 제출 사건**: 커뮤니티가 시나리오 기여
- [ ]  **멀티 에피소드 아크**: 연결된 사건들
- [ ]  **라이브 이벤트**: 실시간 사건 해결 토너먼트

---

## IV. 성공 지표 (KPI) 및 측정

### 4.1. 핵심 메트릭

| 카테고리 | 메트릭 | 목표 (1개월) | 측정 방법 |
| --- | --- | --- | --- |
| **참여** | DAU (일일 활성 사용자) | 50+ | 고유 댓글 작성자 수 |
|  | 게시물당 평균 댓글 | 100+ | Reddit API 집계 |
|  | 용의자당 평균 질문 | 30+ | 용의자 스레드 분석 |
| **성과** | 정답률 | 40-70% | 정답자 / 전체 투표자 |
|  | 평균 해결 시간 | 4시간 | 첫 댓글 ~ 투표 시간 |
| **유지** | 주간 복귀율 | 30%+ | 지난주 참여자 중 이번주 재방문 |
|  | 7일 연속 참여 | 10명+ | Streak 추적 |
| **품질** | 커뮤니티 만족도 | 4.5/5 | 주간 설문 |
|  | LLM 응답 시간 | <3초 | 로그 분석 |

### 4.2. 대시보드 설계

```tsx
interface GameDashboard {
  realtime: {
    currentActivePlayers: number;
    todayParticipants: number;
    topTheoryUpvotes: number;
  };
  
  daily: {
    caseDate: string;
    difficultyActual: number;  // 정답률로 역산
    mostAskedQuestion: string;
    topDetective: string;
  };
  
  trends: {
    dauTrend: number[];        // 지난 30일
    engagementRate: number[];  // 참여율 추이
    averageSolveTime: number[]; // 난이도 추이
  };
}
```

---

## V. 위험 관리 및 대응 전략

### 5.1. 기술적 리스크

| 리스크 | 발생 확률 | 영향도 | 대응 전략 |
| --- | --- | --- | --- |
| LLM API 장애 | 중 | 높음 | - 재시도 로직 (3회)
- 폴백 메시지 준비
- 다중 모델 대비 (Claude backup) |
| 스케줄러 실패 | 저 | 높음 | - Health check 모니터링
- 수동 백업 스크립트
- 알림 시스템 (Discord webhook) |
| KV Store 한계 | 중 | 중 | - 30일 이상 데이터 아카이빙
- 키 설계 최적화
- 필요시 외부 DB 마이그레이션 |

### 5.2. 커뮤니티 리스크

**시나리오 1: 낮은 초기 참여**

```
대응:
1. 출시 전 티저 캠페인 (r/Games, r/mystery)
2. 인플루언서 협업 (추리 유튜버)
3. 첫 주 특별 이벤트 ("창립 탐정" Flair)
```

**시나리오 2: 사건이 너무 쉽거나 어려움**

```
대응:
1. 실시간 난이도 모니터링 (정답률 추적)
2. 긴급 힌트 시스템 (정답률 <20%면 추가 단서)
3. 난이도 피드백 루프 (주간 조정)
```

**시나리오 3: AI 남용 (스팸, 어뷰징)**

```
대응:
1. Rate limiting (사용자당 시간당 10질문)
2. 신뢰도 시스템 (새 계정은 제한적)
3. 모더레이션 봇 (AutoModerator 규칙)
```

---

## VI. 결론: 성공의 청사진

### 핵심 성공 요인 체크리스트

**✅ 콘텐츠 품질**

- [ ]  매력적인 후크 (첫 문장에서 끌림)
- [ ]  공정한 단서 (논리적 해결 가능)
- [ ]  적절한 난이도 (정답률 40-70%)
- [ ]  일관된 세계관

**✅ 기술 안정성**

- [ ]  < 1초 로딩 시간
- [ ]  < 3초 AI 응답
- [ ]  99% 스케줄러 성공률
- [ ]  모바일 최적화

**✅ 커뮤니티 참여**

- [ ]  일일 신규 콘텐츠
- [ ]  경쟁과 협력 균형
- [ ]  명확한 보상 체계
- [ ]  사용자 기여 인정

**✅ 지속 가능성**

- [ ]  콘텐츠 플라이휠 작동
- [ ]  비용 효율적 AI 사용
- [ ]  확장 가능한 아키텍처
- [ ]  커뮤니티 자생력

---

## 다음 단계

1. **즉시 시작**: Week 1 Task 1 (Devvit 프로젝트 설정)
2. **병렬 작업**: 첫 사건 시나리오 작성 시작
3. **일일 체크인**: 진행 상황 추적 및 블로커 해결
4. **주간 데모**: 매주 금요일 내부 플레이테스트

<aside>
🚀

**지금 시작하세요!**

이 문서는 17일간의 여정을 위한 완전한 지도입니다. 각 섹션은 구체적인 코드 예시와 함께 실행 가능한 지침을 담고 있습니다.

Spirit of Kiro의 검증된 패턴, r/ChessQuiz의 성공 공식, 그리고 Devvit 플랫폼의 강력한 기능을 결합하여, 우리는 Reddit 커뮤니티가 사랑할 게임을 만들 수 있습니다.

첫 번째 `devvit new` 명령어를 실행하는 순간, 위대한 탐정 사무소의 문이 열립니다. 🔍

</aside>

---

**문서 버전**: 1.0

**최종 업데이트**: 2025-10-14

**작성 기준**: 전체 리서치 문서 종합 분석

[📐 게임 메커니즘 설계 상세 가이드](https://www.notion.so/adfe3f9a73774ec89af4cdad2308ac01?pvs=21)

[🎯 AI 시스템 구현 전략](https://www.notion.so/AI-5b3dfdb45cea4688a8283049d4a38c01?pvs=21)

[📅 17일 개발 로드맵 & 실행 체크리스트](https://www.notion.so/17-e83f4d8af476480ea0ea1401bf40da29?pvs=21)