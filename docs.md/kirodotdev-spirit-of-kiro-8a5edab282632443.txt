Directory structure:
└── kirodotdev-spirit-of-kiro/
    ├── README.md
    ├── CODE_OF_CONDUCT.md
    ├── CONTRIBUTING.md
    ├── docker-compose.yml
    ├── launch.ts
    ├── LICENSE
    ├── package.json
    ├── .dockerignore
    ├── client/
    │   ├── Dockerfile
    │   ├── env.d.ts
    │   ├── eslint.config.ts
    │   ├── index.html
    │   ├── package.json
    │   ├── tsconfig.app.json
    │   ├── tsconfig.json
    │   ├── tsconfig.node.json
    │   ├── tsconfig.vitest.json
    │   ├── vite.config.ts
    │   ├── vitest.config.ts
    │   ├── .dockerignore
    │   ├── .editorconfig
    │   ├── .prettierrc.json
    │   ├── iac/
    │   │   ├── deploy.sh
    │   │   └── web.yaml
    │   └── src/
    │       ├── App.vue
    │       ├── main.ts
    │       ├── assets/
    │       │   ├── base.css
    │       │   ├── index.ts
    │       │   └── main.css
    │       ├── components/
    │       │   ├── Banner.vue
    │       │   ├── BuyPreview.vue
    │       │   ├── Chest.vue
    │       │   ├── ChestFullscreen.vue
    │       │   ├── Computer.vue
    │       │   ├── ComputerFullscreen.vue
    │       │   ├── DiscardDialog.vue
    │       │   ├── Dispenser.vue
    │       │   ├── GameGrid.vue
    │       │   ├── GameItem.vue
    │       │   ├── GameObjects.vue
    │       │   ├── Garbage.vue
    │       │   ├── HintDisplay.vue
    │       │   ├── HUD.vue
    │       │   ├── ItemDialog.vue
    │       │   ├── ItemPreview.vue
    │       │   ├── LoadingScreen.vue
    │       │   ├── PlayerCharacter.vue
    │       │   ├── Preloader.vue
    │       │   ├── PullLever.vue
    │       │   ├── RandomChat.vue
    │       │   ├── SellDialog.vue
    │       │   ├── SkillResultDialog.vue
    │       │   ├── TutorialScreen.vue
    │       │   ├── Wall.vue
    │       │   ├── Workbench.vue
    │       │   └── WorkbenchFullscreen.vue
    │       ├── composables/
    │       │   └── useEscapeKeyHandler.ts
    │       ├── router/
    │       │   └── index.ts
    │       ├── stores/
    │       │   └── game.ts
    │       ├── systems/
    │       │   ├── focus-system.ts
    │       │   ├── game-object-system.ts
    │       │   ├── inventory-system.ts
    │       │   ├── item-system.ts
    │       │   ├── persona-system.ts
    │       │   ├── physics-system.ts
    │       │   ├── preloader-system.ts
    │       │   └── socket-system.ts
    │       ├── utils/
    │       │   ├── init-world.ts
    │       │   ├── items.ts
    │       │   └── physics.ts
    │       └── views/
    │           ├── GameView.vue
    │           ├── HomeView.vue
    │           ├── SignInView.vue
    │           └── SignUpView.vue
    ├── docs/
    │   ├── appsec-overview.md
    │   ├── architecture.md
    │   ├── CHALLENGE.md
    │   ├── client-events.md
    │   ├── guiding-principles.md
    │   ├── local-setup.md
    │   ├── remote-deploy.md
    │   ├── ROADMAP.md
    │   └── server-messages.md
    ├── item-images/
    │   ├── README.md
    │   ├── config.ts
    │   ├── Dockerfile
    │   ├── local.env
    │   ├── package.json
    │   ├── prod.env
    │   ├── server.ts
    │   ├── .dockerignore
    │   ├── handlers/
    │   │   └── image-handler.ts
    │   ├── iac/
    │   │   ├── deploy.sh
    │   │   ├── distribution.yml
    │   │   ├── fargate.yml
    │   │   ├── images-s3.yml
    │   │   └── memorydb.yml
    │   ├── lib/
    │   │   └── item-image.ts
    │   ├── scripts/
    │   │   └── generate-random-images.js
    │   └── state/
    │       ├── redis-client.ts
    │       └── vector-store.ts
    ├── scripts/
    │   ├── bootstrap-local-dynamodb.js
    │   ├── check-dependencies.sh
    │   ├── deploy-cognito.sh
    │   ├── podman-cleanup.sh
    │   └── prod-deploy.sh
    ├── server/
    │   ├── README.md
    │   ├── bunfig.toml
    │   ├── config.ts
    │   ├── devfile.yaml
    │   ├── Dockerfile
    │   ├── package.json
    │   ├── server.ts
    │   ├── types.ts
    │   ├── .dockerignore
    │   ├── __tests__/
    │   │   ├── server.test.ts
    │   │   ├── setup.ts
    │   │   ├── util.ts
    │   │   └── ws.d.ts
    │   ├── handlers/
    │   │   ├── buy-discarded.ts
    │   │   ├── discard-item.ts
    │   │   ├── fetch-persona.ts
    │   │   ├── list-inventory.ts
    │   │   ├── move-item.ts
    │   │   ├── peek-discarded.ts
    │   │   ├── ping.ts
    │   │   ├── pull-item.ts
    │   │   ├── sell-item.ts
    │   │   ├── signin.ts
    │   │   ├── signup.ts
    │   │   ├── use-skill.ts
    │   │   └── __tests__/
    │   │       ├── discard-item.test.ts
    │   │       ├── list-inventory.test.ts
    │   │       ├── ping.test.ts
    │   │       ├── pull-item.test.ts
    │   │       ├── signin.test.ts
    │   │       └── signup.test.ts
    │   ├── iac/
    │   │   ├── cognito.yml
    │   │   ├── deploy.sh
    │   │   ├── dynamodb.yml
    │   │   └── fargate.yml
    │   ├── llm/
    │   │   ├── model.ts
    │   │   ├── prompts.ts
    │   │   └── word-lists/
    │   │       ├── accessories.js
    │   │       ├── adhesives.js
    │   │       ├── car-parts.js
    │   │       ├── clothing.js
    │   │       ├── containers.js
    │   │       ├── cooking-items.js
    │   │       ├── food-ingredients.js
    │   │       ├── household-items.js
    │   │       ├── index.js
    │   │       ├── liquids.js
    │   │       ├── magical.js
    │   │       ├── themes.js
    │   │       ├── tools.js
    │   │       └── toys.js
    │   ├── mocks/
    │   │   ├── describe-equipment.json
    │   │   └── pull-item.json
    │   ├── state/
    │   │   ├── item-store.ts
    │   │   └── user-store.ts
    │   └── utils/
    │       ├── message.ts
    │       ├── password.ts
    │       └── __tests__/
    │           └── password.test.ts
    └── .kiro/
        └── steering/
            ├── product.md
            ├── structure.md
            └── tech.md

================================================
FILE: README.md
================================================
## Spirit of Kiro

![1.png](docs/images/1.png)

This is an infinite crafting workshop game developed as a demo project for Kiro. >95% of the code has been written by prompting Kiro. This demo project is
designed to show best practices for Kiro, and AI engineering
in general.

## Find Unique Items

Every generated item is unique. Experience an infinite range of potential: from mundane pieces of garbage, to celestial remnants of epic value.

![2.png](docs/images/2.png)

Each item has its own unique description, damage, and quirks.

## Craft and Improve

![3.png](docs/images/3.png)

The items you obtain aren't static. Add an item to the workbench to use it's quirks on other items. Cut, smash, and break items down into components. Glue, weld, or install items together into complex configurations. Paint, cook, or enchant items to modify their appearances and effects.

If there is a verb for it, you can probably do it in this game!

## Sell

Done with an item, or just need to make some space in your inventory?

![4.png](docs/images/4.png)

The appraiser will analyze your item, and sell it for you, giving you a cut of what it was worth!

## Developer Resources

### Start Here

* [local-setup.md](./docs/local-setup.md) - Instructions for how to deploy a local version of the game for fun, or for development

### Learn More

* [CHALLENGE.md](./docs/CHALLENGE.md) - This game has a sample branch that is deliberately left unfinished, with a few bugs. Read to learn more about these tasks. You can use Kiro to work on these tasks.
* [ROADMAP.md](./docs/ROADMAP.md) - There is always more ideas to build. Although this game has a basic core loop, there is a lot more depth that can be added. Kiro is a great tool to implement these remaining features.
* [architecture.md](./docs/architecture.md) - Learn more about how the game works, and how it's pieces tie together.
* [appsec-overview.md](./docs/appsec-overview.md) - Similar to the architecture overview, but more focused on the inbound and outbound connection security.
* [server-messages.md](./docs/server-messages.md) - Documentation of all WebSocket message types and their formats used for client-server communication.
* [client-events.md](./docs/client-events.md) - Documentation of all client-side events and their payloads used for internal game communication.
* [remote-deploy.md](./docs/remote-deploy.md) - Instructions for how to deploy the game as a publically hosted service on AWS infrastructure.
* [guiding-principles.md](./docs/guiding-principles.md) - Some of the guiding principles of the project.

### Contributions

The core game loop of this demo project is complete, however, there is
also a roadmap of potential ideas that could be built into this game.
Check the [ROADMAP.md](./docs/ROADMAP.md) for ideas on what you might be
able to build into the game. 

Open source contributions are welcome. See [CONTRIBUTING.md](CONTRIBUTING.md)
for instructions on how to contribute.

## Security

See [CONTRIBUTING](CONTRIBUTING.md#security-issue-notifications) for more information.

## License

This library is licensed under the MIT-0 License. See the LICENSE file.




================================================
FILE: CODE_OF_CONDUCT.md
================================================
## Code of Conduct
This project has adopted the [Amazon Open Source Code of Conduct](https://aws.github.io/code-of-conduct).
For more information see the [Code of Conduct FAQ](https://aws.github.io/code-of-conduct-faq) or contact
opensource-codeofconduct@amazon.com with any additional questions or comments.



================================================
FILE: CONTRIBUTING.md
================================================
# Contributing Guidelines

Thank you for your interest in contributing to our project. Whether it's a bug report, new feature, correction, or additional
documentation, we greatly value feedback and contributions from our community.

Please read through this document before submitting any issues or pull requests to ensure we have all the necessary
information to effectively respond to your bug report or contribution.


## Reporting Bugs/Feature Requests

We welcome you to use the GitHub issue tracker to report bugs or suggest features.

When filing an issue, please check existing open, or recently closed, issues to make sure somebody else hasn't already
reported the issue. Please try to include as much information as you can. Details like these are incredibly useful:

* A reproducible test case or series of steps
* The version of our code being used
* Any modifications you've made relevant to the bug
* Anything unusual about your environment or deployment


## Contributing via Pull Requests
Contributions via pull requests are much appreciated. Before sending us a pull request, please ensure that:

1. You are working against the latest source on the *main* branch.
2. You check existing open, and recently merged, pull requests to make sure someone else hasn't addressed the problem already.
3. You open an issue to discuss any significant work - we would hate for your time to be wasted.

To send us a pull request, please:

1. Fork the repository.
2. Modify the source; please focus on the specific change you are contributing. If you also reformat all the code, it will be hard for us to focus on your change.
3. Ensure local tests pass.
4. Commit to your fork using clear commit messages.
5. Send us a pull request, answering any default questions in the pull request interface.
6. Pay attention to any automated CI failures reported in the pull request, and stay involved in the conversation.

GitHub provides additional document on [forking a repository](https://help.github.com/articles/fork-a-repo/) and
[creating a pull request](https://help.github.com/articles/creating-a-pull-request/).


## Finding contributions to work on
Looking at the existing issues is a great way to find something to contribute on. As our projects, by default, use the default GitHub issue labels (enhancement/bug/duplicate/help wanted/invalid/question/wontfix), looking at any 'help wanted' issues is a great place to start.


## Code of Conduct
This project has adopted the [Amazon Open Source Code of Conduct](https://aws.github.io/code-of-conduct).
For more information see the [Code of Conduct FAQ](https://aws.github.io/code-of-conduct-faq) or contact
opensource-codeofconduct@amazon.com with any additional questions or comments.


## Security issue notifications
If you discover a potential security issue in this project we ask that you notify AWS/Amazon Security via our [vulnerability reporting page](http://aws.amazon.com/security/vulnerability-reporting/). Please do **not** create a public github issue.


## Licensing

See the [LICENSE](LICENSE) file for our project's licensing. We will ask you to confirm the licensing of your contribution.



================================================
FILE: docker-compose.yml
================================================
networks:
  # This special network is configured so that the local metadata
  # service can bind to the specific IP address that ECS uses
  # in production
  credentials_network:
    driver: bridge
    ipam:
      config:
        - subnet: "169.254.170.0/24"
          gateway: 169.254.170.1

services:
  # This container vends credentials to your containers
  ecs-local-endpoints:
    # The Amazon ECS Local Container Endpoints Docker Image
    image: amazon/amazon-ecs-local-container-endpoints
    volumes:
      # Mount /var/run so we can access docker.sock and talk to Docker
      #- /var/run:/var/run
      # Mount the shared configuration directory, used by the AWS CLI and AWS SDKs
      # On Windows, this directory can be found at "%UserProfile%\.aws"
      # In the endpoints image, $HOME is set to /home.
      - $HOME/.aws/:/home/.aws/
    environment:
      # You can change which AWS CLI Profile is used
      AWS_PROFILE: "default"
    networks:
      credentials_network:
        # This special IP address is recognized by the AWS SDKs and AWS CLI
        ipv4_address: "169.254.170.2"

  # Storage for game data
  dynamodb-local:
    command: "-jar DynamoDBLocal.jar -sharedDb -dbPath ./data"
    image: "amazon/dynamodb-local:latest"
    container_name: dynamodb-local
    ports:
      - "8000:8000"
    volumes:
      - "./docker/dynamodb:/home/dynamodblocal/data"
    working_dir: /home/dynamodblocal
    networks:
      credentials_network:
        ipv4_address: "169.254.170.3"

  # Hosts the backend WebSocket server 
  server:
    build:
      context: ./server
      dockerfile: Dockerfile
    container_name: server
    ports:
      - "8080:8080"
    depends_on:
      # We must wait for the DB to available
      dynamodb-local:
        condition: service_started
      ecs-local-endpoints:
        condition: service_started
    env_file:
      - dev.env
    environment:
      AWS_REGION: us-west-2
      DYNAMODB_ENDPOINT: http://dynamodb-local:8000
      # This ENV VAR enables credentials
      # Set it to "/creds" or "/role/<role name>"
      AWS_CONTAINER_CREDENTIALS_RELATIVE_URI: "/creds"
      # Enables V3 Metadata
      ECS_CONTAINER_METADATA_URI: "http://169.254.170.2/v3"
    networks:
      credentials_network:
        ipv4_address: "169.254.170.4"
    develop:
      watch:
        - action: sync+restart
          path: ./server
          target: /app
          ignore:
            - node_modules/
        - action: rebuild
          path: package.json
    

  # Hosts the web server for the game client
  client:
    build:
      context: ./client
      dockerfile: Dockerfile
    container_name: client
    ports:
      - "5173:5173"
    depends_on:
      - server
    environment:
      VITE_WS_URL: http://localhost:8080/
    networks:
      credentials_network:
        ipv4_address: "169.254.170.5"
    develop:
      watch:
        - action: sync
          path: ./client
          target: /app
          ignore:
            - node_modules/
        - action: rebuild
          path: package.json
    


================================================
FILE: launch.ts
================================================

import { spawn } from 'child_process';
import { join } from 'path';

// Helper to create a process with proper output handling
function spawnProcess(command: string, args: string[], name: string, cwd: string) {
  const proc = spawn(command, args, {
    stdio: 'pipe',
    shell: true,
    cwd // Set working directory for the process
  });

  // Prefix output with component name
  proc.stdout.on('data', (data) => {
    const lines = data.toString().split('\n');
    lines.forEach((line: string) => {
      if (line.trim()) {
        console.log(`[${name}] ${line}`);
      }
    });
  });

  proc.stderr.on('data', (data) => {
    const lines = data.toString().split('\n');
    lines.forEach((line: string) => {
      if (line.trim()) {
        console.error(`[${name}] ${line}`);
      }
    });
  });

  proc.on('error', (error) => {
    console.error(`[${name}] Process error:`, error);
  });

  return proc;
}

// Array to track child processes
const processes: any[] = [];

// Get absolute paths for client and server directories
const clientDir = join(process.cwd(), 'client');
const serverDir = join(process.cwd(), 'server');

console.log('Starting client and server...');

// Start server (in server directory)
const server = spawnProcess('bun', ['--watch', 'server.ts'], 'server', serverDir);
processes.push(server);

// Start client (in client directory)
const client = spawnProcess('bun', ['run', 'dev'], 'client', clientDir);
processes.push(client);

// Handle process termination
function cleanup() {
  console.log('\nShutting down processes...');
  processes.forEach(proc => {
    if (!proc.killed) {
      proc.kill();
    }
  });
  process.exit(0);
}

// Handle termination signals
process.on('SIGINT', cleanup);
process.on('SIGTERM', cleanup);

// Handle process errors and exits
processes.forEach(proc => {
  proc.on('exit', (code: number) => {
    if (code !== 0) {
      console.error(`Process exited with code ${code}`);
      cleanup(); // Kill all processes if one fails
    }
  });
});

console.log('\nBoth processes started! Press Ctrl+C to stop both.\n');



================================================
FILE: LICENSE
================================================
MIT No Attribution

Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.




================================================
FILE: package.json
================================================
{
  "name": "spirit-of-kiro",
  "version": "1.0.0",
  "description": "AI-powered game with client and server components",
  "scripts": {
    "dev": "bun launch.ts"
  },
  "dependencies": {
    "@aws-sdk/client-dynamodb": "^3.821.0",
    "@types/uuid": "^10.0.0",
    "bun": "^1.0.0",
    "eslint": "^9.28.0",
    "uuid": "^11.1.0",
    "yaml": "^2.8.0"
  }
}



================================================
FILE: .dockerignore
================================================
node_modules


================================================
FILE: client/Dockerfile
================================================
FROM oven/bun:1.2.15

WORKDIR /app

# Copy package.json files first (for better layer caching)
COPY package.json ./

# Install dependencies
RUN bun install

# Copy the rest of the client files
COPY . .

# Expose port 5173 (the default Vite dev server port)
EXPOSE 5173

# Add healthcheck
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5173/ || exit 1

# Switch to non-root user

# Set the command to run "bun run dev" with host set to 0.0.0.0 to allow external access
CMD ["bun", "run", "dev", "--host", "0.0.0.0"]


================================================
FILE: client/env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: client/eslint.config.ts
================================================
import pluginVue from 'eslint-plugin-vue'
import { defineConfigWithVueTs, vueTsConfigs } from '@vue/eslint-config-typescript'
import pluginVitest from '@vitest/eslint-plugin'
import skipFormatting from '@vue/eslint-config-prettier/skip-formatting'

// To allow more languages other than `ts` in `.vue` files, uncomment the following lines:
// import { configureVueProject } from '@vue/eslint-config-typescript'
// configureVueProject({ scriptLangs: ['ts', 'tsx'] })
// More info at https://github.com/vuejs/eslint-config-typescript/#advanced-setup

export default defineConfigWithVueTs(
  {
    name: 'app/files-to-lint',
    files: ['**/*.{ts,mts,tsx,vue}'],
  },

  {
    name: 'app/files-to-ignore',
    ignores: ['**/dist/**', '**/dist-ssr/**', '**/coverage/**'],
  },

  pluginVue.configs['flat/essential'],
  vueTsConfigs.recommended,
  
  {
    ...pluginVitest.configs.recommended,
    files: ['src/**/__tests__/*'],
  },
  skipFormatting,
)



================================================
FILE: client/index.html
================================================
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spirit of Kiro</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>



================================================
FILE: client/package.json
================================================
{
  "name": "spirit-of-kiro",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "run-p type-check \"build-only {@}\" --",
    "preview": "vite preview",
    "test:unit": "vitest",
    "build-only": "vite build",
    "type-check": "vue-tsc --build",
    "lint": "eslint . --fix",
    "format": "prettier --write src/"
  },
  "dependencies": {
    "pinia": "^3.0.1",
    "vue": "^3.5.13",
    "vue-router": "4"
  },
  "devDependencies": {
    "@tsconfig/node22": "^22.0.0",
    "@types/jsdom": "^21.1.7",
    "@types/node": "^22.13.4",
    "@vitejs/plugin-vue": "^5.2.1",
    "@vitejs/plugin-vue-jsx": "^4.1.1",
    "@vitest/eslint-plugin": "1.1.31",
    "@vue/eslint-config-prettier": "^10.2.0",
    "@vue/eslint-config-typescript": "^14.4.0",
    "@vue/test-utils": "^2.4.6",
    "@vue/tsconfig": "^0.7.0",
    "eslint": "^9.20.1",
    "eslint-plugin-vue": "^9.32.0",
    "jiti": "^2.4.2",
    "jsdom": "^26.0.0",
    "npm-run-all2": "^7.0.2",
    "prettier": "^3.5.1",
    "typescript": "~5.7.3",
    "vite": "^6.1.0",
    "vite-plugin-vue-devtools": "^7.7.2",
    "vitest": "^3.0.5",
    "vue-tsc": "^2.2.2"
  }
}



================================================
FILE: client/tsconfig.app.json
================================================
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "include": ["env.d.ts", "src/**/*", "src/**/*.vue"],
  "exclude": ["src/**/__tests__/*"],
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",

    "paths": {
      "@/*": ["./src/*"]
    }
  }
}



================================================
FILE: client/tsconfig.json
================================================
{
  "files": [],
  "references": [
    {
      "path": "./tsconfig.node.json"
    },
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.vitest.json"
    }
  ]
}



================================================
FILE: client/tsconfig.node.json
================================================
{
  "extends": "@tsconfig/node22/tsconfig.json",
  "include": [
    "vite.config.*",
    "vitest.config.*",
    "cypress.config.*",
    "nightwatch.conf.*",
    "playwright.config.*",
    "eslint.config.*"
  ],
  "compilerOptions": {
    "noEmit": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",

    "module": "ESNext",
    "moduleResolution": "Bundler",
    "types": ["node"]
  }
}



================================================
FILE: client/tsconfig.vitest.json
================================================
{
  "extends": "./tsconfig.app.json",
  "include": ["src/**/__tests__/*", "env.d.ts"],
  "exclude": [],
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.vitest.tsbuildinfo",

    "lib": [],
    "types": ["node", "jsdom"]
  }
}



================================================
FILE: client/vite.config.ts
================================================
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueJsx from '@vitejs/plugin-vue-jsx'
import vueDevTools from 'vite-plugin-vue-devtools'

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    vueJsx(),
    vueDevTools(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    },
  },
})



================================================
FILE: client/vitest.config.ts
================================================
import { fileURLToPath } from 'node:url'
import { mergeConfig, defineConfig, configDefaults } from 'vitest/config'
import viteConfig from './vite.config'

export default mergeConfig(
  viteConfig,
  defineConfig({
    test: {
      environment: 'jsdom',
      exclude: [...configDefaults.exclude, 'e2e/**'],
      root: fileURLToPath(new URL('./', import.meta.url)),
    },
  }),
)



================================================
FILE: client/.dockerignore
================================================
node_modules


================================================
FILE: client/.editorconfig
================================================
[*.{js,jsx,mjs,cjs,ts,tsx,mts,cts,vue}]
charset = utf-8
indent_size = 2
indent_style = space
insert_final_newline = true
trim_trailing_whitespace = true

end_of_line = lf
max_line_length = 100



================================================
FILE: client/.prettierrc.json
================================================

{
  "$schema": "https://json.schemastore.org/prettierrc",
  "semi": false,
  "singleQuote": true,
  "printWidth": 100
}



================================================
FILE: client/iac/deploy.sh
================================================
#!/bin/bash
set -e

# Configuration
STACK_NAME="web-app"
REGION="us-east-1"  # CloudFront requires us-east-1 for Lambda@Edge

# Prompt for WebSocket server address if not provided
if [ -z "$1" ]; then
  read -p "Enter WebSocket server address (hostname:port): " WS_ENDPOINT
else
  WS_ENDPOINT=$1
fi

# Get domain name and certificate ARN
DOMAIN_NAME=${2:-"nathanpeck.gg"}
CERT_ARN=${3:-"arn:aws:acm:us-east-1:784059518401:certificate/94e1f477-2af7-4f9a-a547-5f4ddd59474b"}

# Validate WebSocket endpoint format
if ! [[ $WS_ENDPOINT =~ ^[^:]+:[0-9]+$ ]]; then
  echo "Error: WebSocket endpoint must be in format hostname:port"
  exit 1
fi

# Build the client application
echo "Building client application..."
cd ..
bun run build

# Deploy CloudFormation stack
echo "Deploying CloudFormation stack..."
aws cloudformation deploy \
  --template-file iac/web.yaml \
  --stack-name $STACK_NAME \
  --capabilities CAPABILITY_IAM \
  --region $REGION \
  --parameter-overrides \
    WebSocketEndpoint=$WS_ENDPOINT \
    DomainName=$DOMAIN_NAME \
    CertificateArn=$CERT_ARN

# Get the S3 bucket name from CloudFormation outputs
BUCKET_NAME=$(aws cloudformation describe-stacks \
  --stack-name $STACK_NAME \
  --query 'Stacks[0].Outputs[?OutputKey==`WebsiteBucketName`].OutputValue' \
  --output text \
  --region $REGION)

# Upload the built files to S3
echo "Uploading files to S3 bucket: $BUCKET_NAME"
aws s3 sync dist/ s3://$BUCKET_NAME/ \
  --delete \
  --cache-control "public, max-age=31536000" \
  --region $REGION

# Get the CloudFront distribution domain name
DISTRIBUTION_DOMAIN=$(aws cloudformation describe-stacks \
  --stack-name $STACK_NAME \
  --query 'Stacks[0].Outputs[?OutputKey==`DistributionDomainName`].OutputValue' \
  --output text \
  --region $REGION)

# Invalidate CloudFront cache
DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
  --stack-name $STACK_NAME \
  --query 'Stacks[0].Outputs[?OutputKey==`DistributionDomainName`].OutputValue' \
  --output text \
  --region $REGION | xargs -I {} aws cloudfront list-distributions --query "DistributionList.Items[?DomainName=='{}'].Id" --output text)

if [ -n "$DISTRIBUTION_ID" ]; then
  echo "Invalidating CloudFront cache for distribution: $DISTRIBUTION_ID"
  aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths '/*' --region $REGION --output text
else
  echo "Warning: Could not determine CloudFront distribution ID for cache invalidation."
fi

echo "Deployment complete!"
echo "Your application is available at: https://$DISTRIBUTION_DOMAIN"
echo "WebSocket server configured at: $WS_ENDPOINT"
echo "Username: tester"
echo "Password: spooky" 


================================================
FILE: client/iac/web.yaml
================================================
AWSTemplateFormatVersion: '2010-09-09'
Description: Creates the web infrastructure for the Spirit of Kiro game client, including a CloudFront distribution with basic authentication, S3 hosting, and WebSocket support. This setup provides secure, global access to the game client with real-time communication capabilities.

Parameters:
  DomainName:
    Type: String
    Description: Domain name for the CloudFront distribution
    Default: nathanpeck.gg
  CertificateArn:
    Type: String
    Description: ARN of the ACM certificate
    Default: arn:aws:acm:us-east-1:784059518401:certificate/94e1f477-2af7-4f9a-a547-5f4ddd59474b
  WebSocketEndpoint:
    Type: String
    Description: The WebSocket server endpoint (e.g., api.example.com:8080)
    Default: localhost:8080

Resources:
  # S3 Bucket for website hosting
  WebsiteBucket:
    Type: AWS::S3::Bucket
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LoggingConfiguration:
        DestinationBucketName: !Ref WebsiteLoggingBucket
        LogFilePrefix: website-access-logs/

  # S3 Bucket for website access logs
  WebsiteLoggingBucket:
    Type: AWS::S3::Bucket
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  # S3 Bucket for CloudFront logging
  CloudFrontLoggingBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-cf-logs-${AWS::AccountId}"
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  # CloudFront Origin Access Control
  CloudFrontOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub "OAC for ${AWS::StackName}"
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  # CloudFront Distribution
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultRootObject: index.html
        HttpVersion: http3
        Logging:
          Bucket: !Sub "${CloudFrontLoggingBucket.DomainName}"
          Prefix: cf-logs/
          IncludeCookies: false
        Origins:
          - DomainName: !GetAtt WebsiteBucket.RegionalDomainName
            Id: S3Origin
            OriginAccessControlId: !GetAtt CloudFrontOAC.Id
            S3OriginConfig:
              OriginAccessIdentity: ''
          - DomainName: !Select [0, !Split [':', !Ref WebSocketEndpoint]]
            Id: WebSocketOrigin
            CustomOriginConfig:
              HTTPSPort: !Select [1, !Split [':', !Ref WebSocketEndpoint]]
              OriginKeepaliveTimeout: 15
              OriginProtocolPolicy: https-only
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
            - OPTIONS
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
          Compress: true
          LambdaFunctionAssociations:
            - EventType: viewer-request
              LambdaFunctionARN: !GetAtt BasicAuthFunctionVersion.FunctionArn
          MinTTL: 3600
          DefaultTTL: 86400
          MaxTTL: 31536000
        CacheBehaviors:
          - PathPattern: /ws*
            TargetOriginId: WebSocketOrigin
            ViewerProtocolPolicy: redirect-to-https
            AllowedMethods:
              - GET
              - HEAD
              - OPTIONS
              - PUT
              - POST
              - PATCH
              - DELETE
            CachedMethods:
              - GET
              - HEAD
              - OPTIONS
            ForwardedValues:
              QueryString: true
              Headers:
                - Origin
                - Access-Control-Request-Headers
                - Access-Control-Request-Method
                - Sec-WebSocket-Key
                - Sec-WebSocket-Version
                - Sec-WebSocket-Protocol
                - Sec-WebSocket-Accept
                - Sec-WebSocket-Extensions
              Cookies:
                Forward: none
            Compress: true
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
        PriceClass: PriceClass_100
        Aliases:
          - !Ref DomainName
        ViewerCertificate:
          AcmCertificateArn: !Ref CertificateArn
          MinimumProtocolVersion: TLSv1.2_2021
          SslSupportMethod: sni-only

  # Bucket Policy
  WebsiteBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref WebsiteBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub 'arn:aws:s3:::${WebsiteBucket}/*'
            Condition:
              StringEquals:
                'AWS:SourceArn': !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}'
              Bool:
                aws:SecureTransport: "true"

  # Lambda@Edge function for basic auth
  BasicAuthFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt BasicAuthFunctionRole.Arn
      Code:
        ZipFile: |
          exports.handler = (event, context, callback) => {
            const request = event.Records[0].cf.request;
            const headers = request.headers;
            
            const authString = 'Basic ' + Buffer.from('tester:spooky').toString('base64');
            
            if (typeof headers.authorization === 'undefined' || headers.authorization[0].value !== authString) {
              const response = {
                status: '401',
                statusDescription: 'Unauthorized',
                headers: {
                  'www-authenticate': [{ key: 'WWW-Authenticate', value: 'Basic realm="Secure Area"' }]
                }
              };
              callback(null, response);
            }
            
            callback(null, request);
          };
      Runtime: nodejs20.x
      Timeout: 5

  # Lambda function version
  BasicAuthFunctionVersion:
    Type: AWS::Lambda::Version
    Properties:
      FunctionName: !Ref BasicAuthFunction
      Description: "Initial version for basic auth"

  # IAM Role for Lambda@Edge
  BasicAuthFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - lambda.amazonaws.com
                - edgelambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "${AWS::StackName}-lambda-execution-policy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-*:*"

  # CloudFront logging bucket policy
  CloudFrontLoggingBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref CloudFrontLoggingBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: 
              - s3:PutObject
              - s3:PutObjectAcl
            Resource: !Sub "${CloudFrontLoggingBucket.Arn}/*"
            Condition:
              StringEquals:
                'AWS:SourceArn': !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}'
              Bool:
                aws:SecureTransport: "true"

  WebsiteLoggingBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref WebsiteLoggingBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: s3.amazonaws.com
            Action: 
              - s3:PutObject
            Resource: !Sub "${WebsiteLoggingBucket.Arn}/*"
            Condition:
              StringEquals:
                'AWS:SourceAccount': !Ref AWS::AccountId
              Bool:
                aws:SecureTransport: "true"

Outputs:
  DistributionDomainName:
    Description: Domain name of the CloudFront distribution
    Value: !GetAtt CloudFrontDistribution.DomainName
  WebsiteBucketName:
    Description: Name of the S3 bucket hosting the website
    Value: !Ref WebsiteBucket 


================================================
FILE: client/src/App.vue
================================================

<script setup lang="ts">
import { onMounted, onUnmounted, watch } from 'vue'
import { useGameStore } from './stores/game'
import { useRouter } from 'vue-router'

const gameStore = useGameStore()
const router = useRouter()

onMounted(() => {
  // Initialize WebSocket at app root level
  gameStore.initWebSocket()
})

onUnmounted(() => {
  // Clean up WebSocket resources when app is unmounted
  gameStore.cleanup()
})

// Add watcher for authentication state changes
watch(() => gameStore.isAuthenticated, (newValue, oldValue) => {
  // If user was authenticated and now is not, redirect to auth page
  if (oldValue === true && newValue === false) {
    router.push('/auth')
  }
})
</script>

<template>
  <div class="app">
    <router-view />
  </div>
</template>




================================================
FILE: client/src/main.ts
================================================
import './assets/main.css'

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'

const app = createApp(App)

app.use(createPinia())
app.use(router)
app.mount('#app')



================================================
FILE: client/src/assets/base.css
================================================
/* color palette from <https://github.com/vuejs/theme> */
:root {
  --vt-c-white: #ffffff;
  --vt-c-white-soft: #f8f8f8;
  --vt-c-white-mute: #f2f2f2;

  --vt-c-black: #181818;
  --vt-c-black-soft: #222222;
  --vt-c-black-mute: #282828;

  --vt-c-indigo: #2c3e50;

  --vt-c-divider-light-1: rgba(60, 60, 60, 0.29);
  --vt-c-divider-light-2: rgba(60, 60, 60, 0.12);
  --vt-c-divider-dark-1: rgba(84, 84, 84, 0.65);
  --vt-c-divider-dark-2: rgba(84, 84, 84, 0.48);

  --vt-c-text-light-1: var(--vt-c-indigo);
  --vt-c-text-light-2: rgba(60, 60, 60, 0.66);
  --vt-c-text-dark-1: var(--vt-c-white);
  --vt-c-text-dark-2: rgba(235, 235, 235, 0.64);
}

/* semantic color variables for this project */
:root {
  --color-background: var(--vt-c-white);
  --color-background-soft: var(--vt-c-white-soft);
  --color-background-mute: var(--vt-c-white-mute);

  --color-border: var(--vt-c-divider-light-2);
  --color-border-hover: var(--vt-c-divider-light-1);

  --color-heading: var(--vt-c-text-light-1);
  --color-text: var(--vt-c-text-light-1);

  --section-gap: 160px;
}

@media (prefers-color-scheme: dark) {
  :root {
    --color-background: var(--vt-c-black);
    --color-background-soft: var(--vt-c-black-soft);
    --color-background-mute: var(--vt-c-black-mute);

    --color-border: var(--vt-c-divider-dark-2);
    --color-border-hover: var(--vt-c-divider-dark-1);

    --color-heading: var(--vt-c-text-dark-1);
    --color-text: var(--vt-c-text-dark-2);
  }
}

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  font-weight: normal;
}

body {
  min-height: 100vh;
  color: var(--color-text);
  background: var(--color-background);
  transition:
    color 0.5s,
    background-color 0.5s;
  line-height: 1.6;
  font-family:
    Inter,
    -apple-system,
    BlinkMacSystemFont,
    'Segoe UI',
    Roboto,
    Oxygen,
    Ubuntu,
    Cantarell,
    'Fira Sans',
    'Droid Sans',
    'Helvetica Neue',
    sans-serif;
  font-size: 15px;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}



================================================
FILE: client/src/assets/index.ts
================================================
// Main game assets
import background from './background.png'
import computer from './computer.png'
import computerZoom from './computer-zoom.png'
import happy from './happy.png'
import neutral from './neutral.png'
import unhappy from './unhappy.png'
import sellTable from './sell-table.png'
import appraising from './appraising.png'
import chest from './chest.png'
import chestOpen from './chest-open.png'
import generic from './generic.png'
import workbench from './workbench.png'
import workbenchZoom from './workbench-zoom.png'
import shelf from './shelf.png'
import panelBackground from './panel-background.png'
import lever from './lever.png'
import garbage from './garbage.png'
import dispenser from './dispenser.png'
import chute from './chute.png'

// Tutorial assets
import tutorialGhost from './tutorial/ghost.png'
import tutorialDispenser from './tutorial/dispenser.png'
import tutorialWorkbench from './tutorial/workbench.png'
import tutorialShopkeeper from './tutorial/shopkeeper.png'

// Ghost assets
import ghostSouthwest from './kiro-ghost/southwest.png'
import ghostSouth from './kiro-ghost/south.png'
import ghostNortheast from './kiro-ghost/northeast.png'
import ghostNorth from './kiro-ghost/north.png'
import ghostEast from './kiro-ghost/east.png'

// Export all assets as an object
export const staticAssets = {
  // Main game assets
  background,
  computer,
  computerZoom,
  happy,
  neutral,
  unhappy,
  sellTable,
  appraising,
  chest,
  chestOpen,
  generic,
  workbench,
  workbenchZoom,
  shelf,
  panelBackground,
  lever,
  garbage,
  dispenser,
  chute,
  // Tutorial assets
  tutorialGhost,
  tutorialDispenser,
  tutorialWorkbench,
  tutorialShopkeeper,
  // Ghost assets
  ghostSouthwest,
  ghostSouth,
  ghostNortheast,
  ghostNorth,
  ghostEast
} 


================================================
FILE: client/src/assets/main.css
================================================
@import './base.css';

body {
  background-color: black;
  margin: 0;
  padding: 0;
}

/* Item container styles */
.item-container {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: all 0.3s ease;
  position: relative;
}

/* Item image base styles */
.item-image, .held-item-image {
  width: 100%;
  height: 100%;
  object-fit: contain;
  border-radius: 10px;
  transition: transform 0.3s ease, border 0.3s ease, box-shadow 0.3s ease;
  border: .25em solid #333;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}

/* Item name styles */
.item-name {
  position: absolute;
  bottom: -24px;
  left: 0;
  width: 100%;
  color: white;
  font-size: 12px;
  text-align: center;
  padding: 4px;
  word-break: break-word;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
}

/* Apply different colors based on item rarity */
.item-common .item-name {
  color: #ffffff;
}

.item-uncommon .item-name {
  color: #4caf50;
}

.item-rare .item-name {
  color: #2196f3;
}

.item-epic .item-name {
  color: #9c27b0;
  text-shadow: 0 0 4px rgba(156, 39, 176, 0.6);
}

.item-legendary .item-name {
  color: #ff9800;
  text-shadow: 0 0 6px rgba(255, 152, 0, 0.8);
  animation: pulse-glow 2s infinite;
}

/* Apply rarity-based styling to item images */
.item-common .item-image, .item-common .held-item-image {
  border-color: #333;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}

.item-uncommon .item-image, .item-uncommon .held-item-image {
  border-color: #4caf50;
  box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
}

.item-rare .item-image, .item-rare .held-item-image {
  border-color: #2196f3;
  box-shadow: 0 0 10px rgba(33, 150, 243, 0.3);
}

.item-epic .item-image, .item-epic .held-item-image {
  border-color: #9c27b0;
  box-shadow: 0 0 10px rgba(156, 39, 176, 0.3);
}

.item-legendary .item-image, .item-legendary .held-item-image {
  border-color: #ff9800;
  box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
  animation: image-pulse 2s infinite;
}

/* Animation keyframes */
@keyframes pulse-glow {
  0% { text-shadow: 0 0 4px rgba(255, 152, 0, 0.6); }
  50% { text-shadow: 0 0 10px rgba(255, 152, 0, 0.9); }
  100% { text-shadow: 0 0 4px rgba(255, 152, 0, 0.6); }
}

@keyframes image-pulse {
  0% { box-shadow: 0 0 10px rgba(255, 152, 0, 0.3); }
  50% { box-shadow: 0 0 20px rgba(255, 152, 0, 0.6); }
  100% { box-shadow: 0 0 10px rgba(255, 152, 0, 0.3); }
}

/* Dot colors based on item rarity */
.capacity-dot.empty {
  background-color: rgba(255, 255, 255, 0.3);
}

.capacity-dot.item-common {
  background-color: #ffffff;
}

.capacity-dot.item-uncommon {
  background-color: #4caf50;
}

.capacity-dot.item-rare {
  background-color: #2196f3;
}

.capacity-dot.item-epic {
  background-color: #9c27b0;
}

.capacity-dot.item-legendary {
  background-color: #ff9800;
  box-shadow: 0 0 4px rgba(255, 152, 0, 0.8);
}

/* Gold display styling */

.gold-icon {
  width: 16px;
  height: 16px;
  background: linear-gradient(135deg, #ffd700, #ffa500);
  border-radius: 50%;
  box-shadow: 0 0 4px rgba(255, 215, 0, 0.5);
}


================================================
FILE: client/src/components/Banner.vue
================================================

<template>
  <div 
    class="banner" 
    :class="{ 'banner-visible': isVisible }"
    :style="{ 
      position: 'absolute',
      left: `${col * tileSize}px`,
      top: `${row * tileSize}px`,
      width: `${width * tileSize}px`
     }"
  >
    {{ currentMessage }}
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import { useGameStore } from '../stores/game';

const props = defineProps<{
  row: number,
  col: number,
  width: number,
  tileSize: number
}>();

const gameStore = useGameStore();
const currentMessage = ref('');
const isVisible = ref(false);
let hideTimeout: number | null = null;

const showMessage = (message: string, duration: number) => {
  // Clear any existing timeout
  if (hideTimeout) {
    clearTimeout(hideTimeout);
  }
  
  // Show new message
  currentMessage.value = message;
  isVisible.value = true;
  
  // Set timeout to hide message
  hideTimeout = setTimeout(() => {
    isVisible.value = false;
    currentMessage.value = '';
  }, duration);
};

// Set up event listener for announcements
let announcementListenerId: string;

onMounted(() => {
  announcementListenerId = gameStore.addEventListener('announce', (data) => {
    if (data && typeof data.message === 'string' && typeof data.duration === 'number') {
      showMessage(data.message, data.duration);
    }
  });
});

onUnmounted(() => {
  if (hideTimeout) {
    clearTimeout(hideTimeout);
  }
  gameStore.removeEventListener('announce', announcementListenerId);
});
</script>

<style scoped>
.banner {
  position: absolute;
  top: 0;
  margin: 0 auto;
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 10px 20px;
  border-radius: 0 0 8px 8px;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
  z-index: 1000;
}

.banner-visible {
  opacity: 1;
}
</style>



================================================
FILE: client/src/components/BuyPreview.vue
================================================
<script setup lang="ts">
import { computed } from 'vue';
import { getRarityClass } from '../utils/items';
import type { Item } from '../systems/item-system';

const props = defineProps<{
  item: Item | null;
  // Position configuration props
  position?: string;
  top?: string;
  right?: string;
  bottom?: string;
  left?: string;
  transform?: string;
}>();

// Determine CSS class based on item value
const rarityClass = computed(() => {
  if (!props.item || props.item.value === undefined) return 'item-common';
  return getRarityClass(props.item.value);
});

// Compute the positioning style based on props without defaults
const positionStyle = computed(() => {
  return {
    position: props.position as 'static' | 'relative' | 'absolute' | 'fixed' | 'sticky' | undefined,
    top: props.top,
    right: props.right,
    bottom: props.bottom,
    left: props.left,
    transform: props.transform
  };
});
</script>

<template>
  <div v-if="item" class="buy-preview" :class="rarityClass" :style="positionStyle">
    <div class="preview-content">
      <div class="price-container">
        <div class="gold-display">
          <div class="gold-icon"></div>
          <span v-if="item.value !== undefined" class="price-tag">
            {{ item.value }}
          </span>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.buy-preview {
  background-color: rgba(40, 40, 40, 0.8);
  border-radius: 12px;
  width: auto;
  max-width: none;
  padding: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  z-index: 30;
  pointer-events: none;
}

.buy-preview.item-uncommon {
  border: 2px solid #4caf50;
  box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
}

.buy-preview.item-rare {
  border: 2px solid #2196f3;
  box-shadow: 0 0 20px rgba(33, 150, 243, 0.3);
}

.buy-preview.item-epic {
  border: 2px solid #9c27b0;
  box-shadow: 0 0 20px rgba(156, 39, 176, 0.3);
}

.buy-preview.item-legendary {
  border: 2px solid #ff9800;
  box-shadow: 0 0 20px rgba(255, 152, 0, 0.5);
}

.preview-content {
  padding: 0;
  display: flex;
  align-items: center;
}

.price-container {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 12px;
  color: white;
  font-weight: bold;
}

.gold-display {
  display: flex;
  align-items: center;
  gap: 8px;
}

.price-tag {
  font-size: 1.1em;
  color: white;
  font-weight: bold;
}

.item-name {
  font-size: 0.9em;
  text-align: center;
  white-space: nowrap;
}

.item-name.item-uncommon {
  color: #4caf50;
}

.item-name.item-rare {
  color: #2196f3;
}

.item-name.item-epic {
  color: #9c27b0;
}

.item-name.item-legendary {
  color: #ff9800;
}
</style> 


================================================
FILE: client/src/components/Chest.vue
================================================
<script setup lang="ts">
import chestImage from '../assets/chest.png';
import chestOpenImage from '../assets/chest-open.png';
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { useGameStore } from '../stores/game';
import ChestFullscreen from './ChestFullscreen.vue';
import { getRarityClass } from '../utils/items';

const props = defineProps<{
  row: number;
  col: number;
  tileSize: number;
  width: number;
  depth: number;
  height: number;
  playerIsNear: boolean;
}>();

const gameStore = useGameStore();
const showFullscreen = ref(false);

const inventoryName = "chest1";
const inventory = gameStore.useInventory(inventoryName);

// Add maxCapacity constant
const maxCapacity = 21;

// Create computed property for usedCapacity
const usedCapacity = computed(() => {
  return inventory.value.length;
});

// Computed property to determine the color of each dot based on item rarity
const capacityDots = computed(() => {
  const dots = [];
  const items = inventory.value.map(id => gameStore.useItem(id).value).filter(Boolean);
  
  // Fill dots with items that exist in inventory
  for (let i = 0; i < Math.min(items.length, maxCapacity); i++) {
    const item = items[i];
    if (!item) {
      continue;
    }
    const rarityClass = getRarityClass(item.value);
    dots.push({
      filled: true,
      rarityClass
    });
  }
  
  // Fill remaining dots as empty
  for (let i = items.length; i < maxCapacity; i++) {
    dots.push({
      filled: false,
      rarityClass: 'empty'
    });
  }
  
  return dots;
});

const linkedInventory = computed(() => {
  return `${gameStore.userId}:${inventoryName}`
});

function handlePlayerInteraction() {
  if (!props.playerIsNear) {
    return;
  }

  if (!gameStore.heldItemId) {
    showFullscreen.value = true;
    return;
  }
  
  // Check if player is holding an item
  if (gameStore.heldItemId) {
    // Check if the chest is full before adding the item
    if (usedCapacity.value >= maxCapacity) {
      // Chest is full, emit drop-item event and open chest without adding item
      gameStore.emitEvent('drop-item', { itemId: gameStore.heldItemId });
      showFullscreen.value = true;
      return;
    }
    
    // Chest has space, move the held item to the chest inventory
    gameStore.moveItem(
      gameStore.heldItemId,
      linkedInventory.value
    );
    
    // Remove the held item
    gameStore.heldItemId = null;
  }
}

function handleItemMoved(data: any) {
  if (!data) {
    return;
  }
   
  if (data.targetInventoryId === linkedInventory.value) {
    // Open the chest when an item is moved to it
    showFullscreen.value = true;
  }
}

let interactionListenerId: string;
let itemMovedListenerId: string;

onMounted(() => {
  interactionListenerId = gameStore.addEventListener('player-interaction', handlePlayerInteraction);
  itemMovedListenerId = gameStore.addEventListener('item-moved', handleItemMoved);
});

onUnmounted(() => {
  gameStore.removeEventListener('player-interaction', interactionListenerId);
  gameStore.removeEventListener('item-moved', itemMovedListenerId);
});

const closeFullscreen = () => {
  showFullscreen.value = false;
};
</script>

<template>
  <div>
    <!-- Regular chest view -->
    <div :style="{
      position: 'absolute',
      top: `${row * tileSize}px`,
      left: `${col * tileSize}px`,
      width: `${width * tileSize}px`,
      height: `${depth * tileSize}px`,
      border: gameStore.debug ? '1px solid red': 'none'
    }">
      <div v-if="playerIsNear" class="interact-prompt">E</div>
      
      <img 
        :src="chestImage" 
        :width="width * tileSize" 
        :style="{
          position: 'absolute',
          top: `-${tileSize * .5}px`
        }"
        :class="['chest', { 'chest-active': playerIsNear }]"
        alt="Chest"
      />

      <!-- Capacity display as grid of dots -->
      <div v-if="playerIsNear" class="capacity-grid">
        <div 
          v-for="(dot, index) in capacityDots" 
          :key="index" 
          class="capacity-dot"
          :class="[dot.rarityClass]"
        ></div>
      </div>
      <!-- Height visualization line (only visible in debug mode) -->
      <div v-if="gameStore.debug" class="height-line" :style="{
        position: 'absolute',
        left: '0',
        bottom: '0',
        width: '2px',
        height: `${height * tileSize}px`,
        backgroundColor: 'blue',
        zIndex: 1000
      }" />
    </div>

    <ChestFullscreen
      :show="showFullscreen"
      :chest-image="chestOpenImage"
      :items="inventory"
      @close="closeFullscreen"
    />
  </div>
</template>

<style scoped>
.chest {
  filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.5));
  object-fit: contain;
  transition: filter 0.3s ease;
}

.chest-active {
  filter: drop-shadow(0 0 15px white);
}

.interact-prompt {
  position: absolute;
  top: calc(-1.1 * v-bind(tileSize) * 1px);
  left: 50%;
  transform: translateX(-50%);
  font-size: calc(0.5 * v-bind(tileSize) * 1px);
  font-weight: bold;
  color: white;
  text-shadow: 0 0 5px white;
  animation: pulse 1s infinite;
  background-color: black;
  padding: calc(0.1 * v-bind(tileSize) * 1px) calc(0.1 * v-bind(tileSize) * 1px);
  border-radius: calc(0.08 * v-bind(tileSize) * 1px);
  z-index: 1;
  line-height: 1;
}

.capacity-grid {
  position: absolute;
  top: 0;
  left: 46.5%;
  transform: translateX(-50%);
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: calc(0.05 * v-bind(tileSize) * 1px);
  width: calc(0.7 * v-bind(tileSize) * 1px);
}

.capacity-dot {
  width: calc(0.08 * v-bind(tileSize) * 1px);
  height: calc(0.08 * v-bind(tileSize) * 1px);
  border-radius: 50%;
  box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
}

@keyframes pulse {
  0% { opacity: 0.5; }
  50% { opacity: 1; }
  100% { opacity: 0.5; }
}
</style>


================================================
FILE: client/src/components/ChestFullscreen.vue
================================================
<script setup lang="ts">
import { onMounted, onUnmounted, watch, ref, computed } from 'vue';
import { useGameStore } from '../stores/game';
import { getRarityClass } from '../utils/items';
import ItemPreview from './ItemPreview.vue';
import { useEscapeKeyHandler } from '../composables/useEscapeKeyHandler';

const gameStore = useGameStore();
const props = defineProps<{
  show: boolean;
  chestImage: string;
  items: string[];
}>();

const emit = defineEmits<{
  (e: 'close'): void;
  (e: 'action', action: string, itemId?: string): void;
}>();

// State to track which item is being hovered
const hoveredItemId = ref<string | null>(null);

// Map the item IDs to actual item objects using useItem
const mappedItems = computed(() => {
  return props.items.map(id => gameStore.useItem(id).value);
});

// Get the currently hovered item object
const hoveredItem = computed(() => {
  if (!hoveredItemId.value) return null;
  return gameStore.useItem(hoveredItemId.value).value;
});

const handleItemClick = (itemId: string) => {
  const targetInventory = `${gameStore.userId}:main`;

  // Clear the hovered item preview immediately when an item is clicked
  hoveredItemId.value = null;

  // Set up a one-time listener for the 'item-moved' event
  const listenerId = gameStore.addEventListener('item-moved', (data) => {
    // Check if this is the item we just moved
    if (data && data.itemId === itemId && data.targetInventoryId === targetInventory) {
      // Remove the listener since we only need it once
      gameStore.removeEventListener('item-moved', listenerId);
      
      // Close the chest fullscreen view
      emit('close');
      
      // Put the item in the player's hands
      gameStore.emitEvent('item-pickup', {
        id: data.itemId
      })
    }
  });

  // Move the item from chest to main inventory
  gameStore.moveItem(itemId, targetInventory);
};

const handleItemMouseEnter = (itemId: string) => {
  hoveredItemId.value = itemId;
};

const handleItemMouseLeave = () => {
  hoveredItemId.value = null;
};

// Use the escape key handler
const { handleKeyDown } = useEscapeKeyHandler('chest-fullscreen', (event) => {
  if (event.key === 'Escape' && props.show) {
    emit('close');
    return true;
  }
  return false;
});

onMounted(() => {
  // Watch for show prop changes to manage focus
  watch(() => props.show, (newValue) => {
    if (newValue) {
      gameStore.pushFocus('chest-fullscreen');
    } else {
      gameStore.popFocus();
    }
  });
});

onUnmounted(() => {
  // No need to clean up event listeners as useEscapeKeyHandler handles that
});
</script>

<template>
  <div v-if="show" class="fullscreen-overlay">
    <div class="chest-container" :style="{ backgroundImage: `url(${chestImage})` }">
      <button class="close-button" @click="$emit('close')">Back</button>
      
      <!-- Item Preview Component -->
      <ItemPreview 
        :item="hoveredItem"
        position="absolute"
        bottom="55%"
        left="50%"
        transform="translateX(-50%)"
      />
      
      <div class="inventory-area">
        <div class="inventory-grid">
          <div 
            class="inventory-slot" 
            :class="{ 'has-item': item }" 
            v-for="item in mappedItems" 
            :key="item.id"
            @click="item && handleItemClick(item.id)"
            @mouseenter="item && handleItemMouseEnter(item.id)"
            @mouseleave="handleItemMouseLeave"
          >
            <div v-if="item" class="item-container" :class="getRarityClass(item.value)">
              <img :src="item.imageUrl" class="item-image" :alt="item.name" />
            </div>
          </div>
          <!-- Add empty slots to fill the grid if needed -->
          <div 
            class="inventory-slot" 
            v-for="n in Math.max(0, 21 - mappedItems.length)" 
            :key='n'
          ></div>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.fullscreen-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.chest-container {
  position: relative;
  width: min(90vh, 90vw); /* Use the smaller of viewport width or height */
  height: min(90vh, 90vw); /* Match width to maintain square ratio */
  max-width: min(90vh, 1200px);
  max-height: min(90vh, 1200px);
  margin: auto;
  background-size: contain;
  background-position: center;
  background-repeat: no-repeat;
  display: flex;
  justify-content: center;
  align-items: center;
}

.close-button {
  position: absolute;
  top: 5%;
  left: 0px;
  margin-right: 5%;
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  height: 50px;
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: 10%;
  transition: background-color 0.3s;
  padding: 1%;
  z-index: 20;
}

.close-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.inventory-area {
  position: absolute;
  width: 58%;
  height: 24%;
  top: 47%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
}

.inventory-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 10px;
  width: 100%;
  height: 100%;
}

.inventory-slot {
  background: transparent;
  border: 3px dashed rgb(113, 67, 31);
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: rgba(255, 255, 255, 0.5);
  font-size: 0.9em;
  transition: border-color 0.3s, background-color 0.3s;
  position: relative;
}

.inventory-slot.has-item {
  border: none;
}

.inventory-slot.has-item:hover .item-container {
  transform: scale(1.05);
  cursor: pointer;
}

.inventory-slot:hover {
  border-color: rgb(173, 127, 91);
  background-color: rgba(113, 67, 31, 0.2);
}

/* Item styles moved to main.css */

.item-name {
  font-size: 0.7em;
  color: white;
  text-align: center;
  margin-top: 4px;
  text-shadow: 1px 1px 2px black;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  width: 90%;
}
</style>


================================================
FILE: client/src/components/Computer.vue
================================================
<script setup lang="ts">
import computerImage from '../assets/computer.png';
import computerZoomImage from '../assets/computer-zoom.png';
import { useGameStore } from '../stores/game';
import { ref, onMounted, onUnmounted, computed } from 'vue';
import ComputerFullscreen from './ComputerFullscreen.vue';
import { getRarityClass } from '../utils/items';

const props = defineProps<{
  row: number;
  col: number;
  tileSize: number;
  width: number;
  depth: number;
  height: number;
  playerIsNear: boolean;
}>();

const gameStore = useGameStore();
const showFullscreen = ref(false);

const inventoryName = "computer";
const inventory = gameStore.useInventory(inventoryName);

// Add maxCapacity constant
const maxCapacity = 21;

// Computed property to determine the color of each dot based on item rarity
const capacityDots = computed(() => {
  const dots = [];
  const items = inventory.value.map(id => gameStore.useItem(id).value);
  
  // Fill dots with items that exist in inventory
  for (let i = 0; i < Math.min(items.length, maxCapacity); i++) {
    const item = items[i];
    if (item) {
      const rarityClass = getRarityClass(item.value);
      dots.push({
        filled: true,
        rarityClass
      });
    }
  }
  
  // Fill remaining dots as empty
  for (let i = items.length; i < maxCapacity; i++) {
    dots.push({
      filled: false,
      rarityClass: 'empty'
    });
  }
  
  return dots;
});

const linkedInventory = computed(() => {
  return `${gameStore.userId}:${inventoryName}`
});

// Function to handle player interaction with the computer
const handlePlayerInteraction = () => {
  if (!props.playerIsNear) {
    return;
  }

  if (!gameStore.heldItemId) {
    showFullscreen.value = true;
    return;
  }
  
  // Check if player is holding an item
  if (gameStore.heldItemId) {
    // Drop the held item and open computer
    gameStore.emitEvent('drop-item', { itemId: gameStore.heldItemId });
    showFullscreen.value = true;
  }
};

function handleItemMoved(data: any) {
  if (!data) {
    return;
  }
   
  if (data.targetInventoryId === linkedInventory.value) {
    // Open the computer when an item is moved to it
    showFullscreen.value = true;
  }
}

let interactionListenerId: string;
let itemMovedListenerId: string;

onMounted(() => {
  interactionListenerId = gameStore.addEventListener('player-interaction', handlePlayerInteraction);
  itemMovedListenerId = gameStore.addEventListener('item-moved', handleItemMoved);
  // Pre-fetch discarded items when computer is mounted
  gameStore.peekDiscarded(21);
});

onUnmounted(() => {
  gameStore.removeEventListener('player-interaction', interactionListenerId);
  gameStore.removeEventListener('item-moved', itemMovedListenerId);
});

const closeFullscreen = () => {
  showFullscreen.value = false;
};
</script>

<template>
  <div>
    <!-- Regular computer view -->
    <div :style="{
      position: 'absolute',
      top: `${row * tileSize}px`,
      left: `${col * tileSize}px`,
      width: `${width * tileSize}px`,
      height: `${depth * tileSize}px`,
      border: gameStore.debug ? '1px solid red': 'none'
    }">
      <div v-if="playerIsNear" class="interact-prompt">E</div>
      
      <img 
        :src="computerImage" 
        :width="width * tileSize" 
        :style="{
          position: 'absolute',
          top: `-${tileSize * 1}px`
        }"
        :class="['computer', { 'computer-active': playerIsNear }]"
        alt="Computer"
      />

      <!-- Capacity display as grid of dots -->
      <div v-if="playerIsNear" class="capacity-grid">
        <div 
          v-for="(dot, index) in capacityDots" 
          :key="index" 
          class="capacity-dot"
          :class="[dot.rarityClass]"
        ></div>
      </div>
      
      <!-- Height visualization line (only visible in debug mode) -->
      <div v-if="gameStore.debug" class="height-line" :style="{
        position: 'absolute',
        left: '0',
        bottom: '0',
        width: '2px',
        height: `${height * tileSize}px`,
        backgroundColor: 'blue',
        zIndex: 1000
      }" />
    </div>

    <ComputerFullscreen
      :show="showFullscreen"
      :computer-image="computerZoomImage"
      :items="inventory"
      @close="closeFullscreen"
    />
  </div>
</template>

<style scoped>
.computer {
  filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.5));
  object-fit: contain;
  transition: filter 0.3s ease;
}

.computer-active {
  filter: drop-shadow(0 0 15px white);
}

.interact-prompt {
  position: absolute;
  top: calc(-.3 * v-bind(tileSize) * 1px);
  left: calc(2 * v-bind(tileSize) * 1px);
  font-size: calc(0.5 * v-bind(tileSize) * 1px);
  font-weight: bold;
  color: white;
  text-shadow: 0 0 5px white;
  animation: pulse 1s infinite;
  background-color: black;
  padding: calc(0.1 * v-bind(tileSize) * 1px) calc(0.1 * v-bind(tileSize) * 1px);
  border-radius: calc(0.08 * v-bind(tileSize) * 1px);
  z-index: 1;
  line-height: 1;
}

.capacity-grid {
  position: absolute;
  top: -21.5%;
  left: 46.5%;
  transform: translateX(-50%);
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: calc(0.05 * v-bind(tileSize) * 1px);
  width: calc(0.7 * v-bind(tileSize) * 1px);
}

.capacity-dot {
  width: calc(0.08 * v-bind(tileSize) * 1px);
  height: calc(0.08 * v-bind(tileSize) * 1px);
  border-radius: 50%;
  box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
}

@keyframes pulse {
  0% { opacity: 0.5; }
  50% { opacity: 1; }
  100% { opacity: 0.5; }
}
</style> 


================================================
FILE: client/src/components/ComputerFullscreen.vue
================================================
<script setup lang="ts">
import { onMounted, onUnmounted, watch, ref, computed } from 'vue';
import { useGameStore } from '../stores/game';
import { getRarityClass } from '../utils/items';
import BuyPreview from './BuyPreview.vue';
import { useEscapeKeyHandler } from '../composables/useEscapeKeyHandler';

const gameStore = useGameStore();
const props = defineProps<{
  show: boolean;
  computerImage: string;
  items: string[];
}>();

const emit = defineEmits<{
  (e: 'close'): void;
  (e: 'action', action: string, itemId?: string): void;
}>();

// State to track which item is being hovered
const hoveredItemId = ref<string | null>(null);
const hoveredItemPosition = ref({ x: 0, y: 0 });

// Map the item IDs to actual item objects using useItem
const mappedItems = computed(() => {
  return props.items.map(id => gameStore.useItem(id).value);
});

// Get the currently hovered item object
const hoveredItem = computed(() => {
  if (!hoveredItemId.value) return null;
  return gameStore.useItem(hoveredItemId.value).value;
});

const handleItemClick = (itemId: string) => {
  // Clear the hovered item preview immediately when an item is clicked
  hoveredItemId.value = null;

  // Buy the item from the discarded inventory
  gameStore.buyDiscarded(itemId);
};

const handleBuyResults = (data: any) => {
  if (!data || !data.itemId) return;
  
  // Close the computer fullscreen view
  emit('close');
  
  // Put the item in the player's hands
  gameStore.emitEvent('item-pickup', {
    id: data.itemId
  });
};

let buyResultsListenerId: string;

const handleItemMouseEnter = (itemId: string, event: MouseEvent) => {
  hoveredItemId.value = itemId;
  const target = event.currentTarget as HTMLElement;
  if (target) {
    const rect = target.getBoundingClientRect();
    hoveredItemPosition.value = {
      x: rect.left + rect.width / 2,
      y: rect.top - 10
    };
  }
};

const handleItemMouseLeave = () => {
  hoveredItemId.value = null;
};

// Use the escape key handler
const { handleKeyDown } = useEscapeKeyHandler('computer-fullscreen', (event) => {
  if (event.key === 'Escape' && props.show) {
    emit('close');
    return true;
  }
  return false;
});

onMounted(() => {
  buyResultsListenerId = gameStore.addEventListener('buy-results', handleBuyResults);
  
  // Watch for show prop changes to manage focus
  watch(() => props.show, (newValue) => {
    if (newValue) {
      gameStore.pushFocus('computer-fullscreen');
    } else {
      gameStore.popFocus();
    }
  });
});

onUnmounted(() => {
  gameStore.removeEventListener('buy-results', buyResultsListenerId);
  // No need to clean up escape key listeners as useEscapeKeyHandler handles that
});

const handleReset = () => {
  // Emit peek-discarded event to fetch 21 items
  gameStore.peekDiscarded(21);
};
</script>

<template>
  <div v-if="show" class="fullscreen-overlay">
    <div class="computer-container" :style="{ backgroundImage: `url(${computerImage})` }">
      <button class="close-button" @click="$emit('close')">Back</button>
      
      <!-- Item Preview Component -->
      <BuyPreview 
        :item="hoveredItem"
        position="fixed"
        :style="{
          left: hoveredItemPosition.x + 'px',
          top: hoveredItemPosition.y + 'px',
          transform: 'translateX(-50%)'
        }"
      />
      <div v-if="hoveredItem" 
        class="item-tooltip"
        :class="getRarityClass(hoveredItem.value)"
        :style="{
          left: hoveredItemPosition.x + 'px',
          top: (hoveredItemPosition.y - 30) + 'px',
          transform: 'translateX(-50%)'
        }"
      >
        {{ hoveredItem.name }}
      </div>
      
      <div class="inventory-area">
        <div class="crt-wrapper">
          <div class="inventory-grid">
            <div 
              class="inventory-slot" 
              :class="{ 'has-item': item }" 
              v-for="item in mappedItems" 
              :key="item.id"
              @click="item && handleItemClick(item.id)"
              @mouseenter="(event) => item && handleItemMouseEnter(item.id, event)"
              @mouseleave="handleItemMouseLeave"
            >
              <div v-if="item" class="item-container" :class="getRarityClass(item.value)">
                <img :src="item.imageUrl" class="item-image" :alt="item.name" />
              </div>
            </div>
            <!-- Add empty slots to fill the grid if needed -->
            <div 
              class="inventory-slot" 
              v-for="n in Math.max(0, 21 - mappedItems.length)" 
              :key='n'
            ></div>
          </div>
        </div>
      </div>
      <button class="reset-button" @click="handleReset">RESET</button>
    </div>
  </div>
</template>

<style scoped>
.fullscreen-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.computer-container {
  position: relative;
  width: min(90vh, 90vw); /* Use the smaller of viewport width or height */
  height: min(90vh, 90vw); /* Match width to maintain square ratio */
  max-width: min(90vh, 1200px);
  max-height: min(90vh, 1200px);
  margin: auto;
  background-size: contain;
  background-position: center;
  background-repeat: no-repeat;
  display: flex;
  justify-content: center;
  align-items: center;
}

.close-button {
  position: absolute;
  top: 5%;
  left: 0px;
  margin-right: 5%;
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  height: 50px;
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: 10%;
  transition: background-color 0.3s;
  padding: 1%;
  z-index: 20;
}

.close-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.inventory-area {
  position: absolute;
  width: 62.5%;
  height: 31%;
  top: 26.25%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
}

.crt-wrapper {
  width: 100%;
  height: 100%;
  padding: 6% 5%;
  border-radius: 7%;
  position: relative;
  overflow: hidden;
}

.crt-wrapper::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    to bottom,
    transparent 50%,
    rgba(0, 0, 0, 0.1) 50%
  );
  background-size: 100% 4px;
  pointer-events: none;
  z-index: 11;
}

.crt-wrapper::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    to right,
    rgba(0, 0, 0, 0.1) 0%,
    transparent 50%,
    rgba(0, 0, 0, 0.1) 100%
  );
  background-size: 4px 100%;
  pointer-events: none;
  z-index: 11;
}

.crt-wrapper::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(
    circle at center,
    transparent 0%,
    rgba(0, 0, 0, 0.2) 100%
  );
  pointer-events: none;
  z-index: 12;
}

.inventory-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 10px;
  width: 100%;
  height: 100%;
  filter: grayscale(100%);
}

.inventory-slot {
  background: transparent;
  border: 3px dashed rgb(113, 67, 31);
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: rgba(255, 255, 255, 0.5);
  font-size: 0.9em;
  transition: border-color 0.3s, background-color 0.3s;
  position: relative;
}

.inventory-slot.has-item {
  border: none;
}

.inventory-slot.has-item:hover .item-container {
  transform: scale(1.05);
  cursor: pointer;
  filter: grayscale(100%);
}

.inventory-slot:hover {
  border-color: rgb(173, 127, 91);
  background-color: rgba(113, 67, 31, 0.2);
}

.item-container {
  filter: grayscale(100%);
}

.reset-button {
  position: absolute;
  bottom: 16.5%;
  left: 26%;
  transform: translateX(-50%);
  background: #ff3333;
  color: white;
  border: none;
  padding: 15px 40px;
  font-size: 1.2em;
  font-weight: bold;
  text-transform: uppercase;
  border-radius: 8px;
  cursor: pointer;
  box-shadow: 
    0 6px 0 #cc0000,
    0 8px 10px rgba(0, 0, 0, 0.3);
  transition: all 0.1s ease;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
  letter-spacing: 2px;
}

.reset-button:hover {
  transform: translateX(-50%) translateY(2px);
  box-shadow: 
    0 4px 0 #cc0000,
    0 6px 8px rgba(0, 0, 0, 0.3);
}

.reset-button:active {
  transform: translateX(-50%) translateY(6px);
  box-shadow: 
    0 0 0 #cc0000,
    0 2px 4px rgba(0, 0, 0, 0.3);
}

.item-tooltip {
  position: fixed;
  background-color: rgba(40, 40, 40, 0.8);
  border-radius: 12px;
  padding: 4px 12px;
  color: white;
  font-size: 0.9em;
  font-weight: bold;
  white-space: nowrap;
  z-index: 30;
  pointer-events: none;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.item-tooltip.item-uncommon {
  color: #4caf50;
}

.item-tooltip.item-rare {
  color: #2196f3;
}

.item-tooltip.item-epic {
  color: #9c27b0;
}

.item-tooltip.item-legendary {
  color: #ff9800;
}
</style> 


================================================
FILE: client/src/components/DiscardDialog.vue
================================================
<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch } from 'vue';
import { useGameStore } from '../stores/game';
import { useEscapeKeyHandler } from '../composables/useEscapeKeyHandler';

const store = useGameStore();

// State to track dialog visibility and current item
const visible = ref(false);
const currentItem = ref<any>(null);

// Computed properties for the dialog
const imageUrl = computed(() => currentItem.value?.imageUrl || '/src/assets/generic.png');

function closeDialog() {
  visible.value = false;
  currentItem.value = null;
}

function discardItem() {
  if (currentItem.value && currentItem.value.id) {
    // Call the discardItem method in the store
    store.discardItem(currentItem.value.id);
  }
  closeDialog();
}

// Use the focus management composable
const { handleKeyDown } = useEscapeKeyHandler('discard-dialog', (event) => {
  if (event.key === 'Escape' && visible.value) {
    closeDialog();
    return true;
  }
  return false;
});

// Listen for intent-to-discard-item events
let discardItemListenerId: string;

onMounted(() => {
  discardItemListenerId = store.addEventListener('intent-to-discard-item', (data) => {
    if (data && data.id) {
      // Get the item data using useItem
      const itemData = store.useItem(data.id).value;
      if (itemData) {
        currentItem.value = itemData;
        visible.value = true;
      }
    }
  });
});

onUnmounted(() => {
  store.removeEventListener('intent-to-discard-item', discardItemListenerId);
});

// Watch for changes to visible prop to manage focus
watch(() => visible.value, (newValue) => {
  if (newValue) {
    store.pushFocus('discard-dialog');
  } else {
    store.popFocus();
  }
});
</script>

<template>
  <div v-if="visible" class="discard-dialog-overlay">
    <div class="discard-dialog">
      <div class="dialog-header">
        <h2>You consider whether to discard this item:</h2>
        <button class="close-button" @click="closeDialog">×</button>
      </div>
      <div class="dialog-content">
        <div class="dialog-image-container">
          <img :src="imageUrl" alt="Item" class="dialog-image" />
        </div>
        <div class="dialog-details">
          <h3>{{ currentItem?.name || 'Unknown Item' }}</h3>
          <p class="item-description">{{ currentItem?.description || 'No description available.' }}</p>
        </div>
      </div>
      <div class="dialog-footer">
        <button class="cancel-button" @click="closeDialog">Cancel</button>
        <button class="discard-button" @click="discardItem">Discard</button>
      </div>
    </div>
  </div>
</template>

<style scoped>
/* Dialog Styles */
.discard-dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.discard-dialog {
  background-color: #1a1a1a;
  border-radius: 8px;
  width: 90%;
  max-width: 600px;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
  border: 2px solid #333;
}

.dialog-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 20px;
  border-bottom: 1px solid #333;
}

.dialog-header h2 {
  margin: 0;
  font-size: 1.3rem;
  color: white;
}

.close-button {
  background: none;
  border: none;
  color: #aaa;
  font-size: 1.8rem;
  cursor: pointer;
  padding: 0;
  line-height: 1;
}

.close-button:hover {
  color: white;
}

.dialog-content {
  padding: 20px;
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  gap: 20px;
}

.dialog-image-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 30%;
  min-width: 120px;
  max-width: 200px;
}

.dialog-image {
  width: 100%;
  max-height: 200px;
  object-fit: contain;
}

.dialog-details {
  color: #ddd;
  width: 70%;
  flex-grow: 1;
}

.dialog-details h3 {
  margin-top: 0;
  margin-bottom: 10px;
  color: white;
}

.item-description {
  margin-bottom: 15px;
  line-height: 1.5;
}

.dialog-footer {
  padding: 15px 20px;
  border-top: 1px solid #333;
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

.cancel-button, .discard-button {
  padding: 8px 16px;
  border-radius: 4px;
  font-weight: bold;
  cursor: pointer;
  transition: background-color 0.2s;
}

.cancel-button {
  background-color: #424242;
  color: white;
  border: none;
}

.cancel-button:hover {
  background-color: #616161;
}

.discard-button {
  background-color: #f44336;
  color: white;
  border: none;
}

.discard-button:hover {
  background-color: #d32f2f;
}
</style>


================================================
FILE: client/src/components/Dispenser.vue
================================================

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import dispenserImage from '../assets/chute.png';
import panel from '../assets/panel-background.png';
import { useGameStore } from '../stores/game';
import GameItem from './GameItem.vue';

const props = defineProps<{
  id: string,
  row: number;
  col: number;
  tileSize: number;
  width: number;
  depth: number;
  height: number;
  playerIsNear: boolean;
}>();

const isPulling = ref(false);
const isShaking = ref(false);
const gameStore = useGameStore();

// Progress bar variables
const showProgressBar = ref(false);
const progress = ref(0);
let progressInterval: number | null = null;

// Function to animate the progress over 20 seconds
function startProgressAnimation() {
  // Reset progress
  progress.value = 0;
  showProgressBar.value = true;
  
  // Clear any existing interval
  if (progressInterval) {
    clearInterval(progressInterval);
  }
  
  // Set up the interval to update progress
  // 20 seconds = 20000ms
  // We'll update every 100ms, so 20000/100 = 200 steps
  // Each step increases progress by 0.5%
  progressInterval = setInterval(() => {
    progress.value += 0.5;
    
    // If we've reached 100%, clear the interval
    if (progress.value >= 100) {
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
    }
  }, 100);
}

function handleLeverPulled() {
  // Start shaking when lever is pulled
  isShaking.value = true;
  
  // Start the progress animation
  startProgressAnimation();
}

function spawnItemGameObject(data: any) {
  // Check if the item has a story (newly generated) or not (from inventory)
  const isFromInventory = data && data.item && !data.story;
  
  if (data && data.story) {
    gameStore.emitEvent('announce', {
      message: data.story,
      duration: 10000
    });
  }

  // First, add the received item to the game store
  if (data && data.item) {    
    // Extract the itemId from the event data
    const itemId = data.item.id;
    
    // Position it slightly offset from the dispenser
    const itemRow = props.row + props.depth + 2;
    const itemCol = props.col + props.width / 2 + .5;
    const itemHeight = 1.5;
    
    // Add a new game object for the pulled item
    gameStore.addObject({
      id: itemId,
      type: GameItem,
      row: itemRow,
      col: itemCol,
      interactive: true,
      width: 1,
      depth: 1,
      height: 1,
      props: { 
        itemId,
        pickedUp: isFromInventory // Set pickedUp flag to true for items from inventory, false for newly generated items
      },
      physics: {
        active: true,
        angle: Math.floor(Math.random() * (100 - 80 + 1)) + 80,
        velocity: 10,
        friction: 2,
        height: itemHeight,
        verticalVelocity: -1,
        bounceStrength: 0.4,
        mass: 1.0 // Default mass of 1.0
      }
    });
  }
  
  // Stop the shake animation after the item is spawned
  isShaking.value = false;
  
  // Hide the progress bar when the item is spawned
  showProgressBar.value = false;
  
  // Clear any existing interval
  if (progressInterval) {
    clearInterval(progressInterval);
    progressInterval = null;
  }
}

let leverPulledListenerId: string;
let pulledItemListenerId: string;

onMounted(() => {
  leverPulledListenerId = gameStore.addEventListener('lever-pulled', handleLeverPulled);
  pulledItemListenerId = gameStore.addEventListener('pulled-item', spawnItemGameObject);
});

onUnmounted(() => {
  gameStore.removeEventListener('lever-pulled', leverPulledListenerId);
  gameStore.removeEventListener('pulled-item', pulledItemListenerId);
  
  // Clean up interval if component is unmounted
  if (progressInterval) {
    clearInterval(progressInterval);
    progressInterval = null;
  }
});
</script>

<template>
  <div :style="{
    position: 'absolute',
    top: `${row * tileSize}px`,
    left: `${col * tileSize}px`,
    width: `${width * tileSize}px`,
    height: `${depth * tileSize}px`,
    border: gameStore.debug ? '1px solid red': 'none'
  }">
    <div v-if="playerIsNear && !isPulling" class="interact-prompt">E</div>
    <img 
      :src="panel" 
      :style="{
        position: 'absolute',
        width: `${(width + 2) * (tileSize)}px`,
        top: `${-tileSize * 1.5}px`,
        left: `${-tileSize * .4}px`
      }"
    />
    <!-- Progress bar -->
    <div v-if="showProgressBar" class="progress-bar-container" :style="{
      position: 'absolute',
      top: `${-tileSize * 1.2}px`,
      left: `${tileSize * .1}px`,
      width: `${width * tileSize * .9}px`,
      zIndex: 10
    }">
      <div class="progress-bar-background">
        <div class="progress-bar-fill" :style="{ width: `${progress}%` }"></div>
      </div>
    </div>
    <img 
      :src="dispenserImage" 
      :width="width * tileSize" 
      :height="4 * tileSize"
      :style="{
        position: 'absolute',
        top: `${-tileSize}px`
      }"
      :class="['dispenser', { 'dispenser-active': playerIsNear, 'dispenser-pulling': isPulling, 'dispenser-shaking': isShaking }]"
      alt="Dispenser"
    />
    <!-- Height visualization line (only visible in debug mode) -->
    <div v-if="gameStore.debug" class="height-line" :style="{
      position: 'absolute',
      left: '0',
      bottom: '0',
      width: '2px',
      height: `${height * tileSize}px`,
      backgroundColor: 'blue',
      zIndex: 1000
    }" />
  </div>
</template>

<style scoped>
.dispenser {
  filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.5));
  object-fit: contain;
  transition: filter 0.3s ease;
}

.dispenser-shaking {
  animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) infinite;
  transform-origin: top center;
}

@keyframes shake {
  0%, 100% { transform: rotate(0deg); }
  10%, 30%, 50%, 70%, 90% { transform: rotate(-2deg); }
  20%, 40%, 60%, 80% { transform: rotate(2deg); }
}

/* Progress bar styles */
.progress-bar-container {
  display: flex;
  justify-content: center;
  align-items: center;
}

.progress-bar-background {
  width: 100%;
  height: 8px;
  background-color: rgba(0, 0, 0, 0.5);
  border-radius: 4px;
  overflow: hidden;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.progress-bar-fill {
  height: 100%;
  background-color: #4CAF50; /* Green color */
  border-radius: 4px;
  transition: width 0.1s linear;
}
</style>



================================================
FILE: client/src/components/GameGrid.vue
================================================
<script setup lang="ts">
import { computed } from 'vue';
import { useGameStore } from '../stores/game';

interface Props {
  gridSize?: number;
}

const props = withDefaults(defineProps<Props>(), {
  gridSize: 30
});

const gameStore = useGameStore();
const totalWidth = computed(() => props.gridSize * gameStore.tileSize);
const totalHeight = computed(() => props.gridSize * gameStore.tileSize);
</script>

<template>
  <div class="game-grid" :style="{ width: `${totalWidth}px`, height: `${totalHeight}px` }">
    <svg :width="totalWidth" :height="totalHeight" v-if="gameStore.debug" style="z-index: 100;">
      <template v-for="row in gridSize" :key="row">
        <template v-for="col in gridSize" :key="`${row}-${col}`">
          <rect 
            :x="(col - 1) * gameStore.tileSize" 
            :y="(row - 1) * gameStore.tileSize" 
            :width="gameStore.tileSize" 
            :height="gameStore.tileSize" 
            fill="transparent"
            stroke="#ccc" 
            stroke-width="1" 
          />
        </template>
      </template>
    </svg>
  </div>
</template>

<style scoped>
.game-grid {
  position: absolute;
  top: 0;
  left: 0;
  background-image: url('../assets/background.png');
  background-size: cover;
}
</style>


================================================
FILE: client/src/components/GameItem.vue
================================================
<script setup lang="ts">
import { type PhysicsProperties } from '../utils/physics';
import { onMounted, onUnmounted, computed } from 'vue';
import { useGameStore } from '../stores/game';
import { getRarityClass } from '../utils/items';

const store = useGameStore();

interface Props {
  id: string;
  row: number;
  col: number;
  tileSize: number;
  width: number;
  height: number;
  depth: number;
  playerIsNear: boolean;
  physics?: PhysicsProperties;
  props: {
    itemId: string; // Now we only pass the itemId
    pickedUp: boolean; // Whether the item has been picked up before
  };
}

const props = defineProps<Props>();

// Get the item details using useItem
const item = computed(() => store.useItem(props.props.itemId).value);

// No dialog state needed anymore

// Use the item's imageUrl if available, otherwise use generic.png
const icon = computed(() => item.value?.imageUrl || '/src/assets/generic.png');

// Use the shared utility function for rarity class
const rarityClass = computed(() => {
  if (!item.value || item.value.value === undefined) return getRarityClass();
  return getRarityClass(item.value.value);
});

// Calculate shadow opacity based on item height
const shadowOpacity = computed(() => {
  const height = props.physics?.height || 0;
  // Linear decrease from 0.3 to 0 as height increases from 0 to 4
  return Math.max(0, 0.3 * (1 - height / 4));
});

function handlePlayerInteraction() {
  if (!props.playerIsNear || !item.value) {
    return;
  }

  // If the item hasn't been picked up yet, emit inspect-item event
  if (!props.props.pickedUp) {
    store.emitEvent('inspect-item', {
      id: props.props.itemId
    });
  }

  // Remove the item from the game world so it no longer renders
  // but we will keep it inside of the item list, so that the
  // player can pick it up.
  store.removeObject(props.id);

  // Emit item pickup events. The PlayerCharacter component subscribes
  // to this event.
  store.emitEvent('item-pickup', {
    id: props.props.itemId
  });
}

let interactionListenerId: string;

onMounted(() => {
  interactionListenerId = store.addEventListener('player-interaction', handlePlayerInteraction);
});

onUnmounted(() => {
  store.removeEventListener('player-interaction', interactionListenerId);
});
</script>

<template>
  <div 
    class="game-item"
    :style="{
      position: 'absolute',
      top: `${row * tileSize - ((physics?.height || 0) * tileSize)}px`,
      left: `${col * tileSize}px`,
      width: `${tileSize * width}px`,
      height: `${tileSize * depth}px`,
      transform: `scale(${1 + ((physics?.height || 0) * .1)})`,
      transition: 'transform 0.1s ease-out',
      border: store.debug ? '1px solid red': 'none'
    }"
  >
    <!-- Ground tile outline (always visible in debug mode) -->
    <div v-if="store.debug" 
         :style="{
           position: 'absolute',
           top: `${(physics?.height || 0) * tileSize}px`,
           left: '0',
           width: `${tileSize * width}px`,
           height: `${tileSize * depth}px`,
           border: '1px solid red',
           zIndex: 999
         }">
    </div>
    <!-- Debug information display -->
    <div v-if="store.debug && physics" 
         class="debug-info"
         :style="{
           position: 'absolute',
           top: '-30px',
           left: '0',
           color: 'white',
           backgroundColor: 'rgba(0, 0, 0, 0.7)',
           padding: '2px 4px',
           fontSize: '10px',
           zIndex: 1000,
           display: 'flex',
           gap: '4px'
         }">
      <span>H:{{ physics.height.toFixed(1) }}</span>
      <span>V:{{ physics.velocity.toFixed(1) }}</span>
      <span>VV:{{ physics.verticalVelocity?.toFixed(1) || '0.0' }}</span>
    </div>
    <div v-if="store.debug && physics?.active" 
         class="debug-vector"
         :style="{
           transform: `rotate(${physics.angle}deg)`,
           width: `${physics.velocity * tileSize}px`
         }">
    </div>
    <!-- Height visualization line (only visible in debug mode) -->
    <div v-if="store.debug" 
         class="height-line"
         :style="{
           position: 'absolute',
           left: '0',
           bottom: '0',
           width: '2px',
           height: `${height * tileSize}px`,
           backgroundColor: 'blue',
           zIndex: 1000
         }">
    </div>
    <!-- Drop shadow under item at ground level -->
    <div
      class="item-shadow"
      :style="{
        position: 'absolute',
        bottom: `-${(physics?.height || 0) * tileSize + (tileSize * 0.2)}px`,
        left: '50%',
        transform: 'translateX(-50%)',
        width: `${tileSize * width * 0.7}px`,
        height: `${tileSize * depth * 0.2}px`,
        backgroundColor: `rgba(0, 0, 0, ${shadowOpacity})`,
        borderRadius: '50%',
        filter: 'blur(3px)',
        zIndex: -1
      }"
    ></div>
    <div class="item-container" :class="[{ 'item-near': playerIsNear }, rarityClass]">
      <div v-if="playerIsNear" class="interact-prompt">E</div>
      <img :src="icon" alt="Item" class="item-image" />
    </div>
    <!--<div class="item-name" :class="getRarityClass">{{ item?.name || 'Unknown Item' }}</div>-->
  </div>
  

</template>

<style scoped>
.game-item {
  pointer-events: none;
}

.item-near .item-image {
  transform: scale(1.1);
  box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
}

.debug-vector {
  position: absolute;
  top: 50%;
  left: 50%;
  height: 2px;
  background-color: orange;
  transform-origin: left center;
  z-index: 1000;
}

.ground-tile-outline {
  pointer-events: none;
  box-sizing: border-box;
  background-color: rgba(255, 0, 0, 0.1);
}

.interact-prompt {
  position: absolute;
  top: -40px;
  left: 50%;
  transform: translateX(-50%);
  font-size: calc(0.5 * v-bind(tileSize))px;
  font-weight: bold;
  color: white;
  text-shadow: 0 0 5px white;
  background-color: black;
  padding: 5px 10px;
  border-radius: 4px;
}
</style>


================================================
FILE: client/src/components/GameObjects.vue
================================================

<template>
  <div class="game-objects">
    <template v-for="obj in sortedGameObjects" :key="obj.id">
      <component :is="obj.type" 
        :id="obj.id"
        :col="(obj.col - 1)" 
        :row="(obj.row - 1)" 
        :tileSize="tileSize"
        :width="obj.width || 1"
        :depth="obj.depth || 1"
        :height="obj.height || 1"
        :playerIsNear="obj.playerIsNear"
        :physics="obj.physics"
        :props="obj.props" />
    </template>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import type { GameObject } from '@/systems/game-object-system';

interface Props {
  gameObjects: GameObject[];
  tileSize: number;
}

const props = defineProps<Props>();

const sortedGameObjects = computed(() => {
  return [...props.gameObjects].sort((a, b) => {
    // Sort from back to front (top to bottom, left to right)
    return (a.row) - (b.row);
  });
});
</script>

<style>
.game-objects {
  position: absolute;
  top: 0;
  left: 0;
}
</style>



================================================
FILE: client/src/components/Garbage.vue
================================================
<script setup lang="ts">
import garbageImage from '../assets/garbage.png';
import { useGameStore } from '../stores/game';
import { ref, onMounted, onUnmounted } from 'vue';
import { storeToRefs } from 'pinia'

const props = defineProps<{
  row: number;
  col: number;
  tileSize: number;
  width: number;
  depth: number;
  height: number;
  playerIsNear: boolean;
}>();

const gameStore = useGameStore();
const { heldItemId } = storeToRefs(gameStore);
let interactionListenerId: string;

// Function to handle player interaction with the garbage can
const interaction = () => {
  if (!props.playerIsNear) {
    return;
  }

  if (!heldItemId.value) {
    // Nothing held
    return;
  }

  // Emit intent-to-discard-item event with the held item ID
  gameStore.emitEvent('intent-to-discard-item', {
    id: heldItemId.value
  });
};

onMounted(() => {
  interactionListenerId = gameStore.addEventListener('player-interaction', interaction);
});

onUnmounted(() => {
  // Clean up event listener
  gameStore.removeEventListener('intent-to-discard-item', interactionListenerId);
});
</script>

<template>
  <div :style="{
    position: 'absolute',
    top: `${row * tileSize}px`,
    left: `${col * tileSize}px`,
    width: `${width * tileSize}px`,
    height: `${depth * tileSize}px`,
    border: gameStore.debug ? '1px solid red': 'none'
  }">
    <div v-if="playerIsNear" class="interact-prompt">E</div>
    <img 
      :src="garbageImage" 
      :width="width * tileSize" 
      :style="{
        position: 'absolute',
        top: `-${tileSize * 1}px`
      }"
      :class="['garbage', { 'garbage-active': playerIsNear }]"
      alt="Garbage"
    />
    <!-- Height visualization line (only visible in debug mode) -->
    <div v-if="gameStore.debug" class="height-line" :style="{
      position: 'absolute',
      left: '0',
      bottom: '0',
      width: '2px',
      height: `${height * tileSize}px`,
      backgroundColor: 'blue',
      zIndex: 1000
    }" />
  </div>
</template>

<style scoped>
.garbage {
  filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.5));
  object-fit: contain;
  transition: filter 0.3s ease;
}

.garbage-active {
  filter: drop-shadow(0 0 15px white);
}

.interact-prompt {
  position: absolute;
  top: calc(-.3 * v-bind(tileSize) * 1px);
  left: calc(2 * v-bind(tileSize) * 1px);
  font-size: calc(0.5 * v-bind(tileSize) * 1px);
  font-weight: bold;
  color: white;
  text-shadow: 0 0 5px white;
  animation: pulse 1s infinite;
  background-color: black;
  padding: calc(0.1 * v-bind(tileSize) * 1px) calc(0.1 * v-bind(tileSize) * 1px);
  border-radius: calc(0.08 * v-bind(tileSize) * 1px);
  z-index: 1;
  line-height: 1;
}

@keyframes pulse {
  0% { opacity: 0.5; }
  50% { opacity: 1; }
  100% { opacity: 0.5; }
}
</style>


================================================
FILE: client/src/components/HintDisplay.vue
================================================
<template>
  <div 
    class="hint-display" 
    :class="{ 'hint-visible': isVisible }"
    v-html="currentHint"
  >
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import { useGameStore } from '../stores/game';

const gameStore = useGameStore();
const currentHint = ref('');
const isVisible = ref(false);
let hideTimeout: number | null = null;

const showHint = (hint: string, duration?: number) => {
  // Clear any existing timeout
  if (hideTimeout) {
    clearTimeout(hideTimeout);
    hideTimeout = null;
  }
  
  // Show new hint
  currentHint.value = hint;
  isVisible.value = true;
  
  // Set timeout to hide hint if duration is provided
  if (duration) {
    hideTimeout = setTimeout(() => {
      isVisible.value = false;
      currentHint.value = '';
    }, duration);
  }
};

const clearHint = () => {
  if (hideTimeout) {
    clearTimeout(hideTimeout);
    hideTimeout = null;
  }
  isVisible.value = false;
  currentHint.value = '';
};

// Set up event listeners
let hintListenerId: string;
let clearHintListenerId: string;

onMounted(() => {
  hintListenerId = gameStore.addEventListener('hint', (data) => {
    if (data && typeof data.message === 'string') {
      showHint(data.message, data.duration);
    }
  });
  
  clearHintListenerId = gameStore.addEventListener('clear-hint', () => {
    clearHint();
  });
});

onUnmounted(() => {
  if (hideTimeout) {
    clearTimeout(hideTimeout);
  }
  gameStore.removeEventListener('hint', hintListenerId);
  gameStore.removeEventListener('clear-hint', clearHintListenerId);
});
</script>

<style scoped>
.hint-display {
  position: absolute;
  bottom: 20px;
  right: 20px;
  background-color: rgba(40, 40, 40, 0.8);
  color: white;
  padding: 10px 20px;
  border-radius: 12px;
  max-width: 300px;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
  z-index: 1000;
  text-align: left;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.hint-visible {
  opacity: 1;
}
</style>


================================================
FILE: client/src/components/HUD.vue
================================================
<template>
  <div class="hud">
    <div class="hud-bubble">
      <div class="gold-display">
        <div class="gold-icon"></div>
        <span class="gold-amount">{{ gold }}</span>
      </div>
      <div v-if="goldChange" class="gold-change" :class="{ 'positive': goldChange > 0, 'negative': goldChange < 0 }">
        {{ goldChange > 0 ? '+' : '' }}{{ goldChange }}
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useGameStore } from '../stores/game'
import { computed, ref, watch } from 'vue'

const gameStore = useGameStore()
const persona = gameStore.usePersona()
const previousGold = ref(0)
const goldChange = ref(0)

const gold = computed(() => {
  return persona.value.gold || '0'
})

// Watch for gold changes and animate the difference
watch(gold, (newValue, oldValue) => {
  const newGold = parseInt(newValue || '0')
  const oldGold = parseInt(oldValue || '0')
  if (!isNaN(newGold) && !isNaN(oldGold)) {
    goldChange.value = newGold - oldGold
    // Clear the change after animation
    setTimeout(() => {
      goldChange.value = 0
    }, 2000)
  }
  previousGold.value = newGold
}, { immediate: true })
</script>

<style scoped>
.hud {
  position: absolute;
  top: 20px;
  right: 20px;
  z-index: 1000;
}

.hud-bubble {
  background-color: rgba(40, 40, 40, 0.8);
  border-radius: 12px;
  padding: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.gold-display {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 12px;
  color: white;
  font-weight: bold;
}

.gold-amount {
  font-size: 1.1em;
}

.gold-change {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  font-size: 0.9em;
  font-weight: bold;
  padding: 2px 8px;
  border-radius: 8px;
  animation: fadeUp 2s ease-out forwards;
  white-space: nowrap;
}

.gold-change.positive {
  color: #4caf50;
  background-color: rgba(76, 175, 80, 0.2);
}

.gold-change.negative {
  color: #f44336;
  background-color: rgba(244, 67, 54, 0.2);
}

@keyframes fadeUp {
  0% {
    opacity: 0;
    transform: translate(-50%, 0);
  }
  20% {
    opacity: 1;
    transform: translate(-50%, -10px);
  }
  80% {
    opacity: 1;
    transform: translate(-50%, -10px);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -20px);
  }
}
</style> 


================================================
FILE: client/src/components/ItemDialog.vue
================================================
<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch } from 'vue';
import { useGameStore } from '../stores/game';
import { getRarityClass } from '../utils/items';
import { useEscapeKeyHandler } from '../composables/useEscapeKeyHandler';

const store = useGameStore();

// State to track dialog visibility and current item ID
const visible = ref(false);
const currentItemId = ref<string>();

// Computed property for the current item
const currentItem = computed(() => {
  if (!currentItemId.value) return undefined;
  return store.useItem(currentItemId.value).value;
});

// Computed properties for the dialog
const imageUrl = computed(() => currentItem.value?.imageUrl || '/src/assets/generic.png');

// Determine CSS class based on item value
const rarityClass = computed(() => {
  if (!currentItem.value || currentItem.value.value === undefined) return 'item-common';
  return getRarityClass(currentItem.value.value);
});

// Format rarity text for display
const rarityText = computed(() => {
  if (!rarityClass.value) return 'Common';
  return rarityClass.value.replace('item-', '').charAt(0).toUpperCase() + rarityClass.value.replace('item-', '').slice(1);
});

function closeDialog() {
  visible.value = false;
}

// Use the focus management composable
const { handleKeyDown } = useEscapeKeyHandler('item-dialog', (event) => {
  if (event.key === 'Escape' && visible.value) {
    closeDialog();
    return true;
  }
  return false;
});

// Listen for inspect-item events
let inspectItemListenerId: string;

onMounted(() => {
  inspectItemListenerId = store.addEventListener('inspect-item', (data) => {
    console.log('inspect-item data', data)
    if (data && data.id) {
      currentItemId.value = data.id;
      visible.value = true;
    }
  });
});

onUnmounted(() => {
  store.removeEventListener('inspect-item', inspectItemListenerId);
});

// Watch for changes to visible prop to manage focus
watch(() => visible.value, (newValue) => {
  if (newValue) {
    store.pushFocus('item-dialog');
  } else {
    store.popFocus();
  }
});
</script>

<template>
  <div v-if="visible && currentItem" class="item-dialog-overlay">
    <div class="item-dialog" :class="rarityClass">
      <div class="dialog-header">
        <h3>{{ currentItem?.name || 'Unknown Item' }}</h3>
        <button class="close-button" @click="closeDialog">×</button>
      </div>
      <div class="dialog-content">
        <div class="dialog-image-container">
          <img :src="imageUrl" alt="Item" class="dialog-image" />
          <div class="tags-container">
            <span class="tag item-rarity" :class="rarityClass">
              {{ rarityText }}
            </span>
            <span class="tag stat-tag gold-display">
              <div class="gold-icon"></div>
              <span class="gold-amount">{{ currentItem.value }}</span>
            </span>
            <span class="tag stat-tag">
              {{ currentItem.weight }}
            </span>
            <span v-for="(material, idx) in currentItem.materials" :key="idx" class="tag stat-tag">
              {{ material }}
            </span>
            <span class="tag stat-tag">
              {{ currentItem.damage }}
            </span>
          </div>
        </div>
        <div class="dialog-details">
          <p class="item-description">{{ currentItem?.description || 'No description available.' }}</p>
          
          <div class="item-skills">
            <h4>Quirks:</h4>
            <div v-for="(skill, index) in currentItem.skills" :key="index" class="skill-item">
              <div class="skill-header">
                <div class="skill-name">{{ skill.name }}</div>
                <div class="skill-targets">
                  <span class="target-tag">
                    {{ typeof skill.targets === 'number' && skill.targets >= 0 && skill.targets <= 2 ? (skill.targets === 0
                      ? 'Self' : skill.targets === 1 ? '1 Target' : '2 Targets') : 'Self' }}
                  </span>
                </div>
              </div>
              <div class="skill-description">{{ skill.description }}</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
/* Dialog Overlay */
.item-dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

/* Dialog Container */
.item-dialog {
  background-color: #1a1a1a;
  border-radius: 8px;
  width: 90%;
  max-width: 650px;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
  border: 2px solid #333;
}

.item-dialog.item-uncommon {
  border-color: #4caf50;
  box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
}

.item-dialog.item-rare {
  border-color: #2196f3;
  box-shadow: 0 0 20px rgba(33, 150, 243, 0.3);
}

.item-dialog.item-epic {
  border-color: #9c27b0;
  box-shadow: 0 0 20px rgba(156, 39, 176, 0.3);
}

.item-dialog.item-legendary {
  border-color: #ff9800;
  box-shadow: 0 0 20px rgba(255, 152, 0, 0.5);
  animation: dialog-pulse 2s infinite;
}

@keyframes dialog-pulse {
  0% { box-shadow: 0 0 20px rgba(255, 152, 0, 0.3); }
  50% { box-shadow: 0 0 30px rgba(255, 152, 0, 0.6); }
  100% { box-shadow: 0 0 20px rgba(255, 152, 0, 0.3); }
}

/* Dialog Header */
.dialog-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  border-bottom: 1px solid #333;
}

.dialog-header h3 {
  margin: 0;
  font-size: 1.2rem;
  color: white;
}

.close-button {
  background: none;
  border: none;
  color: #aaa;
  font-size: 1.8rem;
  cursor: pointer;
  padding: 0;
  line-height: 1;
}

.close-button:hover {
  color: white;
}

/* Dialog Content */
.dialog-content {
  padding: 15px;
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  gap: 15px;
}

/* Image Container */
.dialog-image-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 25%;
  min-width: 80px;
  max-width: 120px;
}

.dialog-image {
  width: 100%;
  max-height: 120px;
  object-fit: contain;
}

/* Details Container */
.dialog-details {
  color: #ddd;
  width: 75%;
  flex-grow: 1;
}

.item-description {
  margin-bottom: 10px;
  line-height: 1.4;
  font-size: 0.9rem;
}

/* Tags */
.tag {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: bold;
  background-color: rgba(255, 255, 255, 0.15);
  font-size: 0.8rem;
}

.item-rarity {
  text-align: left;
}

.stat-tag {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  font-size: 0.75rem;
  padding: 1px 5px;
  color: white;
  background-color: rgba(255, 255, 255, 0.3);
}

/* Gold display styling from HUD.vue */
.gold-display {
  display: flex;
  align-items: center;
  gap: 8px;
  color: white;
  font-weight: bold;
}

.gold-amount {
  font-size: 1.1em;
}

/* Tags Container */
.tags-container {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  align-items: flex-start;
  justify-content: flex-start;
  margin-top: 8px;
  width: 100%;
}

/* Skill Styles */
.item-skills {
  margin: 8px 0;
}

.item-skills h4 {
  font-size: 0.9rem;
  margin: 0 0 5px 0;
  color: #aaa;
}

.skill-item {
  margin-bottom: 8px;
  padding: 6px;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
  font-size: 0.85rem;
}

.skill-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2px;
  flex-wrap: wrap;
}

.skill-name {
  font-weight: bold;
  color: #ddd;
  font-size: 0.85rem;
}

.skill-description {
  font-size: 0.8rem;
  color: #bbb;
  margin-top: 3px;
}

/* Target Tag */
.target-tag {
  font-size: 0.65rem;
  padding: 1px 4px;
  border-radius: 8px;
  font-weight: bold;
  background-color: #607d8b;
  color: white;
  white-space: nowrap;
}

/* Used to style the item rarity tag */
.item-rarity.item-common {
  color: #ffffff;
  background-color: rgba(255, 255, 255, 0.2);
}

.item-rarity.item-uncommon {
  color: #4caf50;
  background-color: rgba(76, 175, 80, 0.25);
}

.item-rarity.item-rare {
  color: #2196f3;
  background-color: rgba(33, 150, 243, 0.25);
}

.item-rarity.item-epic {
  color: #9c27b0;
  background-color: rgba(156, 39, 176, 0.25);
}

.item-rarity.item-legendary {
  color: #ff9800;
  background-color: rgba(255, 152, 0, 0.25);
  text-shadow: 0 0 3px rgba(255, 152, 0, 0.5);
}
</style>


================================================
FILE: client/src/components/ItemPreview.vue
================================================
<script setup lang="ts">
import { computed } from 'vue';
import { getRarityClass } from '../utils/items';
import type { Item } from '../systems/item-system';

const props = defineProps<{
  item: Item | null;
  // Position configuration props
  position?: string;
  top?: string;
  right?: string;
  bottom?: string;
  left?: string;
  transform?: string;
}>();

// Computed properties for the preview
const imageUrl = computed(() => props.item?.imageUrl || '/src/assets/generic.png');

// Determine CSS class based on item value
const rarityClass = computed(() => {
  if (!props.item || props.item.value === undefined) return 'item-common';
  return getRarityClass(props.item.value);
});

// Format rarity text for display
const rarityText = computed(() => {
  if (!rarityClass.value) return 'Common';
  return rarityClass.value.replace('item-', '').charAt(0).toUpperCase() + rarityClass.value.replace('item-', '').slice(1);
});

// Compute the positioning style based on props without defaults
const positionStyle = computed(() => {
  return {
    position: props.position as 'static' | 'relative' | 'absolute' | 'fixed' | 'sticky' | undefined,
    top: props.top,
    right: props.right,
    bottom: props.bottom,
    left: props.left,
    transform: props.transform
  };
});

// No custom material class needed as we're using the same styling as damage tag
</script>

<template>
  <div v-if="item" class="item-preview" :class="rarityClass" :style="positionStyle">
    <div class="preview-header">
      <h3>{{ item.name || 'Unknown Item' }}</h3>
    </div>
    <div class="preview-content">
      <div class="preview-image-container">
        <img :src="imageUrl" alt="Item" class="preview-image" />
        <div class="tags-container">
          <span class="tag item-rarity" :class="rarityClass">
            {{ rarityText }}
          </span>
          <span v-if="item.value !== undefined" class="tag stat-tag gold-display">
            <div class="gold-icon"></div>
            <span class="gold-amount">{{ item.value }}</span>
          </span>
          <span v-if="item.weight" class="tag stat-tag">
            {{ item.weight }}
          </span>
          <span v-if="item.materials && item.materials.length > 0"
            v-for="(material, idx) in item.materials" :key="idx" class="tag stat-tag">
            {{ material }}
          </span>
          <span v-if="item.damage" class="tag stat-tag">
            {{ item.damage }}
          </span>
        </div>
      </div>
      <div class="preview-details">
        <p class="item-description">{{ item.description || 'No description available.' }}</p>

        <div class="item-skills" v-if="item.skills && item.skills.length > 0">
          <h4>Quirks:</h4>
          <div v-for="(skill, index) in item.skills" :key="index" class="skill-item">
            <div class="skill-header">
              <div class="skill-name">{{ skill.name }}</div>
              <div class="skill-targets">
                <span class="target-tag">
                  {{ typeof skill.targets === 'number' && skill.targets >= 0 && skill.targets <= 2 ? (skill.targets === 0
                    ? 'Self' : skill.targets === 1 ? '1 Target' : '2 Targets') : 'Self' }} </span>
              </div>
            </div>
            <div class="skill-description">{{ skill.description }}</div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.item-preview {
  /* Position is now controlled by the positionStyle computed property */
  background-color: #1a1a1a;
  border-radius: 8px;
  width: 80%;
  max-width: 600px;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
  border: 2px solid #333;
  z-index: 30;
  pointer-events: none;
  /* Allow clicking through the preview */
}

.item-preview.item-uncommon {
  border-color: #4caf50;
  box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
}

.item-preview.item-rare {
  border-color: #2196f3;
  box-shadow: 0 0 20px rgba(33, 150, 243, 0.3);
}

.item-preview.item-epic {
  border-color: #9c27b0;
  box-shadow: 0 0 20px rgba(156, 39, 176, 0.3);
}

.item-preview.item-legendary {
  border-color: #ff9800;
  box-shadow: 0 0 20px rgba(255, 152, 0, 0.5);
}

.preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  border-bottom: 1px solid #333;
}

.preview-header h3 {
  margin: 0;
  font-size: 1.2rem;
  color: white;
}

.preview-content {
  padding: 15px;
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  gap: 15px;
}

.preview-image-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 25%;
  min-width: 80px;
  max-width: 120px;
}

.preview-image {
  width: 100%;
  max-height: 120px;
  object-fit: contain;
}

.preview-details {
  color: #ddd;
  width: 75%;
  flex-grow: 1;
}

.item-description {
  margin-bottom: 10px;
  line-height: 1.4;
  font-size: 0.9rem;
}

.tag {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: bold;
  background-color: rgba(255, 255, 255, 0.15);
  font-size: 0.8rem;
}

.item-rarity {
  text-align: left;
}

.stat-tag {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  font-size: 0.75rem;
  padding: 1px 5px;
  color: white;
  background-color: rgba(255, 255, 255, 0.3);
}

/* Gold display styling from HUD.vue */
.gold-display {
  display: flex;
  align-items: center;
  gap: 8px;
  color: white;
  font-weight: bold;
}

.gold-amount {
  font-size: 1.1em;
}

.tags-container {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  align-items: flex-start;
  justify-content: flex-start;
  margin-top: 8px;
  width: 100%;
}

/* Skill styles */
.item-skills {
  margin: 8px 0;
}

.item-skills h4 {
  font-size: 0.9rem;
  margin: 0 0 5px 0;
  color: #aaa;
}

.skill-item {
  margin-bottom: 8px;
  padding: 6px;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
  font-size: 0.85rem;
}

.skill-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2px;
  flex-wrap: wrap;
}

.skill-name {
  font-weight: bold;
  color: #ddd;
  font-size: 0.85rem;
}

.skill-description {
  font-size: 0.8rem;
  color: #bbb;
  margin-top: 3px;
}

/* Add styles for the target tag */
.target-tag {
  font-size: 0.65rem;
  padding: 1px 4px;
  border-radius: 8px;
  font-weight: bold;
  background-color: #607d8b;
  color: white;
  white-space: nowrap;
}

/* Used to style the item rarity tag */
.item-rarity.item-common {
  color: #ffffff;
  background-color: rgba(255, 255, 255, 0.2);
}

.item-rarity.item-uncommon {
  color: #4caf50;
  background-color: rgba(76, 175, 80, 0.25);
}

.item-rarity.item-rare {
  color: #2196f3;
  background-color: rgba(33, 150, 243, 0.25);
}

.item-rarity.item-epic {
  color: #9c27b0;
  background-color: rgba(156, 39, 176, 0.25);
}

.item-rarity.item-legendary {
  color: #ff9800;
  background-color: rgba(255, 152, 0, 0.25);
  text-shadow: 0 0 3px rgba(255, 152, 0, 0.5);
}

</style>


================================================
FILE: client/src/components/LoadingScreen.vue
================================================
<template>
  <div class="loading-screen" v-if="showLoadingScreen">
    <div class="loading-content">
      <h1>Loading Game Assets</h1>
      <div class="progress-container">
        <div class="progress-bar" :style="{ width: `${progressPercent}%` }"></div>
      </div>
      <div class="progress-text">
        {{ progressPercent }}% Complete
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, watch } from 'vue'
import type { PreloadProgress } from '../systems/preloader-system'

const props = defineProps<{
  progress: PreloadProgress
}>()

const initialLoadComplete = ref(false)

const showLoadingScreen = computed(() => {
  if (initialLoadComplete.value) return false
  return props.progress.pending > 0 || props.progress.failed > 0
})

const progressPercent = computed(() => {
  if (props.progress.total === 0) return 0
  return Math.round((props.progress.loaded / props.progress.total) * 100)
})

// Watch for when loading completes and mark initial load as done
watch(() => props.progress.pending, (newPending) => {
  if (newPending === 0) {
    initialLoadComplete.value = true
  }
})
</script>

<style scoped>
.loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: #000000;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}

.loading-content {
  text-align: center;
  color: white;
  padding: 2rem;
  border-radius: 8px;
  background-color: rgba(0, 0, 0, 0.5);
  min-width: 300px;
}

h1 {
  margin-bottom: 2rem;
  font-size: 1.5rem;
}

.progress-container {
  width: 100%;
  height: 20px;
  background-color: #333;
  border-radius: 10px;
  overflow: hidden;
  margin-bottom: 1rem;
}

.progress-bar {
  height: 100%;
  background-color: #4CAF50;
  transition: width 0.3s ease;
}

.progress-text {
  font-size: 1rem;
  color: #ccc;
}
</style> 


================================================
FILE: client/src/components/PlayerCharacter.vue
================================================
<script setup lang="ts">
import { ref, onMounted, onUnmounted, onBeforeUnmount, computed, watch } from 'vue';
import { type PhysicsProperties } from '../utils/physics';
import GameItem from './GameItem.vue';
import ghostNorth from '../assets/kiro-ghost/north.png';
import ghostEast from '../assets/kiro-ghost/east.png';
import ghostSouth from '../assets/kiro-ghost/south.png';
import ghostSouthwest from '../assets/kiro-ghost/southwest.png';
import { storeToRefs } from 'pinia';
import { getRarityClass } from '../utils/items';

interface Props {
  id: string;
  row: number;
  col: number;
  tileSize: number;
  width: number;
  depth: number;
  height: number;
  playerIsNear: boolean;
  physics?: PhysicsProperties;
  props: any;
}

const MOVEMENT_IMPULSE = 10;
const THROW_IMPULSE = 15; // Stronger impulse for throwing items
const props = defineProps<Props>();

import { useGameStore } from '../stores/game';
const gameStore = useGameStore();
const { heldItemId } = storeToRefs(gameStore);

// Track pressed keys
// Shared state for key tracking
const pressedKeys = ref<Set<string>>(new Set());

// Function to clear all pressed keys
const clearPressedKeys = () => {
  pressedKeys.value.clear();
};

// Use the shared utility function for rarity class
const rarityClass = computed(() => {
  if (!heldItem.value) return getRarityClass();
  return getRarityClass(heldItem.value.value);
});

// Computed property for the held item
const heldItem = computed(() => {
  if (!heldItemId.value) return null;
  return gameStore.useItem(heldItemId.value).value;
});

const handleKeyDown = (e: KeyboardEvent) => {
  if (gameStore.interactionLocked) {
    return;
  }

  const key = e.key.toLowerCase();
  
  if (key === 't') {
    if (heldItemId.value) {
      // If holding an item, throw it
      throwHeldItem();
    }
    return;
  }
  
  if (key === 'e') {
    // Use for interaction only
    clearPressedKeys();
    gameStore.emitEvent('player-interaction');
    return;
  }
  
  if (key === 'i') {
    if (heldItemId.value) {
      // If holding an item, inspect it
      gameStore.emitEvent('inspect-item', {
        id: heldItemId.value
      });
    }
    return;
  }

  if (['w', 'a', 's', 'd'].includes(key)) {
    pressedKeys.value.add(key);
    updateMovement();
  }
};

const handleKeyUp = (e: KeyboardEvent) => {
  if (gameStore.interactionLocked) {
    return;
  }

  const key = e.key.toLowerCase();
  if (['w', 'a', 's', 'd'].includes(key)) {
    pressedKeys.value.delete(key);
    if (pressedKeys.value.size > 0) {
      updateMovement();
    }
  }
};

// Handle item pickup event
const handleItemPickup = (data: any) => {
  if (heldItemId.value) {
    // If holding an item, throw it in order to pick up the new item.
    throwHeldItem();
  }

  console.log(`Pickup item ${data.id}`);
  heldItemId.value = data.id;
};

// Handle item discarded event
const handleItemDiscarded = (data: any) => {
  console.log(`Item discarded: ${data.itemId}`);
  // If the discarded item is the one we're holding, clear it
  if (heldItemId.value === data.itemId) {
    heldItemId.value = null;
  }
};

// Handle drop item event
const handleDropItem = (data: any) => {
  if (!heldItemId.value) return;
  
  // Check if the item ID in the event matches the held item
  if (data.itemId && data.itemId !== heldItemId.value) return;
  
  const item = heldItem.value;
  if (!item) return;

  // Add the item back to the game world at the player's position
  // with minimal velocity and physics settings
  gameStore.addObject({
    id: heldItemId.value,
    type: GameItem,
    row: props.row,
    col: props.col,
    interactive: true,
    width: 1,
    depth: 1,
    props: {
      itemId: heldItemId.value,
      pickedUp: true
    },
    physics: {
      active: true,
      angle: angle.value,
      velocity: 2, // Minimal velocity
      friction: 3,
      height: 1, // Lower height
      verticalVelocity: 0,
      bounceStrength: 0.2,
      mass: 1.0
    }
  });
  
  // Clear the held item
  heldItemId.value = null;
};

// Throw the currently held item
const throwHeldItem = () => {
  if (!heldItemId.value) return;
  
  const item = heldItem.value;
  if (!item) return;

  let throwOffset = 0;
  if (angle.value == 270) {
    throwOffset = 1;  // When throwing an item while facing back, offset it a bit
  }
  
  // Add the item back to the game world at the player's position
  // with the appropriate angle and velocity to seem thrown
  gameStore.addObject({
    id: heldItemId.value,
    type: GameItem,
    row: props.row + throwOffset,
    col: props.col + 1,
    interactive: true,
    width: 1,
    depth: 1,
    props: {
      itemId: heldItemId.value,
      pickedUp: true // Set pickedUp flag to true when throwing a held item
    },
    physics: {
      active: true,
      angle: angle.value,
      velocity: THROW_IMPULSE,
      friction: 2,
      height: 3, // Start a bit above ground
      verticalVelocity: 0,
      bounceStrength: 0.4,
      mass: 1.0
    }
  });
  
  // Clear the held item
  heldItemId.value = null;
};

// Computed property for current sprite
const currentSprite = computed(() => {
  const a = angle.value;
  if (a == 0) {
    return ghostEast;  // West (mirrored)
  } else if (a > 0 && a < 90) {
    return ghostSouthwest; // Southeast (mirrored)
  } else if (a == 90) {
    return ghostSouth;
  } else if (a >= 90 && a < 180) {
    return ghostSouthwest;
  } else if (a == 180) {
    return ghostEast;
  } else if (a > 180 && a < 270) {
    // As an optimization the northwest sprite is
    // a reused northeast sprite that will be mirrored
    return ghostSouthwest; // Northwest (mirrored)
  } else if (a == 270) {
    return ghostNorth;
  } else if (a > 270 && a < 360) {
    return ghostSouthwest; // Northeast
  }
});

const transform = computed(() => {
  let scaleX = 1;
  let rotation = 0;

  if (angle.value > 270 && angle.value < 360) {
    // This is the northwest sprite which is the same
    // sprite as the northeast sprite, but mirrored
    scaleX = -1;
  } else if (angle.value == 270) {
    scaleX = -1;
  } else if (angle.value == 180) {
    // For west direction, we're using east.png but flipping it horizontally
    scaleX = -1;
  } else if (angle.value > 0 && angle.value < 90) {
    // For southeast sprite we use the same sprite as southwest
    // sprite, but mirrored.
    scaleX = -1;
  } else {
    scaleX = 1;
  }

  if (angle.value == 180) {
    // Left
    //rotation = 15;
  } else if (angle.value == 0) {
    // Right
    ///rotation = 15;
  } if (angle.value > 270 && angle.value < 360) {
    // Up right
    rotation = 35;
  } else if (angle.value > 180 && angle.value < 270) {
    // Up left
    rotation = 35;
  }

  return { scaleX, rotation };
});

let angle = ref(90);

const updateMovement = () => {
  const keys = Array.from(pressedKeys.value);
  
  // Calculate angle based on pressed keys
  let shouldMove = true;

  if (keys.includes('w') && keys.includes('d')) {
    angle.value = 315; // up-right
  }
  else if (keys.includes('w') && keys.includes('a')) {
    angle.value = 225; // up-left
  }
  else if (keys.includes('s') && keys.includes('d')) {
    angle.value = 45; // down-right
  }
  else if (keys.includes('s') && keys.includes('a')) {
    angle.value = 135; // down-left
  }
  else if (keys.includes('w')) {
    angle.value = 270; // up
  }
  else if (keys.includes('s')) {
    angle.value = 90; // down
  }
  else if (keys.includes('a')) {
    angle.value = 180; // left
  }
  else if (keys.includes('d')) {
    angle.value = 0; // right
  }
  else shouldMove = false;

  if (shouldMove) {
    // Apply physics impulse
    gameStore.updateObjectPhysics(props.id, {
      active: true,
      angle: angle.value,
      velocity: MOVEMENT_IMPULSE,
      friction: 3, // High friction for responsive controls
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0.1,
      mass: 10.0
    });
  }
};

let itemPickupListenerId: string;
let itemDiscardedListenerId: string;
let dropItemListenerId: string;

onMounted(() => {
  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('keyup', handleKeyUp);
  window.addEventListener('blur', clearPressedKeys);
  
  // Listen for item pickup events
  itemPickupListenerId = gameStore.addEventListener('item-pickup', handleItemPickup);
  
  // Listen for item discarded events
  itemDiscardedListenerId = gameStore.addEventListener('item-discarded', handleItemDiscarded);
  
  // Listen for drop item events
  dropItemListenerId = gameStore.addEventListener('drop-item', handleDropItem);
});

onUnmounted(() => {
  window.removeEventListener('keydown', handleKeyDown);
  window.removeEventListener('keyup', handleKeyUp);
  window.removeEventListener('blur', clearPressedKeys);
  pressedKeys.value.clear();
  
  // Remove event listeners
  gameStore.removeEventListener('item-pickup', itemPickupListenerId);
  gameStore.removeEventListener('item-discarded', itemDiscardedListenerId);
  gameStore.removeEventListener('drop-item', dropItemListenerId);
});

onBeforeUnmount(() => {
  clearPressedKeys();
});

// Watch for changes to heldItemId
watch(() => heldItemId.value, (newValue) => {
  if (newValue) {
    // Player is now holding an item, show the hint
    gameStore.emitEvent('hint', {
      message: "<b>T</b> - Throw<br><b>I</b> - Inspect",
      duration: 0 // 0 means it stays until cleared
    });
  } else {
    // Player is no longer holding an item, clear the hint
    gameStore.emitEvent('clear-hint');
  }
}, { immediate: true });

// Watch for changes to interaction locked state
watch(() => gameStore.interactionLocked, (newValue) => {
  if (newValue) {
    clearPressedKeys();
  }
});
</script>

<template>
  <div
    :id="props.id"
    :style="{
      position: 'absolute',
      top: `${row * tileSize}px`,
      left: `${col * tileSize}px`,
      width: `${tileSize}px`,
      height: `${tileSize}px`,
      border: gameStore.debug ? '1px solid red': 'none',
      display: 'flex',
      justifyContent: 'center'
    }">
    <!-- Height visualization line (only visible in debug mode) -->
    <div v-if="gameStore.debug" 
         class="height-line"
         :style="{
           position: 'absolute',
           left: '0',
           bottom: '0',
           width: '2px',
           height: `${height * tileSize}px`,
           backgroundColor: 'blue',
           zIndex: 1000
         }">
    </div>
    <!-- Held item display above player's head -->
    <div v-if="heldItem"
      class="held-item-container"
      :style="{
        position: 'absolute',
        width: `${tileSize}px`,
        height: `${tileSize}px`,
        top: `-${tileSize * 2}px`,
      }">
      <div class="item-container ghost-glow" :class="rarityClass">
        <img 
          :src="heldItem.imageUrl || '/src/assets/generic.png'" 
          :alt="heldItem.name"
          class="held-item-image"
        />
      </div>
    </div>
    
    <!-- Drop shadow under player's feet -->
    <div
      class="player-shadow"
      :style="{
        position: 'absolute',
        bottom: `-0px`,
        width: `${tileSize * 0.7}px`,
        height: `${tileSize * 0.2}px`,
        backgroundColor: 'rgba(0, 0, 0, 0.3)',
        borderRadius: '50%',
        filter: 'blur(3px)',
      }"
    ></div>
    
    <img
      :src="currentSprite"
      :style="{ 
        position: 'absolute',
        top: `-${tileSize}px`,
        margin: '0 auto',
        height: `${tileSize * 2}px`,
        '--scale-x': transform.scaleX,
        '--rotation': `${transform.rotation}deg`,
      }"
      class="ghost-container ghost-glow"
      alt="Ghost character"
    />
  </div>
</template>

<style scoped>
.held-item-container {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: all 0.3s ease;
  position: relative;
}

.held-item-image {
  transform: scale(1.1);
  animation: item-floating 1.2s ease-in-out infinite;
}

@keyframes item-floating {
  0% { transform: scale(1.1) translateY(0); }
  50% { transform: scale(1.1) translateY(-4px); }
  100% { transform: scale(1.1) translateY(0); }
}

.ghost-container {
  animation: ghost-bobbing 1s ease-in-out infinite;
  transform: scaleX(var(--scale-x, 1)) rotate(var(--rotation, 0));
}

.ghost-container.ghost-glow,
.item-container.ghost-glow {
  filter: drop-shadow(0 0 15px white);
}

@keyframes ghost-bobbing {
  0% { transform: scaleX(var(--scale-x, 1)) rotate(var(--rotation, 0)) translateY(0); }
  50% { transform: scaleX(var(--scale-x, 1)) rotate(var(--rotation, 0)) translateY(-8px); }
  100% { transform: scaleX(var(--scale-x, 1)) rotate(var(--rotation, 0)) translateY(0); }
}
</style>


================================================
FILE: client/src/components/Preloader.vue
================================================
<template>
  <div class="preloader-container">
    <!-- Preload all static assets by rendering them with visibility: hidden -->
    <img 
      v-for="(asset, index) in staticAssetUrls" 
      :key="index" 
      :src="asset" 
      class="preloaded-image" 
      alt="Preloaded asset"
    />
  </div>
</template>

<script setup lang="ts">
import { staticAssets } from '../assets'

// Extract all static asset URLs into an array
const staticAssetUrls = Object.values(staticAssets)
</script>

<style scoped>
.preloader-container {
  position: absolute;
  width: 0;
  height: 0;
  overflow: hidden;
  opacity: 0;
  pointer-events: none;
}

.preloaded-image {
  position: absolute;
  width: 1px;
  height: 1px;
  visibility: hidden;
}
</style>


================================================
FILE: client/src/components/PullLever.vue
================================================
<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import leverImage from '../assets/lever.png';
import { useGameStore } from '../stores/game';
import type { Item } from '../systems/item-system';

const props = defineProps<{
  id: string,
  row: number;
  col: number;
  tileSize: number;
  width: number;
  depth: number;
  height: number;
  playerIsNear: boolean;
  props: {
    pivotPoint?: 'top' | 'middle' | 'bottom' | { x: number, y: number };
    initialAngle?: number;
    maxRotationAngle?: number;
    rotationSpeed?: number;
    autoReset?: boolean;
    resetDelay?: number;
    resetSpeed?: number;
  }
}>();

const isPulling = ref(false);
const isRotating = ref(false);
const isPulled = ref(false);
const currentRotation = ref(props.props.initialAngle || 0);
const gameStore = useGameStore();
const localInventory = ref<Item[]>([]);

function handlePlayerInteraction() {
  if (!props.playerIsNear || isPulling.value || isRotating.value) {
    return;
  }

  // Start pulling
  isPulling.value = true;
  
  // Start rotation animation
  isRotating.value = true;
  
  // Animate rotation
  const initialAngle = props.props.initialAngle || 0;
  const maxAngle = props.props.maxRotationAngle || 60;
  const rotationSpeed = props.props.rotationSpeed || 100;
  
  // Simple animation using setTimeout
  const startTime = Date.now();
  const animateRotation = () => {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / rotationSpeed, 1);
    currentRotation.value = initialAngle + progress * (maxAngle - initialAngle);
    
    if (progress < 1) {
      requestAnimationFrame(animateRotation);
    } else {
      // Rotation complete
      isRotating.value = false;
      isPulled.value = true;
      isPulling.value = false;
      
      // Emit lever-pulled event
      gameStore.emitEvent('lever-pulled');
      
      // Check if we have local inventory items to prioritize
      if (localInventory.value.length > 0) {
        // Pop an item from the local inventory
        const item = localInventory.value.shift();
        // Emit the pulled-item event with the local item
        gameStore.emitEvent('pulled-item', { item });
      } else {
        // If no local items, request a new one from the server
        gameStore.pullItem();
      }
      
      // Auto reset if configured
      if (props.props.autoReset) {
        setTimeout(() => {
          resetLever();
        }, props.props.resetDelay || 2000);
      }
    }
  };
  
  animateRotation();
}

function resetLever() {
  if (!isPulled.value || isRotating.value) {
    return;
  }
  
  // Start reset animation
  isRotating.value = true;
  
  // Animate reset rotation
  const resetSpeed = props.props.resetSpeed || props.props.rotationSpeed || 100;
  
  // Simple animation using setTimeout
  const startTime = Date.now();
  const animateReset = () => {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / resetSpeed, 1);
    const initialAngle = props.props.initialAngle || 0;
    const maxAngle = props.props.maxRotationAngle || 60;
    currentRotation.value = initialAngle + (1 - progress) * (maxAngle - initialAngle);
    
    if (progress < 1) {
      requestAnimationFrame(animateReset);
    } else {
      // Reset complete
      isRotating.value = false;
      isPulled.value = false;
      
      // Emit event when lever is reset
      gameStore.emitEvent('lever-reset', {
        leverId: props.id
      });
    }
  };
  
  animateReset();
}

// Handle inventory list response from server
function handleInventoryList(data: any, eventType?: string) {
  if (data && Array.isArray(data)) {
    localInventory.value = data;
  }
}

// Calculate pivot point based on configuration
const getPivotPoint = () => {
  const pivotConfig = props.props.pivotPoint || 'bottom';
  
  if (typeof pivotConfig === 'object') {
    // Custom pivot point
    return `${pivotConfig.x}% ${pivotConfig.y}%`;
  }
  
  // Predefined pivot points
  switch (pivotConfig) {
    case 'top':
      return '50% 0%';
    case 'middle':
      return '50% 50%';
    case 'bottom':
    default:
      return '50% 100%';
  }
};

let interactionListenerId: string;
let inventoryListenerId: string;

onMounted(() => {
  interactionListenerId = gameStore.addEventListener('player-interaction', handlePlayerInteraction);
  inventoryListenerId = gameStore.addEventListener('inventory-items:main', handleInventoryList);
  
  // Fetch inventory when component mounts
  gameStore.listInventory(`${gameStore.userId}:main`);
});

onUnmounted(() => {
  gameStore.removeEventListener('player-interaction', interactionListenerId);
  gameStore.removeEventListener('inventory-items:main', inventoryListenerId);
});
</script>

<template>
  <div :style="{
    position: 'absolute',
    top: `${row * tileSize}px`,
    left: `${col * tileSize}px`,
    width: `${width * tileSize}px`,
    height: `${depth * tileSize}px`,
    border: gameStore.debug ? '1px solid red': 'none',
    zIndex: 10
  }">
    <div v-if="playerIsNear && !isPulling && !isPulled" class="interact-prompt">E</div>
    <img 
      :src="leverImage" 
      :height="depth * tileSize"
      :style="{
        position: 'absolute',
        top: `${-tileSize * 2}px`,
        transformOrigin: getPivotPoint(),
        transform: `rotate(${currentRotation}deg)`
      }"
      :class="['lever', { 'lever-active': playerIsNear, 'lever-pulling': isPulling }]"
      alt="Lever"
    />
  </div>
</template>

<style scoped>
.lever {
  filter: none;
  object-fit: contain;
  transition: filter 0.3s ease;
}

.lever-active {
  filter: drop-shadow(0 0 15px white);
}

.lever-pulling {
  animation: pulse 1s infinite;
}

.interact-prompt {
  position: absolute;
  top: -80%;
  right: -10%;
  font-size: calc(0.5 * v-bind(tileSize))px;
  font-weight: bold;
  color: white;
  text-shadow: 0 0 5px white;
  background-color: black;
  padding: 5px 10px;
  border-radius: 4px;
}

@keyframes pulse {
  0% { filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.5)); }
  50% { filter: drop-shadow(0 0 30px rgba(255, 255, 255, 1)); }
  100% { filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.5)); }
}
</style>



================================================
FILE: client/src/components/RandomChat.vue
================================================
<script setup lang="ts">
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { useGameStore } from '../stores/game';

const store = useGameStore();
const visible = ref(false);
const currentMessage = ref('');
let lastNearDoorTime = 0;
const DEBOUNCE_TIME = 5000; // 5 seconds debounce

// Array of general shop messages
const messages = [
  "Get back to work! We need more items!",
  "The repair bench is waiting for you!",
  "Time to fix some more items!",
  "The shop needs more inventory!",
  "Customers are waiting for repaired items!",
  "Don't keep me waiting! Get crafting!",
  "The repair bench is empty! Get to work!",
  "We need more items to sell!",
  "The shelves are looking bare!",
  "Keep those repairs coming!"
];

// Array of door messages when holding an item
const doorMessagesWithItem = [
  "Ah, a great find! Throw it here!",
  "Perfect! Hand that over so I can sell it!",
  "That looks good! Toss it my way!",
  "I'll take that repaired item off your hands!",
  "Great work! Now give it to me to sell!"
];

// Array of door messages when not holding an item
const doorMessagesWithoutItem = [
  "Why aren't you at the repair bench?",
  "Get back to work! We need more items!",
  "The repair bench is waiting for you!",
  "Don't keep the customers waiting!",
  "Time to fix some more items!"
];

let messageInterval: number | null = null;
let nearDoorListenerId: string | null = null;

// Check if player is holding an item
const isHoldingItem = computed(() => {
  return store.heldItemId !== null;
});

function showRandomMessage() {
  const randomIndex = Math.floor(Math.random() * messages.length);
  currentMessage.value = messages[randomIndex];
  visible.value = true;
  
  // Hide the message after 3 seconds
  setTimeout(() => {
    visible.value = false;
  }, 3000);
}

function showDoorMessage() {
  const now = Date.now();
  if (now - lastNearDoorTime < DEBOUNCE_TIME) return;
  lastNearDoorTime = now;
  
  const messages = isHoldingItem.value ? doorMessagesWithItem : doorMessagesWithoutItem;
  const randomIndex = Math.floor(Math.random() * messages.length);
  currentMessage.value = messages[randomIndex];
  visible.value = true;
  
  // Hide the message after 3 seconds
  setTimeout(() => {
    visible.value = false;
  }, 3000);
}

onMounted(() => {
  // Show first message after 5 seconds
  setTimeout(() => {
    showRandomMessage();
  }, 5000);
  
  // Set up interval to show messages every 60 seconds
  messageInterval = window.setInterval(() => {
    if (!store.interactionLocked) { // Only check for dialogs being open
      showRandomMessage();
    }
  }, 60000);

  // Listen for near-door event
  nearDoorListenerId = store.addEventListener('near-door', () => {
    showDoorMessage();
  });
});

onUnmounted(() => {
  if (messageInterval) {
    clearInterval(messageInterval);
  }
  if (nearDoorListenerId) {
    store.removeEventListener('near-door', nearDoorListenerId);
  }
});
</script>

<template>
  <div v-if="visible" class="random-chat">
    <div class="chat-bubble">
      {{ currentMessage }}
    </div>
  </div>
</template>

<style scoped>
.random-chat {
  position: absolute;
  bottom: 5%;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
}

.chat-bubble {
  background-color: rgba(0, 0, 0, 0.7);
  color: #ddd;
  padding: 10px 15px;
  border-radius: 15px;
  font-size: 1.2em;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  white-space: nowrap;
  animation: fadeIn 0.5s ease-in;
}

.chat-bubble:after {
  content: '';
  position: absolute;
  bottom: -10px;
  left: 50%;
  transform: translateX(-50%);
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-top: 10px solid rgba(0, 0, 0, 0.7);
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}
</style> 


================================================
FILE: client/src/components/SellDialog.vue
================================================
<script setup lang="ts">
import { ref, onMounted, onUnmounted, computed, watch } from 'vue';
import { useGameStore } from '../stores/game';
import ItemPreview from './ItemPreview.vue';
import { getRarityClass } from '../utils/items';
import sellTableImage from '../assets/sell-table.png';
import appraisingImage from '../assets/appraising.png';
import happyImage from '../assets/happy.png';
import unhappyImage from '../assets/unhappy.png';
import neutralImage from '../assets/neutral.png';
import type { Item } from '../systems/item-system';
import { useEscapeKeyHandler } from '../composables/useEscapeKeyHandler';

const store = useGameStore();

// State
const visible = ref(false);
const isLoading = ref(true);
const sellData = ref<Item | null>(null);
const result = ref<any>(null);

// State to track which item is being hovered
const hoveredItemId = ref<string | null>(null);
const hoveredItemElement = ref<HTMLElement | null>(null);
const hoveredItemPosition = ref({ x: 0, y: 0 });

// Get the currently hovered item object
const hoveredItem = computed(() => {
  if (!hoveredItemId.value) return null;
  return store.useItem(hoveredItemId.value).value;
});

// Handle mouse enter event for items
function handleItemMouseEnter(itemId: string | undefined, event: MouseEvent) {
  if (!itemId) return;
  hoveredItemId.value = itemId;
  hoveredItemElement.value = event.currentTarget as HTMLElement;
  
  // Capture the position of the hovered item
  const target = event.currentTarget as HTMLElement;
  if (target) {
    const rect = target.getBoundingClientRect();
    const tooltipWidth = 300; // Approximate width of tooltip

    hoveredItemPosition.value = {
      x: rect.right + 10, // Position to the right of the item
      y: rect.top // Align with the top of the item
    };
    
    // Check if tooltip would go off-screen to the right
    if (hoveredItemPosition.value.x + tooltipWidth > window.innerWidth) {
      hoveredItemPosition.value.x = rect.left - tooltipWidth - 10; // Position to the left of the item
    }

    // Check if tooltip would go off-screen to the left
    if (hoveredItemPosition.value.x < 0) {
      hoveredItemPosition.value.x = 10;
    }
    
    // Check if tooltip would go off-screen at the bottom
    const tooltipHeight = 400; // Approximate height of tooltip
    if (hoveredItemPosition.value.y + tooltipHeight > window.innerHeight) {
      // Adjust y position to keep tooltip on screen
      hoveredItemPosition.value.y = window.innerHeight - tooltipHeight - 10;
    }
  }
}

// Handle mouse leave event for items
function handleItemMouseLeave() {
  hoveredItemId.value = null;
  hoveredItemElement.value = null;
}

function closeDialog() {
  if (isLoading.value) return;
  // Clear any hovered item preview when closing
  hoveredItemId.value = null;
  visible.value = false;
  // Emit gold update event with the sale amount
  if (result.value?.gold) {
    store.emitEvent('gold-update', { gold: result.value.gold });
  }
}

// Use the focus management composable
const { handleKeyDown } = useEscapeKeyHandler('sell-dialog', (event) => {
  if (event.key === 'Escape' && visible.value && !isLoading.value) {
    closeDialog();
    return true;
  }
  return false;
});

// Listen for events
let sellItemListenerId: string;
let itemSoldListenerId: string | null = null;

onMounted(() => {
  sellItemListenerId = store.addEventListener('sell-item', (data) => {
    if (data && data.id) {
      // Get the item data directly from the store using the ID
      const itemData = store.useItem(data.id);
      if (itemData) {
        sellData.value = itemData.value;
        visible.value = true;
        isLoading.value = true;
        
        // Remove the game object from the world
        store.removeObject(data.id);
        
        // Send sell-item request to server
        store.sellItem(data.id);
      }
    }
  });
  
  itemSoldListenerId = store.addEventListener('item-sold', (data) => {
    result.value = data;
    isLoading.value = false;
    // Clear any hovered item preview when the result comes back
    hoveredItemId.value = null;
  });
});

onUnmounted(() => {
  store.removeEventListener('sell-item', sellItemListenerId);
  if (itemSoldListenerId) {
    store.removeEventListener('item-sold', itemSoldListenerId);
  }
});

// Watch for changes to visible prop to manage focus
watch(() => visible.value, (newValue) => {
  if (newValue) {
    store.pushFocus('sell-dialog');
  } else {
    store.popFocus();
  }
});

function getHappinessText(happiness: number): string {
  if (happiness > 50) return 'Absolutely Thrilled!';
  if (happiness > 0) return 'Quite Pleased';
  if (happiness === 0) return 'Neutral';
  if (happiness > -50) return 'Disappointed';
  return 'Absolutely Disgusted';
}

function getAppraiserImage(happiness: number): string {
  if (happiness > 50) return happyImage;
  if (happiness < -20) return unhappyImage;
  return neutralImage;
}

function getAppraiserComment(happiness: number): string {
  if (happiness > 50) return "What an exceptional find!";
  if (happiness > 0) return "Not bad at all!";
  if (happiness === 0) return "Hmm, interesting...";
  if (happiness > -50) return "Well, it's something...";
  return "Oh my...";
}
</script>

<template>
  <div v-if="visible" class="sell-dialog-overlay">
    <div class="sell-dialog">
      <!-- Loading state -->
      <div v-if="isLoading" class="dialog-content loading-content">
        <div class="appraising-container">
          <div class="chat-bubble">Hmm... let's see</div>
          <img :src="appraisingImage" class="appraising-image" alt="Appraising" />
        </div>
        <div class="table-container">
          <img :src="sellTableImage" class="table-image" alt="Sell Table" />
        </div>
        <div class="preview-grid" v-if="sellData">
          <div class="item-wrapper" 
               :class="getRarityClass(sellData?.value)"
               @mouseenter="(event) => handleItemMouseEnter(sellData?.id, event)"
               @mouseleave="handleItemMouseLeave">
            <img :src="sellData?.imageUrl" class="item-image" :alt="sellData?.name" />
          </div>
        </div>
      </div>
      
      <!-- Result state -->
      <div v-else class="dialog-content result-content">
        <div class="appraisal-container">
          <div class="appraising-container">
            <div class="chat-bubble">{{ getAppraiserComment(result?.appraisal?.appraisal?.happiness) }}</div>
            <img :src="getAppraiserImage(result?.appraisal?.appraisal?.happiness)" class="appraising-image" alt="Appraiser" />
          </div>
        </div>
        <div class="table-container">
          <img :src="sellTableImage" class="table-image" alt="Sell Table" />
        </div>
        <div class="preview-grid" v-if="sellData">
          <div class="item-wrapper" 
                :class="getRarityClass(sellData?.value)"
                @mouseenter="(event) => handleItemMouseEnter(sellData?.id, event)"
                @mouseleave="handleItemMouseLeave">
            <img :src="sellData?.imageUrl" class="item-image" :alt="sellData?.name" />
          </div>
        </div>
        <div class="appraisal-details">
          <div class="appraisal-row">
            <p class="value">{{ result?.appraisal?.appraisal?.analysis || 'No analysis provided.' }}</p>
          </div>
          <div class="appraisal-tags">
            <div class="tags-container">
              <div class="gold-tag">
                <div class="gold-icon"></div>
                <span class="gold-amount">{{ result?.appraisal?.appraisal?.saleAmount || 0 }}</span>
              </div>
              <div class="happiness-tag" :class="{
                'very-happy': result?.appraisal?.appraisal?.happiness > 50,
                'happy': result?.appraisal?.appraisal?.happiness > 0 && result?.appraisal?.appraisal?.happiness <= 50,
                'neutral': result?.appraisal?.appraisal?.happiness === 0,
                'unhappy': result?.appraisal?.appraisal?.happiness < 0 && result?.appraisal?.appraisal?.happiness >= -50,
                'very-unhappy': result?.appraisal?.appraisal?.happiness < -50
              }">
                {{ getHappinessText(result?.appraisal?.appraisal?.happiness) }}
              </div>
            </div>
            <button class="done-button" @click="closeDialog">Done</button>
          </div>
        </div>
      </div>
      
      <!-- Item Preview Component -->
      <ItemPreview 
        v-if="hoveredItem && hoveredItemElement"
        :item="hoveredItem"
        :style="{
          position: 'absolute',
          left: '50%',
          top: '10%',
          transform: 'translateX(-50%)',
          maxHeight: '40vh',
          overflowY: 'auto',
          zIndex: 4
        }"
      />
    </div>
  </div>
</template>

<style scoped>
.sell-dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.sell-dialog {
  position: relative;
  width: min(90vh, 90vw);
  height: min(90vh, 90vw);
  max-width: min(90vh, 1200px);
  max-height: min(90vh, 1200px);
  margin: auto;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
}

.table-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 2;
}

.table-image {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.dialog-content {
  position: relative;
  width: 100%;
  height: 100%;
  z-index: 2;
}

.dialog-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 20px;
  border-bottom: 1px solid #333;
}

.dialog-header h2 {
  margin: 0;
  font-size: 1.5rem;
  color: white;
}

.close-button {
  background: none;
  border: none;
  color: #aaa;
  font-size: 1.8rem;
  cursor: pointer;
  padding: 0;
  line-height: 1;
}

.close-button:hover {
  color: white;
}

.close-button:disabled {
  color: #555;
  cursor: not-allowed;
}

.loading-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
}

.preview-grid {
  position: absolute;
  width: 15%;
  height: 15%;
  top: 55%;
  left: 59%;
  display: grid;
  grid-template-columns: repeat(1, 1fr);
  grid-template-rows: repeat(1, 1fr);
  gap: 10px;
  justify-items: center;
  align-items: center;
  z-index: 3;
  transform: perspective(400px) rotateX(25deg) rotateZ(-2deg);
  transform-origin: bottom center;
  filter: drop-shadow(0 10px 8px rgba(0, 0, 0, 0.3));
}

.preview-slot {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  border: 3px dashed rgb(113, 67, 31);
  border-radius: 6px;
  transition: border-color 0.3s, background-color 0.3s;
}

.preview-slot:hover {
  border-color: rgb(173, 127, 91);
  background-color: rgba(113, 67, 31, 0.2);
}

.item-wrapper {
  width: 80%;
  height: 80%;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 5px;
  transition: all 0.2s;
  transform: perspective(2000px) rotateX(-25deg) rotateZ(2deg);
  transform-style: preserve-3d;
  backface-visibility: hidden;
}

/* Add animation for loading state */
.loading-content .item-wrapper {
  animation: itemFloat 3s ease-in-out infinite;
}

@keyframes itemFloat {
  0% {
    transform: perspective(2000px) rotateX(-25deg) rotateZ(2deg);
  }
  25% {
    transform: perspective(2000px) rotateX(25deg) rotateZ(-2deg);
  }
  50% {
    transform: perspective(2000px) rotateX(-25deg) rotateZ(2deg) rotateY(180deg);
  }
  75% {
    transform: perspective(2000px) rotateX(25deg) rotateZ(-2deg) rotateY(180deg);
  }
  100% {
    transform: perspective(2000px) rotateX(-25deg) rotateZ(2deg);
  }
}

.item-image {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  transform: translateZ(20px);
  filter: drop-shadow(0 5px 3px rgba(0, 0, 0, 0.2));
}

.processing-text {
  margin: 20px 0;
  color: #ddd;
  font-size: 1.1rem;
  text-align: center;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  border-top-color: #2196f3;
  animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.result-content {
  padding: 20px;
}

.appraisal-container {
  position: absolute;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.appraisal-details {
  position: absolute;
  background-color: rgba(121, 75, 35);
  border-radius: 8px;
  left: 2.5%;
  width: 95.5%;
  top: 77%;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: flex-start;
  z-index: 3;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
  border: .7vw solid rgba(50, 36, 20);
  padding: 15px;
  overflow: hidden;
}

.appraisal-row {
  width: 100%;
  margin-bottom: 12px;
}

.appraisal-row .value {
  color: #ddd;
  line-height: 1.4;
  font-size: 0.9rem;
  margin: 0;
  padding: 0;
  overflow-wrap: break-word;
  word-wrap: break-word;
  hyphens: auto;
}

.appraisal-tags {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
}

.tags-container {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

.gold-tag {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 16px;
  border: 1px solid rgba(255, 215, 0, 0.3);
}

.happiness-tag {
  padding: 6px 12px;
  border-radius: 16px;
  font-size: 0.9rem;
  font-weight: 500;
  background-color: rgba(0, 0, 0, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.happiness-tag.very-happy {
  color: #4CAF50;
  border-color: rgba(76, 175, 80, 0.3);
}

.happiness-tag.happy {
  color: #8BC34A;
  border-color: rgba(139, 195, 74, 0.3);
}

.happiness-tag.neutral {
  color: #FFC107;
  border-color: rgba(255, 193, 7, 0.3);
}

.happiness-tag.unhappy {
  color: #FF9800;
  border-color: rgba(255, 152, 0, 0.3);
}

.happiness-tag.very-unhappy {
  color: #F44336;
  border-color: rgba(244, 67, 54, 0.3);
}

.gold-amount {
  font-size: 0.9rem;
  color: #ffd700;
  font-weight: 500;
}

.appraising-container {
  position: absolute;
  width: 40%;
  height: 40%;
  top: 23%;
  left: 42%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  animation: float 2s ease-in-out infinite;
  z-index: 1;
}

.chat-bubble {
  position: absolute;
  top: -40px;
  background-color: rgba(0, 0, 0, 0.7);
  color: #ddd;
  padding: 10px 15px;
  border-radius: 15px;
  font-size: 1.2em;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  white-space: nowrap;
  animation: fadeIn 0.5s ease-in;
}

.chat-bubble:after {
  content: '';
  position: absolute;
  bottom: -10px;
  left: 50%;
  transform: translateX(-50%);
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-top: 10px solid rgba(0, 0, 0, 0.7);
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.appraising-image {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

@keyframes float {
  0% { transform: translateY(0); }
  50% { transform: translateY(-4%); }
  100% { transform: translateY(0); }
}

.appraisal-header {
  position: absolute;
  top: 10px;
  right: 10px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.close-appraisal-button {
  background: none;
  border: none;
  color: #aaa;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 5px;
  line-height: 1;
  transition: color 0.2s;
}

.close-appraisal-button:hover {
  color: white;
}

.done-button {
  padding: 8px 24px;
  background-color: rgba(76, 175, 80, 0.2);
  border: 1px solid rgba(76, 175, 80, 0.4);
  border-radius: 20px;
  color: #4CAF50;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.done-button:hover {
  background-color: rgba(76, 175, 80, 0.3);
  border-color: rgba(76, 175, 80, 0.6);
  transform: translateY(-1px);
}

.done-button:active {
  transform: translateY(0);
}
</style>


================================================
FILE: client/src/components/SkillResultDialog.vue
================================================
<script setup lang="ts">
import { ref, onMounted, onUnmounted, computed, watch } from 'vue';
import { useGameStore } from '../stores/game';
import ItemPreview from './ItemPreview.vue';
import { getRarityClass } from '../utils/items';
import { useEscapeKeyHandler } from '../composables/useEscapeKeyHandler';

const store = useGameStore();

// State to track dialog visibility, loading state, story state, and result data
const visible = ref(false);
const isLoading = ref(true);
const storyText = ref<string>('');
const isComplete = ref(false);
const displayedStoryText = ref<string>('');
const resultData = ref<{
  tool: any;
  removedItemIds: string[];
  story: string;
}>({
  tool: null,
  removedItemIds: [],
  story: ''
});

// State to track skill invocation details for the loading animation
const skillInvocationData = ref<{
  skill: any;
  tool: any;
  targets: any[];
} | null>(null);

// State to track which item is being hovered
const hoveredItemId = ref<string | null>(null);
// State to track if the tool is being hovered
const isToolHovered = ref(false);

// Get the workbench-results inventory using the useInventory composable
const workbenchResultsIds = store.useInventory('workbench-results');

// Computed properties for removed and output items
const removedItems = computed(() => {
  if (!resultData.value?.removedItemIds || !resultData.value.removedItemIds.length) {
    return [];
  }
  
  return resultData.value.removedItemIds
    .map((itemId: string) => store.useItem(itemId).value);
});

// Get the actual item objects from the workbench-results inventory IDs
const workbenchResultItems = computed(() => {
  return workbenchResultsIds.value
    .map(itemId => store.useItem(itemId).value);
});

// Get the currently hovered item object
const hoveredItem = computed(() => {
  if (isToolHovered.value && resultData.value?.tool) {
    return resultData.value.tool;
  }
  if (!hoveredItemId.value) return null;
  return store.useItem(hoveredItemId.value).value;
});

// Handle mouse enter event for items
function handleItemMouseEnter(itemId: string) {
  hoveredItemId.value = itemId;
  isToolHovered.value = false;
}

// Handle mouse leave event for items
function handleItemMouseLeave() {
  hoveredItemId.value = null;
}

// Handle mouse enter event for tool
function handleToolMouseEnter() {
  isToolHovered.value = true;
}

// Handle mouse leave event for tool
function handleToolMouseLeave() {
  isToolHovered.value = false;
}

function closeDialog() {
  if (isLoading.value || !isComplete.value) {
    return;
  }
  store.emitEvent('clean-workbench-results');
  visible.value = false;
}

// Use the focus management composable
const { handleKeyDown } = useEscapeKeyHandler('skill-use', (event) => {
  if (event.key === 'Escape' && visible.value && !isLoading.value && isComplete.value) {
    closeDialog();
    return true;
  }
  return false;
});

// Listen for skill events
let skillInvokedListenerId: string;
let skillStoryListenerId: string;
let skillToolUpdateListenerId: string;
let skillNewItemListenerId: string;
let skillUpdatedItemListenerId: string;
let skillRemovedItemListenerId: string;
let useSkillDoneListenerId: string;

// Add typing animation logic
const startTypingAnimation = (text: string) => {
  const words = text.split(' ');
  let currentIndex = 0;
  displayedStoryText.value = '';
  
  const typeNextWord = () => {
    if (currentIndex < words.length) {
      displayedStoryText.value += (currentIndex > 0 ? ' ' : '') + words[currentIndex];
      currentIndex++;
      setTimeout(typeNextWord, 50); // 20 words per second = 50ms per word
    }
  };
  
  typeNextWord();
};

onMounted(() => {
  skillInvokedListenerId = store.addEventListener('skill-invoked', (data) => {
    visible.value = true;
    isLoading.value = true;
    isComplete.value = false;
    storyText.value = '';
    displayedStoryText.value = '';
    resultData.value = {
      tool: null,
      removedItemIds: [],
      story: ''
    };
    skillInvocationData.value = data;
  });
  
  skillStoryListenerId = store.addEventListener('skill-use-story', (data) => {
    storyText.value = data.story;
    resultData.value.story = data.story;
    isLoading.value = false;
    startTypingAnimation(data.story);
  });
  
  skillToolUpdateListenerId = store.addEventListener('skill-use-tool-update', (data) => {
    resultData.value.tool = data.tool;
    isLoading.value = false;
  });
  
  skillNewItemListenerId = store.addEventListener('skill-use-new-item', (data) => {
    isLoading.value = false;
  });
  
  skillUpdatedItemListenerId = store.addEventListener('skill-use-updated-item', (data) => {
    isLoading.value = false;
  });
  
  skillRemovedItemListenerId = store.addEventListener('skill-use-removed-item', (data) => {
    resultData.value.removedItemIds.push(data.itemId);
    isLoading.value = false;
  });
  
  useSkillDoneListenerId = store.addEventListener('skill-use-done', () => {
    isComplete.value = true;
  });
});

onUnmounted(() => {
  store.removeEventListener('skill-invoked', skillInvokedListenerId);
  store.removeEventListener('skill-use-story', skillStoryListenerId);
  store.removeEventListener('skill-use-tool-update', skillToolUpdateListenerId);
  store.removeEventListener('skill-use-new-item', skillNewItemListenerId);
  store.removeEventListener('skill-use-updated-item', skillUpdatedItemListenerId);
  store.removeEventListener('skill-use-removed-item', skillRemovedItemListenerId);
  store.removeEventListener('use-skill-done', useSkillDoneListenerId);
});

watch(visible, (newValue) => {
  if (newValue) {
    store.pushFocus('skill-use');
  } else {
    store.popFocus();
  }
}, { immediate: true });
</script>

<template>
  <div v-if="visible" class="skill-result-overlay">
    <!-- Loading state - just the animation -->
    <div v-if="isLoading" class="loading-phase">
      <div class="skill-fusion-container">
        <!-- Tool item on the left -->
        <div v-if="skillInvocationData?.tool" class="fusion-item tool-item">
          <div class="item-wrapper" :class="getRarityClass(skillInvocationData.tool.value)">
            <img :src="skillInvocationData.tool.imageUrl || '/src/assets/generic.png'" class="item-image" :alt="skillInvocationData.tool.name" />
          </div>
          <div class="fusion-label">{{ skillInvocationData.tool.name }}</div>
        </div>
        
        <!-- Skill name in the center -->
        <div class="fusion-skill">
          <div class="skill-name">{{ skillInvocationData?.skill?.name || 'Skill' }}</div>
        </div>
        
        <!-- Target items on the right -->
        <template v-if="skillInvocationData?.targets">
          <div 
            v-for="(target, index) in skillInvocationData.targets" 
            :key="target.id"
            class="fusion-item target-item"
            :style="{
              '--target-index': index,
              '--total-targets': skillInvocationData.targets.length
            }"
          >
            <div class="item-wrapper" :class="getRarityClass(target.value)">
              <img :src="target.imageUrl || '/src/assets/generic.png'" class="item-image" :alt="target.name" />
            </div>
            <div class="fusion-label">{{ target.name }}</div>
          </div>
        </template>

        <!-- Fusion effect overlay -->
        <div class="fusion-effect"></div>
      </div>
    </div>
    
    <!-- Result state - full dialog -->
    <div v-else class="skill-result-dialog" :class="{ 'processing': !isComplete }">
      <button v-if="isComplete" class="close-button" @click="closeDialog">×</button>
      
      <div class="dialog-content">
        <!-- Story section -->
        <div class="story-section">
          <p class="story-text">{{ displayedStoryText }}</p>
        </div>

        <div class="results-container">
          <!-- Tool used section -->
          <div v-if="resultData?.tool" class="result-item">
            <div class="item-label changed">Used</div>
            <div 
              class="item-container"
              @mouseenter="handleToolMouseEnter"
              @mouseleave="handleToolMouseLeave"
            >
              <div class="item-wrapper" :class="getRarityClass(resultData.tool.value)">
                <img :src="resultData.tool.imageUrl || '/src/assets/generic.png'" class="item-image" :alt="resultData.tool.name" />
              </div>
            </div>
          </div>
          
          <!-- Lost items -->
          <div v-for="item in removedItems" :key="item.id" class="result-item">
            <div class="item-label lost">Lost</div>
            <div 
              class="item-container animate-in"
              @mouseenter="handleItemMouseEnter(item.id)"
              @mouseleave="handleItemMouseLeave"
            >
              <div class="item-wrapper" :class="getRarityClass(item.value)">
                <img :src="item.imageUrl" class="item-image" :alt="item.name" />
              </div>
            </div>
          </div>
          
          <!-- New items -->
          <div v-for="item in workbenchResultItems" :key="item.id" class="result-item">
            <div class="item-label new">Gained</div>
            <div 
              class="item-container animate-in"
              @mouseenter="handleItemMouseEnter(item.id)"
              @mouseleave="handleItemMouseLeave"
            >
              <div class="item-wrapper" :class="getRarityClass(item.value)">
                <img :src="item.imageUrl" class="item-image" :alt="item.name" />
              </div>
            </div>
          </div>

          <!-- Placeholder item for incomplete results -->
          <div v-if="!isComplete" class="result-item">
            <div class="item-label">Processing</div>
            <div class="item-container">
              <div class="item-wrapper placeholder">
                <div class="loading-dot"></div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Item Preview Component -->
        <ItemPreview 
          :item="hoveredItem"
          position="fixed"
          top="50%"
          left="50%"
          transform="translate(-50%, -50%)"
          style="z-index: 10000;"
        />
      </div>
    </div>
  </div>
</template>

<style scoped>
.skill-result-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

/* Loading phase styles */
.loading-phase {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

/* Story phase styles */
.story-phase {
  display: none;
}

.story-dialog {
  display: none;
}

/* Result dialog styles */
.skill-result-dialog {
  background-color: #1a1a1a;
  border-radius: 8px;
  width: 800px;
  min-width: 800px;
  max-height: 80vh;
  overflow: hidden;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
  border: 2px solid #333;
  position: relative;
  display: flex;
  flex-direction: column;
}

.skill-result-dialog.processing {
  border: 2px solid #ffd700;
  box-shadow: 0 0 40px rgba(255, 215, 0, 0.5);
  animation: legendary-glow 2s ease-in-out infinite;
  position: relative;
}

.skill-result-dialog.processing::before {
  content: '';
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  border-radius: 12px;
  background: linear-gradient(45deg, #ffd700, #ff8c00, #ffd700);
  z-index: -1;
  animation: legendary-border 3s linear infinite;
  opacity: 0.7;
}

.dialog-content {
  padding: 20px;
  padding-top: 40px;
  color: #ddd;
  display: flex;
  flex-direction: column;
  gap: 24px;
  position: relative;
  height: 100%;
  overflow-y: auto;
}

/* Loading state styles */
.loading-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  position: relative;
}

.skill-fusion-container {
  position: relative;
  width: 100%;
  height: 400px;
  display: flex;
  justify-content: center;
  align-items: center;
  perspective: 1000px;
}

.fusion-item {
  position: absolute;
  width: 80px;
  height: 80px;
  display: flex;
  flex-direction: column;
  align-items: center;
  z-index: 2;
  transition: transform 0.5s ease-out;
}

.tool-item {
  left: 25%;
  top: 50%;
  transform: translate(-50%, -50%);
  animation: tool-approach 3s ease-in-out infinite;
}

.target-item {
  right: 25%;
  top: 50%;
  transform: translate(50%, -50%);
  animation: target-approach 3s ease-in-out infinite;
  animation-delay: calc(var(--target-index) * 0.4s);
  top: calc(50% + (var(--target-index) - (var(--total-targets) - 1) / 2) * 60px);
}

.fusion-skill {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background-color: rgba(33, 150, 243, 0.4);
  border: 3px solid #2196f3;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  font-weight: bold;
  z-index: 3;
  animation: skill-rotate 3s linear infinite;
  box-shadow: 0 0 20px rgba(33, 150, 243, 0.5);
}

.skill-name {
  font-size: 1rem;
  text-shadow: 0 0 8px rgba(33, 150, 243, 0.7);
  color: white;
  text-align: center;
  padding: 0 10px;
  transform: rotate(-360deg);
  animation: counter-rotate 3s linear infinite;
}

.fusion-effect {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(33, 150, 243, 0.2) 0%, rgba(33, 150, 243, 0) 70%);
  z-index: 1;
  animation: fusion-pulse 3s ease-in-out infinite;
}

@keyframes tool-approach {
  0%, 100% {
    transform: translate(-50%, -50%) translateX(-100px);
    opacity: 1;
  }
  50% {
    transform: translate(-50%, -50%) translateX(0);
    opacity: 0.5;
  }
}

@keyframes target-approach {
  0%, 100% {
    transform: translate(50%, -50%) translateX(100px);
    opacity: 1;
  }
  50% {
    transform: translate(50%, -50%) translateX(0);
    opacity: 0.5;
  }
}

@keyframes skill-rotate {
  from {
    transform: translate(-50%, -50%) rotate(0deg);
  }
  to {
    transform: translate(-50%, -50%) rotate(360deg);
  }
}

@keyframes counter-rotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(-360deg);
  }
}

@keyframes fusion-pulse {
  0%, 100% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 0.3;
  }
  50% {
    transform: translate(-50%, -50%) scale(1.5);
    opacity: 0.6;
  }
}

.fusion-label {
  margin-top: 4px;
  font-size: 0.8rem;
  color: #aaa;
  text-align: center;
  text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
}

.processing-text {
  margin-top: 20px;
  color: #ddd;
  font-size: 1.1rem;
  text-align: center;
}

.small-spinner {
  width: 24px;
  height: 24px;
  border: 3px solid rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  border-top-color: #2196f3;
  animation: spin 1s ease-in-out infinite;
  margin-right: 10px;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Story state styles */
.story-content {
  display: flex;
  flex-direction: column;
  gap: 20px;
  min-height: 200px;
}

.loading-footer {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 20px;
  color: #aaa;
  font-size: 0.9rem;
}

/* Result state styles */
.result-content {
  width: 90%;
  max-width: 800px;
  max-height: 80vh;
  overflow-y: auto;
  color: #ddd;
  padding: 20px;
}

.results-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 16px;
  padding: 16px;
  background-color: rgba(0, 0, 0, 0.15);
  border-radius: 8px;
}

.result-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.item-label {
  font-size: 0.8rem;
  font-weight: 500;
  padding: 4px 8px;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.item-label.changed {
  background-color: rgba(33, 150, 243, 0.2);
  color: #2196f3;
}

.item-label.lost {
  background-color: rgba(255, 82, 82, 0.2);
  color: #ff5252;
}

.item-label.new {
  background-color: rgba(76, 175, 80, 0.2);
  color: #4caf50;
}

.item-container {
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  transition: transform 0.2s;
}

.item-container:hover {
  transform: scale(1.05);
}

.item-wrapper {
  width: 80px;
  height: 80px;
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 8px;
  transition: all 0.2s;
  background-color: rgba(0, 0, 0, 0.2);
}

.item-image {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.tool-section h3 {
  margin-bottom: 15px;
  color: #2196f3;
  font-size: 1.2rem;
}

.tool-used {
  margin-top: 5px;
  margin-bottom: 10px;
  font-size: 0.9rem;
  color: #aaa;
  display: flex;
  align-items: center;
  gap: 10px;
}

.tool-icon-container {
  width: 40px;
  height: 40px;
  border-radius: 6px;
  background-color: rgba(0, 0, 0, 0.3);
  border: 2px solid #2196f3;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 3px;
  box-shadow: 0 0 5px rgba(33, 150, 243, 0.3);
}

.tool-icon {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.tool-info {
  display: flex;
  flex-direction: column;
}

.tool-label {
  color: #2196f3;
  font-weight: bold;
}

.no-items {
  text-align: center;
  padding: 20px;
  color: #aaa;
  font-style: italic;
}

.appraisal-details {
  position: absolute;
  background-color: #1a1a1a;
  border-radius: 8px;
  width: 95%;
  height: 24%;
  top: 77%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 3;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
  border: 2px solid #333;
  padding: 15px;
}

.appraisal-header {
  position: absolute;
  top: 10px;
  right: 10px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.close-appraisal-button {
  background: none;
  border: none;
  color: #aaa;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 5px;
  line-height: 1;
  transition: color 0.2s;
}

.close-appraisal-button:hover {
  color: white;
}

/* Animation styles */
@keyframes pop-in {
  0% {
    transform: scale(0);
    opacity: 0;
  }
  70% {
    transform: scale(1.1);
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

.animate-in {
  animation: pop-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* Add animation delay based on item index */
.items-grid .item-container:nth-child(1) { animation-delay: 0.1s; }
.items-grid .item-container:nth-child(2) { animation-delay: 0.2s; }
.items-grid .item-container:nth-child(3) { animation-delay: 0.3s; }
.items-grid .item-container:nth-child(4) { animation-delay: 0.4s; }
.items-grid .item-container:nth-child(5) { animation-delay: 0.5s; }
.items-grid .item-container:nth-child(6) { animation-delay: 0.6s; }
.items-grid .item-container:nth-child(7) { animation-delay: 0.7s; }
.items-grid .item-container:nth-child(8) { animation-delay: 0.8s; }
.items-grid .item-container:nth-child(9) { animation-delay: 0.9s; }
.items-grid .item-container:nth-child(10) { animation-delay: 1.0s; }

@keyframes glow {
  0%, 100% {
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
  }
  50% {
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
  }
}

/* Remove old done button styles */
.done-button-container,
.done-button {
  display: none;
}

/* Add new close button styles */
.close-button {
  position: absolute;
  top: 12px;
  right: 12px;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.1);
  border: none;
  color: #ddd;
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  z-index: 2;
  padding: 0;
}

.close-button:hover {
  background-color: rgba(255, 255, 255, 0.2);
  transform: scale(1.1);
}

.close-button:active {
  transform: scale(0.95);
}

@keyframes legendary-glow {
  0%, 100% {
    box-shadow: 0 0 40px rgba(255, 215, 0, 0.5);
  }
  50% {
    box-shadow: 0 0 60px rgba(255, 215, 0, 0.8);
  }
}

@keyframes legendary-border {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

@keyframes glow {
  0%, 100% {
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
  }
  50% {
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
  }
}

.animate-in {
  animation: pop-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
}

@keyframes pop-in {
  0% {
    transform: scale(0);
    opacity: 0;
  }
  70% {
    transform: scale(1.1);
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

/* Add loading indicator styles */
.results-grid::after {
  content: '...';
  position: absolute;
  bottom: -30px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 24px;
  color: #ffd700;
  animation: loading-dots 1.5s infinite;
  opacity: 0;
}

.skill-result-dialog.processing .results-grid::after {
  opacity: 1;
}

@keyframes loading-dots {
  0%, 20% {
    content: '.';
  }
  40% {
    content: '..';
  }
  60%, 100% {
    content: '...';
  }
}

.story-text {
  line-height: 1.6;
  font-size: 1.1rem;
  color: #fff;
  white-space: pre-line;
  margin: 0;
}

.item-wrapper.placeholder {
  background-color: rgba(0, 0, 0, 0.2);
  border: 2px dashed #666;
  display: flex;
  justify-content: center;
  align-items: center;
}

.loading-dot {
  width: 12px;
  height: 12px;
  background-color: #666;
  border-radius: 50%;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    transform: scale(0.8);
    opacity: 0.5;
  }
  50% {
    transform: scale(1.2);
    opacity: 1;
  }
}
</style>


================================================
FILE: client/src/components/TutorialScreen.vue
================================================
<template>
  <div class="tutorial-screen" v-if="shouldShowTutorial">
    <div class="tutorial-content">      
      <div class="tutorial-grid">
        <div class="tutorial-card">
          <div class="tutorial-image ghost-image"></div>
          <div class="tutorial-tips">
            <h2>Movement & Interaction</h2>
            <ul>
              <li><span class="keycap">W</span><span class="keycap">A</span><span class="keycap">S</span><span class="keycap">D</span> keys to move around</li>
              <li><span class="keycap">E</span> key to interact</li>
              <li><span class="keycap">T</span> key to throw held items</li>
            </ul>
          </div>
        </div>

        <div class="tutorial-card">
          <div class="tutorial-image dispenser-image"></div>
          <div class="tutorial-tips">
            <h2>Discover discarded items</h2>
            <ul>
              <li>Use <span class="keycap">E</span> to interact with the red "PULL" lever</li>
              <li>Pick up items with <span class="keycap">E</span> and inspect them with <span class="keycap">I</span></li>
              <li>While carrying an item, use <span class="keycap">E</span> to put it in a chest or workbench</li>
            </ul>
          </div>
        </div>

        <div class="tutorial-card">
          <div class="tutorial-image workbench-image"></div>
          <div class="tutorial-tips">
            <h2>Craft at the workbench</h2>
            <ul>
              <li>Carry an item to the workbench, then use <span class="keycap">E</span> to place it</li>
              <li>Drag items up to the tool wall or down to the working area</li>
              <li>Click an item on the tool wall to cast one of it's quirks</li>
              <li>Click targets for the quirk, down in the working area</li>
            </ul>
          </div>
        </div>

        <div class="tutorial-card">
          <div class="tutorial-image shopkeeper-image"></div>
          <div class="tutorial-tips">
            <h2>Sell your creations</h2>
            <ul>
              <li>Throw items out of the door to the shop keeper</li>
              <li>The shop keeper pays more for fun, unusual, and rare items</li>
              <li>Check the computer to buy items from other shops</li>
              <li>Not ready to sell? Store your treasures in the chest</li>
            </ul>
          </div>
        </div>
      </div>

      <button class="close-button" @click="closeTutorial">Got it!</button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useGameStore } from '../stores/game'

const emit = defineEmits<{
  (e: 'close'): void
}>()

const gameStore = useGameStore()
const isTutorialClosed = ref(false)

// Get all relevant inventories
const mainInventory = gameStore.useInventory('main')
const chestInventory = gameStore.useInventory('chest1')
const workbenchWorkingInventory = gameStore.useInventory('workbench-working')
const workbenchToolsInventory = gameStore.useInventory('workbench-tools')

// Check if all inventories are empty
const areAllInventoriesEmpty = computed(() => {
  return mainInventory.value.length === 0 &&
    chestInventory.value.length === 0 &&
    workbenchWorkingInventory.value.length === 0 &&
    workbenchToolsInventory.value.length === 0
})

// Only show tutorial if all inventories are empty and tutorial hasn't been closed
const shouldShowTutorial = computed(() => {
  return areAllInventoriesEmpty.value && !isTutorialClosed.value
})

const closeTutorial = () => {
  isTutorialClosed.value = true
  emit('close')
}
</script>

<style scoped>
.tutorial-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: rgba(0, 0, 0, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}

.tutorial-content {
  text-align: left;
  color: white;
  padding: min(1.5vw, 15px);
  border-radius: 8px;
  background-color: rgba(0, 0, 0, 0.7);
  max-width: 1024px;
  max-height: 90vh;
  overflow-y: auto;
  width: min(90vw, 1024px);
}

h1 {
  text-align: center;
  margin-bottom: min(2vw, 20px);
  font-size: min(3vw, 30px);
  color: #4CAF50;
}

.tutorial-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: min(1vw, 10px);
  margin-bottom: min(1.5vw, 15px);
}

.tutorial-card {
  background-color: rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  padding: min(0.75vw, 8px);
  display: flex;
  flex-direction: column;
  gap: min(0.75vw, 8px);
}

.tutorial-image {
  width: 100%;
  height: min(20vw, 200px);
  background-size: contain;
  background-position: center;
  background-repeat: no-repeat;
  border-radius: 4px;
}

.ghost-image {
  background-image: url('@/assets/tutorial/ghost.png');
}

.dispenser-image {
  background-image: url('@/assets/tutorial/dispenser.png');
}

.workbench-image {
  background-image: url('@/assets/tutorial/workbench.png');
}

.shopkeeper-image {
  background-image: url('@/assets/tutorial/shopkeeper.png');
}

.tutorial-tips {
  flex: 1;
}

h2 {
  color: #4CAF50;
  margin: 0 0 min(0.5vw, 5px) 0;
  font-size: min(2vw, 20px);
}

ul {
  list-style-type: none;
  padding-left: min(0.75vw, 8px);
  margin: 0;
}

li {
  margin: min(0.35vw, 4px) 0;
  line-height: 1.3;
  font-size: min(1.5vw, 15px);
}

.close-button {
  display: block;
  margin: min(1.5vw, 15px) auto 0;
  padding: min(0.6vw, 6px) min(1.75vw, 18px);
  font-size: min(1.5vw, 15px);
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.close-button:hover {
  background-color: #45a049;
}

.keycap {
  display: inline-block;
  padding: min(0.2vw, 2px) min(0.6vw, 6px);
  margin: 0 min(0.2vw, 2px);
  background: #2c2c2c;
  border: 1px solid #4a4a4a;
  border-radius: 4px;
  box-shadow: 0 2px 0 #1a1a1a;
  font-family: monospace;
  font-weight: bold;
  color: #e0e0e0;
  text-transform: uppercase;
  font-size: min(1.2vw, 12px);
  line-height: 1;
  min-width: 1.2em;
  text-align: center;
}
</style>


================================================
FILE: client/src/components/Wall.vue
================================================
<script setup lang="ts">
import { useGameStore } from '../stores/game';

defineProps<{
  row: number;
  col: number;
  tileSize: number;
  width: number;
  depth: number;
  height: number;
}>();

const gameStore = useGameStore();
</script>

<template>
  <div :style="{
    position: 'absolute',
    top: `${row * tileSize}px`,
    left: `${col * tileSize}px`,
    width: `${width * tileSize}px`,
    height: `${depth * tileSize}px`,
    border: gameStore.debug ? '1px solid red': 'none',
  }">
    <!-- Height visualization line (only visible in debug mode) -->
    <div v-if="gameStore.debug" class="height-line" :style="{
      position: 'absolute',
      left: '0',
      bottom: '0',
      width: '2px',
      height: `${height * tileSize}px`,
      backgroundColor: 'blue',
      zIndex: 1000
    }" />
  </div>
</template>


================================================
FILE: client/src/components/Workbench.vue
================================================
<script setup lang="ts">
import workbenchImage from '../assets/workbench.png';
import workbenchZoomImage from '../assets/workbench-zoom.png';
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { useGameStore } from '../stores/game';
import WorkbenchFullscreen from './WorkbenchFullscreen.vue';
import { getRarityClass } from '../utils/items';
import GameItem from './GameItem.vue';

const props = defineProps<{
  row: number;
  col: number;
  tileSize: number;
  width: number;
  depth: number;
  height: number;
  playerIsNear: boolean;
}>();

const gameStore = useGameStore();
const showFullscreen = ref(false);

// Define inventory names
const workingInventoryName = "workbench-working";
const toolsInventoryName = "workbench-tools";

// Use the inventory system to get reactive references to the inventories
const workingInventoryIds = gameStore.useInventory(workingInventoryName);
const toolsInventoryIds = gameStore.useInventory(toolsInventoryName);

// Add maxCapacity constants for both inventories
const workingMaxCapacity = 5;
const toolsMaxCapacity = 32;

// Create computed properties for the actual inventory items
const workingInventory = computed(() => {
  return workingInventoryIds.value.map(id => gameStore.useItem(id).value);
});

const toolsInventory = computed(() => {
  return toolsInventoryIds.value.map(id => gameStore.useItem(id).value);
});

// Create computed properties for capacity
const workingUsedCapacity = computed(() => {
  return workingInventory.value.length;
});

// Computed property for working inventory capacity dots
const workingCapacityDots = computed(() => {
  const dots = [];
  
  // Fill dots with items that exist in inventory
  for (let i = 0; i < Math.min(workingInventory.value.length, workingMaxCapacity); i++) {
    const item = workingInventory.value[i];
    if (!item) {
      continue;
    }
    const rarityClass = getRarityClass(item.value);
    dots.push({
      filled: true,
      rarityClass
    });
  }
  
  // Fill remaining dots as empty
  for (let i = workingInventory.value.length; i < workingMaxCapacity; i++) {
    dots.push({
      filled: false,
      rarityClass: 'empty'
    });
  }
  
  return dots;
});

// Computed property for tools inventory capacity dots
const toolsCapacityDots = computed(() => {
  const dots = [];
  
  // Fill dots with items that exist in inventory
  for (let i = 0; i < Math.min(toolsInventory.value.length, toolsMaxCapacity); i++) {
    const item = toolsInventory.value[i];
    if (!item) {
      continue;
    }
    const rarityClass = getRarityClass(item.value);
    dots.push({
      filled: true,
      rarityClass
    });
  }
  
  // Fill remaining dots as empty
  for (let i = toolsInventory.value.length; i < toolsMaxCapacity; i++) {
    dots.push({
      filled: false,
      rarityClass: 'empty'
    });
  }
  
  return dots;
});

function handlePlayerInteraction() {
  if (!props.playerIsNear) {
    return;
  }

  if (!gameStore.heldItemId) {
    showFullscreen.value = true;
    gameStore.emitEvent('clean-workbench-results');
    return;
  }
  
  // Check if player is holding an item
  if (gameStore.heldItemId) {
    // Check if the working inventory is full before adding the item
    if (workingUsedCapacity.value >= workingMaxCapacity) {
      // Working inventory is full, emit drop-item event and open workbench without adding item
      gameStore.emitEvent('drop-item', { itemId: gameStore.heldItemId });
      showFullscreen.value = true;
      return;
    }
    
    // Working inventory has space, move the held item to the working inventory using the inventory system
    gameStore.moveItemToInventory(gameStore.heldItemId, workingInventoryName);
    
    // Remove the held item
    gameStore.heldItemId = null;
    showFullscreen.value = true;
    gameStore.emitEvent('clean-workbench-results');
  }
}

// Define constants for overflow item physics
const OVERFLOW_IMPULSE = 5; // Lower impulse than throwing

/**
 * Handle workbench overflow item event
 * Spawns an item below the workbench when triggered
 */
function handleWorkbenchOverflowItem(data: { itemId: string }) {
  if (!data.itemId) return;
  
  const item = gameStore.useItem(data.itemId).value;
  if (!item) return;

  // Add the item back to the game world at a position below the workbench
  // with appropriate physics settings
  gameStore.addObject({
    id: data.itemId,
    type: GameItem,
    row: props.row + props.depth, // Position below the workbench
    col: props.col + props.width / 2, // Center horizontally
    interactive: true,
    width: 1,
    depth: 1,
    props: {
      itemId: data.itemId,
      pickedUp: true
    },
    physics: {
      active: true,
      angle: 90, // Drop downward
      velocity: OVERFLOW_IMPULSE,
      friction: 2,
      height: 2, // Start a bit above ground
      verticalVelocity: 0,
      bounceStrength: 0.3,
      mass: 1.0
    }
  });
}

let interactionListenerId: string;
let overflowItemListenerId: string;

onMounted(() => {
  interactionListenerId = gameStore.addEventListener('player-interaction', handlePlayerInteraction);
  overflowItemListenerId = gameStore.addEventListener('workbench-overflow-item', handleWorkbenchOverflowItem);
});

onUnmounted(() => {
  gameStore.removeEventListener('player-interaction', interactionListenerId);
  gameStore.removeEventListener('workbench-overflow-item', overflowItemListenerId);
});

const closeFullscreen = () => {
  showFullscreen.value = false;
};
</script>

<template>
  <div>
    <!-- Regular workbench view -->
    <div :style="{
      position: 'absolute',
      top: `${row * tileSize}px`,
      left: `${col * tileSize}px`,
      width: `${width * tileSize}px`,
      height: `${depth * tileSize}px`,
      border: gameStore.debug ? '1px solid red': 'none'
    }">
      <div v-if="playerIsNear" class="interact-prompt">E</div>
      <img 
        :src="workbenchImage" 
        :width="width * tileSize" 
        :height="depth * tileSize"
        :class="['workbench', { 'workbench-active': playerIsNear }]"
        alt="Workbench"
      />
      
      <!-- Capacity display as grid of dots for working inventory -->
      <div v-if="playerIsNear" class="capacity-grid working-grid">
        <div 
          v-for="(dot, index) in workingCapacityDots" 
          :key="'working-'+index" 
          class="capacity-dot"
          :class="[dot.rarityClass]"
        ></div>
      </div>
      
      <!-- Capacity display as grid of dots for tools inventory -->
      <div v-if="playerIsNear" class="capacity-grid tools-grid">
        <div 
          v-for="(dot, index) in toolsCapacityDots" 
          :key="'tools-'+index" 
          class="capacity-dot"
          :class="[dot.rarityClass]"
        ></div>
      </div>
      
      <!-- Height visualization line (only visible in debug mode) -->
      <div v-if="gameStore.debug" class="height-line" :style="{
        position: 'absolute',
        left: '0',
        bottom: '0',
        width: '2px',
        height: `${height * tileSize}px`,
        backgroundColor: 'blue',
        zIndex: 1000
      }" />
    </div>

    <WorkbenchFullscreen
      :show="showFullscreen"
      :workbench-image="workbenchZoomImage"
      :tools-items="toolsInventory"
      :working-items="workingInventory"
      @close="closeFullscreen"
    />
  </div>
</template>

<style scoped>
.workbench {
  filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.5));
  object-fit: contain;
  transition: filter 0.3s ease;
}

.workbench-active {
  filter: drop-shadow(0 0 15px white);
}

.interact-prompt {
  position: absolute;
  top: calc(-1.1 * v-bind(tileSize) * 1px);
  left: 50%;
  transform: translateX(-50%);
  font-size: calc(0.5 * v-bind(tileSize) * 1px);
  font-weight: bold;
  color: white;
  text-shadow: 0 0 5px white;
  animation: pulse 1s infinite;
  background-color: black;
  padding: calc(0.1 * v-bind(tileSize) * 1px) calc(0.1 * v-bind(tileSize) * 1px);
  border-radius: calc(0.08 * v-bind(tileSize) * 1px);
  z-index: 1;
  line-height: 1;
}

.capacity-grid {
  position: absolute;
  display: grid;
  gap: calc(0.05 * v-bind(tileSize) * 1px);
}

.working-grid {
  top: 60%;
  left: 50%;
  transform: translateX(-50%);
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: 1fr;
  width: calc(1.5 * v-bind(tileSize) * 1px);
}

.tools-grid {
  top: 8%;
  left: 14%;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(4, 1fr);
  width: calc(1.9 * v-bind(tileSize) * 1px);
  row-gap: calc(.2 * v-bind(tileSize) * 1px);
}

.capacity-dot {
  width: calc(0.08 * v-bind(tileSize) * 1px);
  height: calc(0.08 * v-bind(tileSize) * 1px);
  border-radius: 50%;
  box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
}

.working-grid .capacity-dot {
  width: calc(0.13 * v-bind(tileSize) * 1px);
  height: calc(0.13 * v-bind(tileSize) * 1px);
}

/* Dot colors based on item rarity */
.capacity-dot.empty {
  background-color: rgba(255, 255, 255, 0.3);
}

.capacity-dot.item-common {
  background-color: #ffffff;
}

.capacity-dot.item-uncommon {
  background-color: #4caf50;
}

.capacity-dot.item-rare {
  background-color: #2196f3;
}

.capacity-dot.item-epic {
  background-color: #9c27b0;
}

.capacity-dot.item-legendary {
  background-color: #ff9800;
  box-shadow: 0 0 4px rgba(255, 152, 0, 0.8);
}

@keyframes pulse {
  0% { opacity: 0.5; }
  50% { opacity: 1; }
  100% { opacity: 0.5; }
}
</style>


================================================
FILE: client/src/components/WorkbenchFullscreen.vue
================================================
<script setup lang="ts">
import { onMounted, onUnmounted, watch, ref, computed } from 'vue';
import { useGameStore } from '../stores/game';
import { getRarityClass } from '../utils/items';
import ItemPreview from './ItemPreview.vue';
import { useEscapeKeyHandler } from '../composables/useEscapeKeyHandler';

const gameStore = useGameStore();
const props = defineProps<{
  show: boolean;
  workbenchImage: string;
  toolsItems?: any[];
  workingItems?: any[];
}>();

const emit = defineEmits<{
  (e: 'close'): void;
}>();

const hoveredItem = ref<any>(null);
const hoveredItemPosition = ref({ x: 0, y: 0 });
const draggedItem = ref<any>(null);
const dropTarget = ref<'tools' | 'working' | null>(null);
const dropTargetFull = ref<'tools' | 'working' | null>(null);
const selectedToolItem = ref<any>(null);
const selectedSkill = ref<any>(null);
const selectedTargets = ref<any[]>([]);
const mousePosition = ref({ x: 0, y: 0 });
const showSkillsDropdown = ref(false);
const skillsDropdownPosition = ref({ x: 0, y: 0 });

const isToolGridEmpty = computed(() => !props.toolsItems?.length);

const selectedToolSkills = computed(() => {
  if (!selectedToolItem.value || !selectedToolItem.value.skills) {
    return [];
  }
  return selectedToolItem.value.skills;
});

const positionSkillsDropdown = (event: MouseEvent) => {
  const target = event.currentTarget as HTMLElement;
  if (target) {
    const rect = target.getBoundingClientRect();
    skillsDropdownPosition.value = {
      x: rect.left + rect.width / 2,
      y: rect.bottom + 10
    };
  }
};

const handleItemClick = (item: any, sourceArea: 'tools' | 'working', event?: MouseEvent) => {
  hoveredItem.value = null;

  if (sourceArea === 'tools') {
    handleToolItemClick(item, event);
    return;
  }

  if (selectedSkill.value) {
    handleSkillTargetSelection(item);
    return;
  }

  moveItemToMainInventory(item);
};

const handleToolItemClick = (item: any, event?: MouseEvent) => {
  if (selectedToolItem.value === item) {
    showSkillsDropdown.value = !showSkillsDropdown.value;

    if (showSkillsDropdown.value && event) {
      positionSkillsDropdown(event);
    }
    return;
  }

  selectedToolItem.value = item;
  selectedSkill.value = null; // Clear skill when switching tools to prevent confusion
  showSkillsDropdown.value = true;

  if (event) {
    positionSkillsDropdown(event);
  }
};

const handleSkillTargetSelection = (item: any) => {
  const isAlreadySelected = selectedTargets.value.some(target => target.id === item.id);

  if (isAlreadySelected) {
    selectedTargets.value = selectedTargets.value.filter(target => target.id !== item.id);
    return;
  }

  selectedTargets.value.push(item);

  if (selectedTargets.value.length < selectedSkill.value.targets) {
    return;
  }

  const toolSkillIndex = selectedToolItem.value.skills.findIndex(
    (s: any) => s === selectedSkill.value
  );

  if (toolSkillIndex === -1) {
    console.error('Selected skill not found in tool skills');
    return;
  }

  gameStore.emitEvent('skill-invoked', {
    skill: selectedSkill.value,
    tool: selectedToolItem.value,
    targets: selectedTargets.value
  });

  gameStore.useSkill(
    selectedToolItem.value.id,
    toolSkillIndex,
    selectedTargets.value.map(target => target.id)
  );

  selectedSkill.value = null;
  selectedTargets.value = [];
};

const moveItemToMainInventory = (item: any) => {
  const targetInventory = `${gameStore.userId}:main`;

  // One-time listener to handle post-move actions
  const listenerId = gameStore.addEventListener('item-moved', (data) => {
    if (data && data.itemId === item.id && data.targetInventoryId === targetInventory) {
      gameStore.removeEventListener('item-moved', listenerId);
      emit('close');

      gameStore.emitEvent('item-pickup', {
        id: data.itemId
      });
    }
  });

  gameStore.moveItem(item.id, targetInventory);
};

const handleSkillClick = (skill: any, event: MouseEvent) => {
  if (selectedSkill.value === skill) {
    selectedSkill.value = null;
    selectedTargets.value = [];
    return;
  }

  // Skills with invalid target counts default to self-targeting
  if (!skill.targets || typeof skill.targets !== 'number' || skill.targets < 0 || skill.targets > 2) {
    handleSelfTargetingSkill(skill);
    return;
  }

  selectedSkill.value = skill;
  selectedTargets.value = [];

  mousePosition.value = {
    x: event.clientX,
    y: event.clientY
  };

  showSkillsDropdown.value = false;
};

const handleSelfTargetingSkill = (skill: any) => {
  const toolSkillIndex = selectedToolItem.value.skills.findIndex(
    (s: any) => s === skill
  );

  if (toolSkillIndex === -1) {
    console.error('Selected skill not found in tool skills');
    return;
  }

  gameStore.emitEvent('skill-invoked', {
    skill: skill,
    tool: selectedToolItem.value,
    target: selectedToolItem.value // Tool targets itself for self-skills
  });

  gameStore.useSkill(
    selectedToolItem.value.id,
    toolSkillIndex,
    [] // Self-targeting requires no target IDs
  );

  showSkillsDropdown.value = false;
};

const handleItemMouseEnter = (event: MouseEvent, item: any) => {
  hoveredItem.value = item;

  const target = event.currentTarget as HTMLElement;
  if (!target) {
    return;
  }

  const rect = target.getBoundingClientRect();
  const tooltipWidth = 600;
  const tooltipHeight = 400;

  hoveredItemPosition.value = {
    x: rect.left - (tooltipWidth / 2) - 10,
    y: rect.bottom + 10
  };

  adjustTooltipPosition(tooltipWidth, tooltipHeight, rect);
};

// Prevents tooltip from rendering outside viewport bounds
const adjustTooltipPosition = (tooltipWidth: number, tooltipHeight: number, rect: DOMRect) => {
  if (hoveredItemPosition.value.x + tooltipWidth > window.innerWidth) {
    hoveredItemPosition.value.x = window.innerWidth - tooltipWidth - 10;
  }

  if (hoveredItemPosition.value.x < 0) {
    hoveredItemPosition.value.x = 10;
  }

  if (hoveredItemPosition.value.y + tooltipHeight > window.innerHeight) {
    hoveredItemPosition.value.y = rect.top - tooltipHeight - 10;
  }
};

const handleItemMouseLeave = () => {
  hoveredItem.value = null;
};

const handleDragStart = (event: DragEvent, item: any, sourceArea: 'tools' | 'working') => {
  if (!item) return;

  draggedItem.value = { ...item, sourceArea };

  if (event.dataTransfer) {
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', item.id);
  }

  // Clean up UI state during drag
  hoveredItem.value = null;
  showSkillsDropdown.value = false;
  selectedSkill.value = null;
};

const handleDragEvent = (event: DragEvent, targetArea: 'tools' | 'working') => {
  event.preventDefault();

  // Check if target area is at capacity
  const currentCount = targetArea === 'tools'
    ? (props.toolsItems?.length || 0)
    : (props.workingItems?.length || 0);
  const maxCapacity = targetArea === 'tools' ? 32 : 5;

  // Don't allow drop if at capacity and item is coming from different area
  if (draggedItem.value && draggedItem.value.sourceArea !== targetArea && currentCount >= maxCapacity) {
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = 'none';
    }
    dropTarget.value = null;
    dropTargetFull.value = targetArea;
    return;
  }

  if (event.type === 'dragover' && event.dataTransfer) {
    event.dataTransfer.dropEffect = 'move';
  }

  dropTarget.value = targetArea;
  dropTargetFull.value = null;
};

const handleDragLeave = () => {
  dropTarget.value = null;
  dropTargetFull.value = null;
};

const handleDrop = (event: DragEvent, targetArea: 'tools' | 'working') => {
  event.preventDefault();
  dropTarget.value = null;
  dropTargetFull.value = null;

  if (!draggedItem.value || draggedItem.value.sourceArea === targetArea) {
    draggedItem.value = null;
    return;
  }

  // Check capacity limits before allowing drop
  const currentCount = targetArea === 'tools'
    ? (props.toolsItems?.length || 0)
    : (props.workingItems?.length || 0);
  const maxCapacity = targetArea === 'tools' ? 32 : 5;

  if (currentCount >= maxCapacity) {
    draggedItem.value = null;
    return;
  }

  const targetInventoryId = targetArea === 'tools'
    ? `${gameStore.userId}:workbench-tools`
    : `${gameStore.userId}:workbench-working`;

  gameStore.moveItem(draggedItem.value.id, targetInventoryId);
  draggedItem.value = null;
};

// Escape key handler with priority: skill > dropdown > close workbench
useEscapeKeyHandler('workbench-fullscreen', (event) => {
  if (event.key === 'Escape' && props.show) {
    if (selectedSkill.value) {
      selectedSkill.value = null;
      return true;
    }

    if (showSkillsDropdown.value) {
      showSkillsDropdown.value = false;
      return true;
    }

    emit('close');
    return true;
  }
  return false;
});

const handleMouseMove = (e: MouseEvent) => {
  if (selectedSkill.value) {
    mousePosition.value = {
      x: e.clientX,
      y: e.clientY
    };
  }
};

const handleClickOutside = (e: MouseEvent) => {
  if (showSkillsDropdown.value) {
    const dropdown = document.querySelector('.skills-dropdown');
    const toolItems = document.querySelectorAll('.inventory-slot.selected');

    let clickedOnTool = false;
    toolItems.forEach(tool => {
      if (tool.contains(e.target as Node)) {
        clickedOnTool = true;
      }
    });

    if (dropdown && !dropdown.contains(e.target as Node) && !clickedOnTool) {
      showSkillsDropdown.value = false;
    }
  }
};

const handleContextMenu = (e: MouseEvent) => {
  if (selectedSkill.value) {
    e.preventDefault(); // Prevent browser context menu when canceling skill
    selectedSkill.value = null;
    selectedTargets.value = [];
  }
};

onMounted(() => {
  window.addEventListener('mousemove', handleMouseMove);
  window.addEventListener('click', handleClickOutside);
  window.addEventListener('contextmenu', handleContextMenu);
});

onUnmounted(() => {
  window.removeEventListener('mousemove', handleMouseMove);
  window.removeEventListener('click', handleClickOutside);
  window.removeEventListener('contextmenu', handleContextMenu);
});

watch(() => props.show, (newValue) => {
  if (newValue) {
    gameStore.pushFocus('workbench-fullscreen');
  } else {
    gameStore.popFocus();
  }
});
</script>

<template>
  <div v-if="show" class="fullscreen-overlay">
    <div class="workbench-container" :style="{ backgroundImage: `url(${workbenchImage})` }">
      <button class="close-button" @click="$emit('close')">Back</button>

      <!-- Item Preview Component -->
      <ItemPreview v-if="hoveredItem" :item="hoveredItem" position="fixed" :style="{
        left: hoveredItemPosition.x + 'px',
        top: hoveredItemPosition.y + 'px',
        maxHeight: '80vh',
        overflowY: 'auto'
      }" />

      <div class="tool-area" @dragover="handleDragEvent($event, 'tools')" @dragenter="handleDragEvent($event, 'tools')"
        @dragleave="handleDragLeave" @drop="handleDrop($event, 'tools')"
        :class="{ 'drop-target': dropTarget === 'tools', 'drop-target-full': dropTargetFull === 'tools' }">
        <div class="tool-grid">
          <div class="inventory-slot" :class="{ 'has-item': item, 'selected': selectedToolItem === item }"
            v-for="(item, index) in toolsItems" :key="item ? item.id : 'tool-' + index"
            @click="item && handleItemClick(item, 'tools', $event)"
            @mouseenter="item && handleItemMouseEnter($event, item)" @mouseleave="handleItemMouseLeave"
            :draggable="!!item" @dragstart="item && handleDragStart($event, item, 'tools')">
            <div v-if="item" class="item-container" :class="getRarityClass(item.value)">
              <img :src="item.imageUrl" class="item-image" :alt="item.name" />
            </div>
          </div>
          <!-- Add empty slots to fill the grid if needed -->
          <div class="inventory-slot" v-for="n in Math.max(0, 32 - (toolsItems ? toolsItems.length : 0))"
            :key="'empty-' + n"></div>

          <!-- Empty grid prompt message -->
          <div v-if="isToolGridEmpty" class="empty-grid-prompt">
            Drag an item here to use as a tool
          </div>
          
          <!-- Full area indicator -->
          <div v-if="dropTargetFull === 'tools'" class="full-area-prompt">
            Tool area is full (32/32)
          </div>
        </div>
      </div>

      <!-- Skills Dropdown - Show when a tool is selected and dropdown is toggled -->
      <div v-if="showSkillsDropdown && selectedToolItem && selectedToolSkills.length > 0" class="skills-dropdown"
        :style="{
          left: `${skillsDropdownPosition.x}px`,
          top: `${skillsDropdownPosition.y}px`
        }">
        <div class="skills-container">
          <button v-for="(skill, index) in selectedToolSkills" :key="index" class="skill-button"
            @click="handleSkillClick(skill, $event)">
            <div class="skill-button-content">
              <div class="skill-icon">
                <img :src="selectedToolItem.imageUrl" class="tool-icon-image" :alt="selectedToolItem.name" />
              </div>
              <div class="skill-text">
                <div class="skill-header">
                  <div class="skill-name">{{ skill.name }}</div>
                  <div class="skill-targets">
                    <span class="target-tag">
                      {{ typeof skill.targets === 'number' && skill.targets >= 0 && skill.targets <= 2 ?
                        (skill.targets === 0 ? 'Self' : skill.targets === 1 ? '1 Target' : '2 Targets') : 'Self' }} </span>
                  </div>
                </div>
                <div class="skill-description">{{ skill.description }}</div>
              </div>
            </div>
          </button>
        </div>
      </div>

      <!-- Working Area -->
      <div class="working-area" @dragover="handleDragEvent($event, 'working')"
        @dragenter="handleDragEvent($event, 'working')" @dragleave="handleDragLeave"
        @drop="handleDrop($event, 'working')" :class="{ 'drop-target': dropTarget === 'working', 'drop-target-full': dropTargetFull === 'working' }">
        <div class="working-grid">
          <div class="inventory-slot working-slot" :class="{
            'has-item': item,
            'selected-target': selectedTargets.some(target => target.id === item?.id)
          }" v-for="(item, index) in workingItems" :key="item ? item.id : 'working-' + index"
            @click="item && handleItemClick(item, 'working')" @mouseenter="item && handleItemMouseEnter($event, item)"
            @mouseleave="handleItemMouseLeave" :draggable="!!item"
            @dragstart="item && handleDragStart($event, item, 'working')">
            <div v-if="item" class="item-container" :class="getRarityClass(item.value)">
              <img :src="item.imageUrl" class="item-image" :alt="item.name" />
            </div>
          </div>
          <!-- Add empty slots to fill the grid if needed -->
          <div class="inventory-slot working-slot"
            v-for="n in Math.max(0, 5 - (workingItems ? workingItems.length : 0))" :key="'empty-working-' + n"></div>
        </div>
        
        <!-- Full area indicator -->
        <div v-if="dropTargetFull === 'working'" class="full-area-prompt">
          Working area is full (5/5)
        </div>
      </div>

    </div>

    <!-- Skill cursor that follows the mouse when a skill is selected -->
    <div v-if="selectedSkill" class="skill-cursor"
      :style="{ left: `${mousePosition.x}px`, top: `${mousePosition.y}px` }">
      <div class="skill-cursor-icon">
        <img :src="selectedToolItem?.imageUrl" class="tool-icon-image" :alt="selectedToolItem?.name" />
      </div>
      <div class="skill-cursor-name">{{ selectedSkill.name }}</div>
    </div>
  </div>
</template>

<style scoped>
.fullscreen-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.workbench-container {
  position: relative;
  width: min(90vh, 90vw);
  /* Use the smaller of viewport width or height */
  height: min(90vh, 90vw);
  /* Match width to maintain square ratio */
  max-width: min(90vh, 1200px);
  max-height: min(90vh, 1200px);
  margin: auto;
  background-size: contain;
  background-position: center;
  background-repeat: no-repeat;
  display: flex;
  justify-content: center;
  align-items: top;
  padding-top: 8%;
}

.close-button {
  position: absolute;
  top: 5%;
  left: 0px;
  margin-right: 5%;
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  height: 50px;
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: 10%;
  transition: background-color 0.3s;
  padding: 1%;
  z-index: 20;
}

.close-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.tool-area {
  position: absolute;
  width: 61%;
  height: 31.5%;
  top: 10.5%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
}

.tool-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(4, 1fr);
  gap: 5px;
  width: 100%;
  height: 100%;
}

/* Working area in the lower half of the workbench */
.working-area {
  position: absolute;
  width: 60%;
  height: 11%;
  bottom: 35%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
}

.working-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: 1fr;
  gap: 10px;
  width: 100%;
  height: 100%;
}

.inventory-slot {
  background: transparent;
  border: 3px dashed rgb(113, 67, 31);
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: normal;
  color: rgba(255, 255, 255, 0.5);
  font-size: 0.9em;
  transition: border-color 0.3s, background-color 0.3s;
  position: relative;
}

.tool-grid .inventory-slot {
  border: none;
}

.working-slot {
  /* Working slots already have the dashed border from .inventory-slot */
  cursor: grab;
}

.drop-target {
  outline: 2px solid rgba(255, 215, 0, 0.7);
  background-color: rgba(255, 215, 0, 0.1);
  border-radius: 8px;
}

.drop-target-full {
  outline: 2px solid rgba(255, 0, 0, 0.7);
  background-color: rgba(255, 0, 0, 0.1);
  border-radius: 8px;
}

.inventory-slot[draggable=true] {
  cursor: grab;
}

.inventory-slot[draggable=true]:active {
  cursor: grabbing;
}

.inventory-slot.has-item {
  border: none;
  overflow: hidden;
  border-radius: 6px;
}

.inventory-slot.has-item:hover .item-container {
  transform: scale(1.05);
  cursor: pointer;
}

.inventory-slot:hover {
  border-color: rgb(173, 127, 91);
  background-color: rgba(113, 67, 31, 0.2);
}

.item-container {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: 6px;
  overflow: hidden;
}

.item-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

.empty-grid-prompt {
  position: absolute;
  display: inline-block;
  padding: 12px 15px;
  color: rgba(255, 255, 255, 0.6);
  font-size: 1.2em;
  text-align: center;
  pointer-events: none;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
  z-index: 5;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: auto;
  height: auto;
}

.full-area-prompt {
  position: absolute;
  display: inline-block;
  padding: 12px 15px;
  color: rgba(255, 255, 255, 0.9);
  font-size: 1.2em;
  text-align: center;
  pointer-events: none;
  background-color: rgba(255, 0, 0, 0.3);
  border: 2px solid rgba(255, 0, 0, 0.7);
  border-radius: 8px;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
  z-index: 15;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: auto;
  height: auto;
  font-weight: bold;
}

/* Selected tool styling */
.inventory-slot.selected {
  z-index: 15;
}

/* Skills dropdown styling */
.skills-dropdown {
  position: fixed;
  transform: translateX(-50%);
  /* Center horizontally relative to position */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 100;
  filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5));
}

.skills-dropdown:before {
  content: '';
  position: absolute;
  top: -9px;
  left: 50%;
  transform: translateX(-50%);
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 10px solid rgba(0, 0, 0, 0.7);
}

.skills-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-width: 300px;
  max-height: 300px;
  overflow-y: auto;
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.7);
  border-radius: 8px;
  border: 1px solid rgba(113, 67, 31, 0.8);
}

.skill-button {
  padding: 2px 5px;
  border-radius: 6px;
  border: none;
  background-color: rgba(50, 50, 50, 0.8);
  color: white;
  font-size: 0.9em;
  cursor: pointer;
  transition: all 0.2s ease;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
  text-align: left;
  width: 100%;
  max-width: 280px;
}

.skill-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.skill-button-content {
  display: flex;
  flex-direction: row;
  align-items: center;
}

.skill-icon {
  margin-right: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  min-width: 24px;
  overflow: hidden;
  border-radius: 4px;
}

.tool-icon-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.skill-text {
  display: flex;
  flex-direction: column;
  flex: 1;
}

.skill-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}

.skill-name {
  font-weight: bold;
  font-size: 0.95em;
}

.skill-targets {
  display: flex;
  align-items: center;
}

.target-tag {
  font-size: 0.65rem;
  padding: 1px 4px;
  border-radius: 8px;
  font-weight: bold;
  background-color: #607d8b;
  color: white;
  white-space: nowrap;
  display: inline-block;
}

.skill-description {
  font-size: 0.8em;
  opacity: 0.9;
  line-height: 1.3;
}

/* Skill cursor styling */
.skill-cursor {
  position: fixed;
  pointer-events: none;
  /* Allow clicking through the cursor */
  z-index: 2000;
  display: flex;
  align-items: center;
  transform: translate(-50%, -50%);
  /* Center on cursor */
  background-color: rgba(0, 0, 0, 0.7);
  border-radius: 12px;
  padding: 5px 10px;
}

.skill-cursor-icon {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  overflow: hidden;
  margin-right: 8px;
}

.skill-cursor-name {
  color: white;
  font-size: 0.9em;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
}

/* Add styles for selected targets */
.inventory-slot.selected-target {
  outline: 2px solid #4caf50;
  outline-offset: 2px;
}

.inventory-slot.selected-target .item-container {
  transform: scale(1.05);
}
</style>


================================================
FILE: client/src/composables/useEscapeKeyHandler.ts
================================================
import { onMounted, onUnmounted } from 'vue';
import { useGameStore } from '../stores/game';

export function useEscapeKeyHandler(componentId: string, customKeyDownHandler?: (event: KeyboardEvent) => boolean) {
  const gameStore = useGameStore();

  function handleKeyDown(event: KeyboardEvent) {
    if (event.key === 'Escape' && gameStore.hasFocus(componentId)) {
      // If a custom handler is provided, use it
      if (customKeyDownHandler) {
        return customKeyDownHandler(event);
      }
      return true; // Return true if the event was handled
    }
    return false;
  }

  function handleGainedFocus() {
    window.addEventListener('keydown', handleKeyDown);
  }

  function handleLostFocus() {
    window.removeEventListener('keydown', handleKeyDown);
  }

  let gainedFocusListenerId: string;
  let lostFocusListenerId: string;

  onMounted(() => {
    gainedFocusListenerId = gameStore.addEventListener(`gained-focus:${componentId}`, handleGainedFocus);
    lostFocusListenerId = gameStore.addEventListener(`lost-focus:${componentId}`, handleLostFocus);
  });

  onUnmounted(() => {
    gameStore.removeEventListener(`gained-focus:${componentId}`, gainedFocusListenerId);
    gameStore.removeEventListener(`lost-focus:${componentId}`, lostFocusListenerId);
    window.removeEventListener('keydown', handleKeyDown);
  });

  return {
    handleKeyDown
  };
} 


================================================
FILE: client/src/router/index.ts
================================================
import { createRouter, createWebHistory } from 'vue-router'
import HomeView from '../views/HomeView.vue'
import SignInView from '../views/SignInView.vue'
import SignUpView from '../views/SignUpView.vue'
import GameView from '../views/GameView.vue'
import { useGameStore } from '../stores/game'
import { watch } from 'vue'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      name: 'home',
      component: HomeView
    },
    {
      path: '/signin',
      name: 'signin',
      component: SignInView,
      beforeEnter: (to, from, next) => {
        const gameStore = useGameStore()
        if (gameStore.isAuthenticated) {
          next('/play')
        } else {
          next()
        }
      }
    },
    {
      path: '/signup',
      name: 'signup',
      component: SignUpView,
      beforeEnter: (to, from, next) => {
        const gameStore = useGameStore()
        if (gameStore.isAuthenticated) {
          next('/play')
        } else {
          next()
        }
      }
    },
    {
      path: '/play',
      name: 'game',
      component: GameView,
      beforeEnter: (to, from, next) => {
        const gameStore = useGameStore()
        if (!gameStore.isAuthenticated) {
          next('/signin')
        } else {
          next()
        }
      }
    },
    {
      path: '/:pathMatch(.*)*',
      redirect: '/'
    }
  ]
})

// Add global navigation guard
router.beforeEach((to, from, next) => {
  const gameStore = useGameStore()

  // Always allow access to home and auth routes
  if (to.name === 'home' || to.name === 'signin' || to.name === 'signup') {
    next()
    return
  }

  // Check authentication for other routes
  if (!gameStore.isAuthenticated) {
    next('/signin')
  } else {
    next()
  }
})

// Authentication state changes are now watched in App.vue

export default router


================================================
FILE: client/src/stores/game.ts
================================================
import { ref, computed } from 'vue'
import type { Ref } from 'vue'
import { PhysicsSystem } from '../systems/physics-system'
import { SocketSystem } from '../systems/socket-system'
import { defineStore } from 'pinia'
import { FocusSystem } from '../systems/focus-system'

import { GameObjectSystem, type GameObject } from '../systems/game-object-system'
import { ItemSystem, type Item } from '../systems/item-system'
import { InventorySystem } from '../systems/inventory-system'
import { PersonaSystem } from '../systems/persona-system'
import { PreloaderSystem, type PreloadProgress } from '../systems/preloader-system'

export const useGameStore = defineStore('game', () => {
  // Reactive state variables that are used by front facing
  // components, as well as manipulated by the logic layers
  const ws = ref<WebSocket | null>(null)
  const wsConnected = ref(false)
  const isAuthenticated = ref(false)
  const userId = ref<string | null>(null)
  const objects = ref<GameObject[]>([])
  const tileSize = ref(50)
  const heldItemId = ref<string | null>(null)
  const personaData = ref<Map<string, string>>(new Map())

  // Flags
  const debug = ref(false)
  const interactionLocked = ref(false)
  const hasActivePhysics = ref(false)

  // Preloader state
  const preloadProgress = ref<PreloadProgress>({
    total: 0,
    loaded: 0,
    failed: 0,
    pending: 0
  })
  const isInitialLoadComplete = ref(false)

  // Logic layers that interact with aspects of the
  // shared reactive state
  new PhysicsSystem(objects, hasActivePhysics);
  const socketSystem = new SocketSystem(ws, wsConnected, isAuthenticated);
  const gameObjectSystem = new GameObjectSystem(objects);
  const itemSystem = new ItemSystem(socketSystem);
  const inventorySystem = new InventorySystem(
    socketSystem,
    userId
  );
  const personaSystem = new PersonaSystem(personaData, socketSystem);
  const focusSystem = new FocusSystem(socketSystem, interactionLocked);
  
  // Initialize preloader system
  const preloaderSystem = new PreloaderSystem(socketSystem, preloadProgress, isInitialLoadComplete)

  return {
    // State
    ws,
    wsConnected,
    isAuthenticated,
    userId,
    objects,
    debug,
    tileSize,
    interactionLocked,
    hasActivePhysics,
    heldItemId,
    personaData,
    focusedComponent: focusSystem.focusedComponentRef,

    // Focus management
    pushFocus: focusSystem.pushFocus.bind(focusSystem),
    popFocus: focusSystem.popFocus.bind(focusSystem),
    hasFocus: focusSystem.hasFocus.bind(focusSystem),

    // Socket actions
    initWebSocket: socketSystem.initWebSocket.bind(socketSystem),
    addEventListener: socketSystem.addEventListener.bind(socketSystem),
    removeEventListener: socketSystem.removeEventListener.bind(socketSystem),
    emitEvent: socketSystem.emitEvent.bind(socketSystem),
    pullItem: socketSystem.pullItem.bind(socketSystem),
    listInventory: socketSystem.listInventory.bind(socketSystem),
    discardItem: socketSystem.discardItem.bind(socketSystem),
    moveItem: socketSystem.moveItem.bind(socketSystem),
    useSkill: socketSystem.useSkill.bind(socketSystem),
    sellItem: socketSystem.sellItem.bind(socketSystem),
    fetchPersona: socketSystem.fetchPersona.bind(socketSystem),
    peekDiscarded: socketSystem.peekDiscarded.bind(socketSystem),
    buyDiscarded: socketSystem.buyDiscarded.bind(socketSystem),
    reconnect: socketSystem.reconnect.bind(socketSystem),
    cleanup: socketSystem.cleanup.bind(socketSystem),

    // Game item actions (getting items is done using the reactive itemsById prop)
    upsertItem: itemSystem.upsertItem.bind(itemSystem),
    removeItem: itemSystem.removeItem.bind(itemSystem),
    clearItems: itemSystem.clearItems.bind(itemSystem),
    useItem: itemSystem.useItem.bind(itemSystem),

    // Game object (drawn objects) actions
    addObject: gameObjectSystem.addObject.bind(gameObjectSystem),
    clearObjects: gameObjectSystem.clearObjects.bind(gameObjectSystem),
    updateObjectPhysics: gameObjectSystem.updateObjectPhysics.bind(gameObjectSystem),
    removeObject: gameObjectSystem.removeObject.bind(gameObjectSystem),
    
    // Inventory system actions
    useInventory: inventorySystem.useInventory.bind(inventorySystem),
    moveItemToInventory: inventorySystem.moveItemToInventory.bind(inventorySystem),

    // Persona system actions
    usePersona: personaSystem.usePersona.bind(personaSystem),

    // Preloader state
    preloadProgress,
    isInitialLoadComplete,

    // Preloader actions
    preloadStaticAssets: preloaderSystem.preloadStaticAssets.bind(preloaderSystem),
  }
})


================================================
FILE: client/src/systems/focus-system.ts
================================================
import { ref, computed, watch, type Ref } from 'vue'
import type { SocketSystem } from './socket-system'

export class FocusSystem {
  private focusStack = ref<string[]>([])
  private socketSystem: SocketSystem
  private eventListenerIds: string[] = []
  private interactionLocked: Ref<boolean>

  constructor(socketSystem: SocketSystem, interactionLocked: Ref<boolean>) {
    this.socketSystem = socketSystem
    this.interactionLocked = interactionLocked
    
    // Watch for changes to the focus stack
    watch(this.focusStack, (newStack) => {
      console.log('Focus stack changed:', [...newStack])
      // Update interactionLocked based on whether there are any focused components
      this.interactionLocked.value = newStack.length > 0
    }, { deep: true })
  }

  pushFocus(componentId: string) {
    // Emit lost-focus for the previous top item if it exists
    const previousFocus = this.focusStack.value[this.focusStack.value.length - 1]
    if (previousFocus) {
      this.socketSystem.emitEvent(`lost-focus:${previousFocus}`)
    }
    
    this.focusStack.value.push(componentId)
    this.socketSystem.emitEvent(`gained-focus:${componentId}`)
  }

  popFocus() {
    const previousFocus = this.focusStack.value[this.focusStack.value.length - 1]
    this.focusStack.value.pop()
    if (previousFocus) {
      this.socketSystem.emitEvent(`lost-focus:${previousFocus}`)
    }
    // Emit gained focus for the new top of stack if it exists
    const newFocus = this.focusStack.value[this.focusStack.value.length - 1]
    if (newFocus) {
      this.socketSystem.emitEvent(`gained-focus:${newFocus}`)
    }
  }

  hasFocus(componentId: string): boolean {
    return this.focusStack.value.length > 0 && 
           this.focusStack.value[this.focusStack.value.length - 1] === componentId
  }

  get focusedComponentRef() {
    return computed(() => 
      this.focusStack.value.length > 0 
        ? this.focusStack.value[this.focusStack.value.length - 1] 
        : null
    )
  }

  get focusStackRef() {
    return this.focusStack
  }

  cleanup() {
    // Remove event listeners
    this.eventListenerIds.forEach((id) => {
      this.socketSystem.removeEventListener('gained-focus:*', id)
      this.socketSystem.removeEventListener('lost-focus:*', id)
    })
    this.eventListenerIds = []
  }
} 


================================================
FILE: client/src/systems/game-object-system.ts
================================================
import type { Component, Ref } from 'vue'
import { markRaw, watch } from 'vue'
import type { PhysicsProperties } from '../utils/physics'

export interface GameObject {
  id: string
  type: Component
  row: number
  col: number
  width?: number
  height?: number
  depth?: number
  playerIsNear?: boolean
  physics?: PhysicsProperties
  interactive?: boolean
  props: any
}

export class GameObjectSystem {
  private objects: Ref<GameObject[]>

  constructor(objects: Ref<GameObject[]>) {
    this.objects = objects
  }

  addObject(obj: GameObject) {
    this.objects.value.push({
      ...obj,
      type: markRaw(obj.type),
      playerIsNear: false
    })

    // Check to see if this object is the player, if
    // so attach a watcher to update proximity
    if (obj.id === 'player') {
      const playerObject = this.objects.value.find(o => o.id === 'player')

      if (!playerObject) {
        return
      }

      watch(
        playerObject,
        (player) => {
          if (player) {
            this.updatePlayerProximity(player.row, player.col)
          }
        },
        { deep: true }
      )
    }
  }

  clearObjects() {
    this.objects.value = []
  }

  updatePlayerProximity(playerRow: number, playerCol: number) {
    const proximityThreshold = 3 // Now in tile units instead of pixels
    let closestDistance = Infinity
    let closestInteractiveId: string | null = null

    // Reset all playerIsNear flags
    this.objects.value.forEach(obj => {
      if (obj.id !== 'player') {
        obj.playerIsNear = false
      }
    })

    // Find the closest interactive object based on tile distance
    this.objects.value.forEach(obj => {
      if (obj.id === 'player' || !obj.interactive) {
        return
      }

      const objRow = obj.row - 1
      const objCol = obj.col - 1
      const objWidth = obj.width || 1
      const objDepth = obj.depth || 1

      // Calculate closest points between player and object in tile coordinates
      const closestCol = Math.max(objCol, Math.min(playerCol, objCol + objWidth))
      const closestRow = Math.max(objRow, Math.min(playerRow, objRow + objDepth))

      // Calculate tile distance
      const distance = Math.sqrt(
        Math.pow(closestCol - playerCol, 2) +
        Math.pow(closestRow - playerRow, 2)
      )

      // Update closest interactive object if this one is closer
      if (distance < closestDistance) {
        closestDistance = distance
        closestInteractiveId = obj.id
      }
    })

    // Mark only the closest interactive object as near if it's within threshold
    if (closestInteractiveId && closestDistance < proximityThreshold) {
      const closestObject = this.objects.value.find(obj => obj.id === closestInteractiveId)
      if (closestObject) {
        closestObject.playerIsNear = true
      }
    }
  }

  updateObjectPhysics(objectId: string, physicsProps: Partial<PhysicsProperties>) {
    const object = this.objects.value.find(obj => obj.id === objectId)
    if (!object) {
      console.warn(`No object found with id ${objectId}`)
      return
    }

    // Initialize physics if it doesn't exist
    if (!object.physics) {
      object.physics = {
        active: false,
        angle: 0,
        velocity: 0,
        friction: 0.2,
        height: 0,
        verticalVelocity: 0,
        bounceStrength: 0.7,
        mass: 1.0
      }
    }

    // Update physics properties
    object.physics = {
      ...object.physics,
      ...physicsProps,
      active: true
    }
  }

  removeObject(objectId: string) {
    const index = this.objects.value.findIndex(obj => obj.id === objectId)
    if (index !== -1) {
      this.objects.value.splice(index, 1)
    }
  }
}


================================================
FILE: client/src/systems/inventory-system.ts
================================================
import { type Ref, computed, ref } from 'vue'
import type { Item } from './item-system'
import type { SocketSystem } from './socket-system'

export class InventorySystem {
  private inventories: Map<string, Ref<string[]>>
  private inventoryForItem: Map<string, string>
  private socketSystem: SocketSystem
  private eventListenerIds: string[] = []
  private userId: Ref<string | null>

  constructor(
    socketSystem: SocketSystem,
    userId: Ref<string | null>
  ) {
    this.inventories = new Map<string, Ref<string[]>>();
    this.inventoryForItem = new Map<string, string>();
    this.socketSystem = socketSystem
    this.userId = userId

    // Subscribe to inventory events
    this.eventListenerIds.push(this.socketSystem.addEventListener('inventory-items:*', this.handleInventoryItems.bind(this)))
    this.eventListenerIds.push(this.socketSystem.addEventListener('item-moved', this.handleItemMoved.bind(this)))
    this.eventListenerIds.push(this.socketSystem.addEventListener('skill-use*', this.handleSkillResults.bind(this)))
    this.eventListenerIds.push(this.socketSystem.addEventListener('clean-workbench-results', this.handleCleanWorkbenchResults.bind(this)))
    this.eventListenerIds.push(this.socketSystem.addEventListener('discarded-results', this.handleDiscardedResults.bind(this)))
  }

  /**
   * Get a reactive reference to item IDs in a specific inventory
   * @param inventoryName The name of the inventory to access
   * @returns A ref to the array of item IDs in the inventory
   */
  useInventory(inventoryName: string) {
    if (!this.inventories.has(inventoryName)) {
      this.inventories.set(inventoryName, ref<string[]>([]));
    }

    // Now request this inventory from the server
    this.socketSystem.listInventory(`${this.userId.value}:${inventoryName}`);

    // Return the ref directly
    return this.inventories.get(inventoryName)!;
  }

  /**
   * Move an item to a specific inventory
   * @param itemId The ID of the item to move
   * @param inventoryName The name of the target inventory
   */
  moveItemToInventory(itemId: string, inventoryName: string) {
    if (!this.userId.value) {
      console.error('Cannot move item: user ID is not set')
      return
    }

    const targetInventoryId = `${this.userId.value}:${inventoryName}`
    this.socketSystem.moveItem(itemId, targetInventoryId)
  }

  /**
   * Helper method to get or create an inventory ref
   * @param inventoryName The name of the inventory
   * @returns The inventory ref
   */
  private getOrCreateInventoryRef(inventoryName: string): Ref<string[]> {
    let inventoryRef = this.inventories.get(inventoryName)
    if (!inventoryRef) {
      inventoryRef = ref<string[]>([])
      this.inventories.set(inventoryName, inventoryRef)
    }
    return inventoryRef
  }

  /**
   * Helper method to remove an item from an inventory
   * @param itemId The ID of the item to remove
   * @param inventoryName The name of the inventory to remove from
   * @returns true if the item was removed, false otherwise
   */
  private removeItemFromInventory(itemId: string, inventoryName: string): boolean {
    const inventoryRef = this.inventories.get(inventoryName)
    if (!inventoryRef) return false

    const inventory = [...inventoryRef.value]
    const itemIndex = inventory.indexOf(itemId)
    if (itemIndex === -1) return false

    inventory.splice(itemIndex, 1)
    inventoryRef.value = inventory
    this.inventoryForItem.delete(itemId)
    return true
  }

  /**
   * Helper method to add an item to an inventory
   * @param itemId The ID of the item to add
   * @param inventoryName The name of the inventory to add to
   */
  private addItemToInventory(itemId: string, inventoryName: string) {
    const inventoryRef = this.getOrCreateInventoryRef(inventoryName)
    const inventory = [...inventoryRef.value]
    
    // Remove from current inventory if it exists
    const currentInventoryName = this.inventoryForItem.get(itemId)
    if (currentInventoryName) {
      this.removeItemFromInventory(itemId, currentInventoryName)
    }

    // Add to new inventory
    inventory.push(itemId)
    inventoryRef.value = inventory
    this.inventoryForItem.set(itemId, inventoryName)
  }

  /**
   * Handle inventory items received from socket events
   * @param data The inventory items data from the socket
   * @param eventType The event type string
   */
  private handleInventoryItems(data: any, eventType?: string) {
    const inventoryName = eventType ? eventType.split(':')[1] : data.type?.split(':')[1]

    if (!inventoryName) {
      console.error('Invalid inventory event type:', eventType || data.type)
      return
    }

    const sortedItems = [...data].sort((a, b) => {
      if (a.createdAt && b.createdAt) {
        return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
      }
      return 0
    })

    const itemIds = sortedItems.map(item => item.id)
    const inventoryRef = this.getOrCreateInventoryRef(inventoryName)
    inventoryRef.value = itemIds

    itemIds.forEach(itemId => {
      this.inventoryForItem.set(itemId, inventoryName)
    })
  }

  /**
   * Handle item moved events
   * @param data The item moved event data
   */
  private handleItemMoved(data: { itemId: string, targetInventoryId: string, item: Item }) {
    const targetInventoryName = data.targetInventoryId.split(':')[1]

    if (!targetInventoryName) {
      console.error('Invalid target inventory ID in item-moved event:', data)
      return
    }

    const sourceInventoryName = this.inventoryForItem.get(data.itemId)
    if (sourceInventoryName) {
      this.removeItemFromInventory(data.itemId, sourceInventoryName)
    }

    this.addItemToInventory(data.itemId, targetInventoryName)
  }

  /**
   * Handle skill results events
   * @param data The skill results data containing removedItemIds and outputItems
   */
  private handleSkillResults(data: any) {
    if (data.itemId) {
      const inventoryName = this.inventoryForItem.get(data.itemId)
      if (inventoryName) {
        this.removeItemFromInventory(data.itemId, inventoryName)
      }
    }

    if (data.item) {
      const itemId = data.item.id
      if (itemId) {
        this.addItemToInventory(itemId, 'workbench-results')
      }
    }
  }

  /**
   * Handle clean workbench results event
   * Moves items from workbench-results to workbench-working (max 5 items)
   * and any extra items to workbench-main or drops them if no space
   */
  private handleCleanWorkbenchResults() {
    const resultsInventoryRef = this.inventories.get('workbench-results')
    if (!resultsInventoryRef || resultsInventoryRef.value.length === 0) {
      return
    }
    
    const resultsInventory = [...resultsInventoryRef.value]
    const workingInventoryRef = this.getOrCreateInventoryRef('workbench-working')
    const workingInventory = [...workingInventoryRef.value]
    let remainingWorkingSpace = 5 - workingInventory.length
    
    while (resultsInventory.length > 0) {
      const itemId = resultsInventory.shift()!
      
      if (remainingWorkingSpace > 0) {
        this.moveItemToInventory(itemId, 'workbench-working')
        remainingWorkingSpace--
      } else {
        this.moveItemToInventory(itemId, 'main')
        this.socketSystem.emitEvent('workbench-overflow-item', { itemId })
      }
    }
  }

  /**
   * Handle discarded results events
   * @param data The discarded results data containing items
   */
  private handleDiscardedResults(data: any) {
    if (!data || !Array.isArray(data)) {
      return
    }
    
    const itemIds = data.map((item: any) => item.id)
    const computerInventoryRef = this.getOrCreateInventoryRef('computer')
    computerInventoryRef.value = itemIds
    
    itemIds.forEach((itemId: string) => {
      this.inventoryForItem.set(itemId, 'computer')
    })
  }

  /**
   * Clean up resources when the component is unmounted
   */
  cleanup() {
    // Remove event listeners
    this.eventListenerIds.forEach(id => {
      // Extract event type from the ID (assuming format: 'eventType:id')
      const eventType = id.includes(':') ? id.split(':')[0] : 'inventory-items:*';
      this.socketSystem.removeEventListener(eventType, id)
    })
    this.eventListenerIds = []

    // Clear inventories
    this.inventories.clear()

    // Clear inventoryForItem map
    this.inventoryForItem.clear()
  }
}


================================================
FILE: client/src/systems/item-system.ts
================================================
import { type Ref, computed, ref } from 'vue'
import { useGameStore } from '../stores/game';
import type { SocketSystem } from './socket-system';

export interface Item {
  id: string
  name: string
  description: string
  imageUrl: string
  value?: number
  weight?: string
  damage?: string
  materials?: string[]
  skills?: { 
    name: string
    description: string
    targets?: number // 0 for self, 1 for single target, 2 for two targets
  }[]
}

export class ItemSystem {
  private items: Map<string, Ref<Item>>
  private socketSystem;
  private eventListenerIds: string[] = [];

  constructor(socketSystem: SocketSystem) {
    this.items = new Map()
    this.socketSystem = socketSystem;
    
    // Subscribe to inventory-items:* events
    this.eventListenerIds.push(this.socketSystem.addEventListener('inventory-items:*', this.handleInventoryItems.bind(this)))
    this.eventListenerIds.push(this.socketSystem.addEventListener('pulled-item', this.handlePulledItem.bind(this)))
    this.eventListenerIds.push(this.socketSystem.addEventListener('skill-use*', this.handleSkillResults.bind(this)))
    this.eventListenerIds.push(this.socketSystem.addEventListener('discarded-results', this.handleDiscardedResults.bind(this)))
  }

  useItem(itemId: string): Ref<Item> {
    const item = this.items.get(itemId)
    if (!item) {
      // Create a placeholder loading item
      const loadingItem: Item = {
        id: itemId,
        name: 'Loading...',
        description: 'This item is still loading...',
        imageUrl: '/src/assets/generic.png'
      }
      const loadingItemRef = ref(loadingItem)
      this.items.set(itemId, loadingItemRef)
      return loadingItemRef
    }
    return item
  }

  upsertItem(item: Item) {
    const existingRef = this.items.get(item.id)
    if (existingRef) {
      // Update the existing ref's value
      existingRef.value = item
    } else {
      // Create a new ref
      this.items.set(item.id, ref(item))
    }
  }

  removeItem(itemId: string) {
    this.items.delete(itemId)
  }

  clearItems() {
    this.items.clear()
  }
  
  /**
   * Handles inventory items received from socket events
   * @param data The inventory items data from the socket
   */
  private handleInventoryItems(data?: any, eventType?: string) {    
    // Add each item to the collection
    data.forEach((item: Item) => {
      this.upsertItem(item)
    })
  }

  /**
   * Adds item when an item is pulled
   */
  private handlePulledItem(data?: any, eventType?: string) {    
    this.upsertItem(data.item)
  }

  /**
   * Handles skill results from the server
   * @param data The skill results data containing story, tool, outputItems, and removedItemIds
   */
  private handleSkillResults(data?: any, eventType?: string) {
    // Update the tool item if present
    if (data.tool) {
      this.upsertItem(data.tool)
    }

    if (data.item) {
      this.upsertItem(data.item)
    }
    
    // Remove all items with IDs in the removedItemIds array
    // TODO: For now we will retain removed items so that they
    // can still be shown in the skill results window as a removed item.
    // In the future we should garbage collect these old items periodically
    // so that they don't add up and consume lots of memory on the client side
    // however retaining them until reload has minimal impact, while avoiding
    // UI bugs for now.
  }

  /**
   * Handles discarded results from the server
   * @param data The discarded results data containing items
   * @param eventType The type of event that triggered this handler
   */
  private handleDiscardedResults(data?: any, eventType?: string) {
    // Add all items to the local item store
    if (data && Array.isArray(data)) {
      data.forEach((item: Item) => {
        this.upsertItem(item)
      })
    }
  }
  
  /**
   * Clean up resources when the component is unmounted
   */
  cleanup() {
    // Remove event listeners
    this.eventListenerIds.forEach((id) => {
      this.socketSystem.removeEventListener('discarded-results', id)
    })
    this.eventListenerIds = [];
  }
}


================================================
FILE: client/src/systems/persona-system.ts
================================================
import { type Ref, computed } from 'vue'
import type { SocketSystem } from './socket-system'

export class PersonaSystem {
  private personaData: Ref<Map<string, string>>
  private socketSystem: SocketSystem
  private initialized = false

  constructor(
    personaData: Ref<Map<string, string>>,
    socketSystem: SocketSystem
  ) {
    this.personaData = personaData
    this.socketSystem = socketSystem

    // Subscribe to relevant events
    this.socketSystem.addEventListener('persona-details', this.handlePersonaDetails.bind(this))
    this.socketSystem.addEventListener('gold-update', this.handleGoldUpdate.bind(this))
    this.socketSystem.addEventListener('buy-results', this.handleBuyResults.bind(this))
  }

  /**
   * Get a reactive object containing all persona data points
   * Automatically fetches data on first call
   */
  usePersona() {
    if (!this.initialized) {
      this.socketSystem.fetchPersona()
      this.initialized = true
    }

    return computed(() => {
      const details: Record<string, string> = {}
      this.personaData.value.forEach((value, key) => {
        details[key] = value
      })
      return details
    })
  }

  /**
   * Handle incoming persona details from the server
   */
  private handlePersonaDetails(details: Record<string, string>) {
    // Update all persona data points
    Object.entries(details).forEach(([key, value]) => {
      this.personaData.value.set(key, value)
    })
  }

  /**
   * Handle gold update events
   */
  private handleGoldUpdate(data: { gold: number }) {
    if (data.gold !== undefined) {
      this.personaData.value.set('gold', data.gold.toString())
    }
  }

  /**
   * Handle buy results events
   */
  private handleBuyResults(data: { gold: number }) {
    if (data.gold !== undefined) {
      this.personaData.value.set('gold', data.gold.toString())
    }
  }
} 


================================================
FILE: client/src/systems/physics-system.ts
================================================
import { computed, watch, type Ref } from 'vue';
import type { GameObject } from './game-object-system';
import { useGameStore } from '../stores/game';
import { 
  updatePhysicsPosition, 
  checkCollision, 
  handleCollision, 
  handleWallCollision,
  PhysicsType
} from '../utils/physics';

export class PhysicsSystem {
  private objects: Ref<GameObject[]>;
  private lastTimestamp: number = 0;
  private animationFrameId: number | null = null;
  private hasActivePhysics: Ref<boolean>;

  private physicsObjects = computed(() => this.objects.value.filter(obj => obj.physics))
  private walls = computed(() => this.objects.value.filter(obj => obj.physics && obj.physics.mass == Infinity))
  private activeObjects = computed(() => this.physicsObjects.value.filter(obj => obj.physics && obj.physics.active == true))
  private gameStore;

  constructor(objects: Ref<GameObject[]>, hasActivePhysics: Ref<boolean>) {
    this.objects = objects;
    this.hasActivePhysics = hasActivePhysics;
    this.lastTimestamp = performance.now();
    const self = this;
    this.gameStore = useGameStore();

    // Watch activeObjects to control physics loop
    watch(this.activeObjects, (newActiveObjects) => {
      if(newActiveObjects.length > 0 && hasActivePhysics.value == false) {
        hasActivePhysics.value = true;
        self.start();
      }

      if (hasActivePhysics.value == true && newActiveObjects.length == 0) {
        hasActivePhysics.value = false;
        self.stop();
      }
    })
    
    // Add page visibility event listener to handle tab switching
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Tab is hidden, pause physics
        this.stop();
      } else {
        // Tab is visible again, reset timestamp and restart if needed
        this.lastTimestamp = performance.now();
        if (this.hasActivePhysics.value && this.animationFrameId === null) {
          this.start();
        }
      }
    });
  }

  start() {
    if (this.animationFrameId !== null) {
      return; // Already running
    }
    
    // Start the physics loop
    this.lastTimestamp = performance.now();
    this.animationFrameId = requestAnimationFrame(this.update.bind(this));
  }

  stop() {
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
  }

  private update(timestamp: number) {
    // Calculate delta time in seconds
    let deltaTime = (timestamp - this.lastTimestamp) / 1000;
    this.lastTimestamp = timestamp;
    
    // Cap delta time to prevent physics instability from large jumps
    const MAX_DELTA_TIME = 1/30; // Cap at ~33ms (30 FPS equivalent)
    deltaTime = Math.min(deltaTime, MAX_DELTA_TIME);
    
    // Update physics for all objects
    this.updatePhysics(deltaTime);
    
    // Continue the loop
    this.animationFrameId = requestAnimationFrame(this.update.bind(this));
  }

  private updatePhysics(deltaTime: number) {    
    const self = this;
    // Update positions based on physics properties
    for (const obj of this.physicsObjects.value) {
      if (!obj.physics) {
        continue;
      }

      if (obj.physics.physicsType == PhysicsType.Static || obj.physics.physicsType == PhysicsType.Field) {
        // These items don't collide with each other
        continue;
      }

      // First check if the object is stuck and fix it if needed
      /*obj.physics = detectAndFixStuckObjects({
        row: obj.row,
        col: obj.col,
        width: obj.width || 1,
        depth: obj.depth || 1,
        physics: obj.physics
      });*/

      // Update position based on physics
      const { row, col, physics } = updatePhysicsPosition(
        obj.row, 
        obj.col, 
        obj.physics, 
        deltaTime
      );
      
      // Check for wall collisions
      const wallCollisionResult = handleWallCollision(
        row,
        col,
        obj.width || 1,
        obj.depth || 1,
        physics,
        self.walls.value.map(wall => ({
          row: wall.row,
          col: wall.col,
          width: wall.width || 1,
          depth: wall.depth || 1,
          height: wall.height || 1 // Pass wall height with default of 1
        }))
      );
      
      // Update object with new position and physics
      obj.row = wallCollisionResult.row;
      obj.col = wallCollisionResult.col;
      obj.physics = wallCollisionResult.physics;
    }
    
    // Check for collisions between active objects
    for (let i = 0; i < this.physicsObjects.value.length; i++) {
      for (let j = 0; j < this.physicsObjects.value.length; j++) {
        if (i == j) {
          continue;
        }

        const obj1 = this.physicsObjects.value[i];
        const obj2 = this.physicsObjects.value[j];

        if (!obj1.physics || !obj2.physics) {
          continue;
        }

        /*if (!obj1.physics || !obj2.physics) {
          continue;
        }*/

        if (obj1.physics.physicsType == PhysicsType.Static || obj2.physics.physicsType == PhysicsType.Static) {
          // Static type collisions were handled already
          continue;
        }
        
        // Check if objects are colliding
        const colliding = checkCollision(
          {
            row: obj1.row,
            col: obj1.col,
            width: obj1.width || 1,
            depth: obj1.depth || 1,
            physics: obj1.physics
          },
          {
            row: obj2.row,
            col: obj2.col,
            width: obj2.width || 1,
            depth: obj2.depth || 1,
            physics: obj2.physics
          }
        );
        
        if (!colliding) {
          continue;
        }
          
        if (obj1.physics.physicsType == PhysicsType.Field || obj2.physics.physicsType == PhysicsType.Field) {
          // Field type collisions don't actually collide, but they do event.
          if (obj1.physics.event && typeof obj1.physics.event === 'string') {
            this.gameStore.emitEvent(obj1.physics.event, { id: obj2.id });
          }
          if (obj2.physics.event && typeof obj2.physics.event === 'string') {
            this.gameStore.emitEvent(obj2.physics.event, { id: obj1.id });
          }

          continue;
        }

        // Handle collision with momentum transfer
        const { obj1Physics, obj2Physics } = handleCollision(
          {
            row: obj1.row,
            col: obj1.col,
            width: obj1.width || 1,
            depth: obj1.depth || 1,
            physics: obj1.physics
          },
          {
            row: obj2.row,
            col: obj2.col,
            width: obj2.width || 1,
            depth: obj2.depth || 1,
            physics: obj2.physics
          }
        );
        
        // Update physics properties
        obj1.physics = obj1Physics;
        obj2.physics = obj2Physics;
        
        // Check if either object has an event property in its physics configuration
        // and emit that event with the ID of the colliding object
        
        if (obj1.physics.event && typeof obj1.physics.event === 'string') {
          this.gameStore.emitEvent(obj1.physics.event, { id: obj2.id });
        }
        if (obj2.physics.event && typeof obj2.physics.event === 'string') {
          this.gameStore.emitEvent(obj2.physics.event, { id: obj1.id });
        }
        
        // Slightly separate objects to prevent sticking
        const pushFactor = 0.05;
        const centerDiffX = obj2.col - obj1.col;
        const centerDiffY = obj2.row - obj1.row;
        const distance = Math.sqrt(centerDiffX * centerDiffX + centerDiffY * centerDiffY);
        
        if (distance > 0) {
          const normalX = centerDiffX / distance;
          const normalY = centerDiffY / distance;
          
          obj1.col -= normalX * pushFactor;
          obj1.row -= normalY * pushFactor;
          obj2.col += normalX * pushFactor;
          obj2.row += normalY * pushFactor;
        }
      }
    }
  }

  // Apply an impulse to an object (useful for kicking or pushing)
  applyImpulse(objectId: string, angle: number, force: number) {
    const object = this.objects.value.find(obj => obj.id === objectId);
    if (!object || !object.physics) {
      return;
    }
    
    // Initialize physics if not active
    if (!object.physics.active) {
      object.physics.active = true;
      object.physics.velocity = 0;
    }
    
    // Convert current velocity to vector
    const currentVelocity = {
      x: Math.cos(object.physics.angle * (Math.PI / 180)) * object.physics.velocity,
      y: Math.sin(object.physics.angle * (Math.PI / 180)) * object.physics.velocity
    };
    
    // Convert impulse to vector
    const impulse = {
      x: Math.cos(angle * (Math.PI / 180)) * force,
      y: Math.sin(angle * (Math.PI / 180)) * force
    };
    
    // Add impulse to current velocity
    const newVelocity = {
      x: currentVelocity.x + impulse.x / object.physics.mass,
      y: currentVelocity.y + impulse.y / object.physics.mass
    };
    
    // Convert back to angle and magnitude
    const magnitude = Math.sqrt(newVelocity.x * newVelocity.x + newVelocity.y * newVelocity.y);
    let newAngle = Math.atan2(newVelocity.y, newVelocity.x) * (180 / Math.PI);
    if (newAngle < 0) newAngle += 360;
    
    // Update physics properties
    object.physics.angle = newAngle;
    object.physics.velocity = magnitude;
    object.physics.active = true;
  }

  // Apply a vertical impulse (jumping or throwing upward)
  applyVerticalImpulse(objectId: string, force: number) {
    const object = this.objects.value.find(obj => obj.id === objectId);
    if (!object || !object.physics) {
      return;
    }
    
    // Initialize physics if not active
    if (!object.physics.active) {
      object.physics.active = true;
    }
    
    // Add vertical impulse
    object.physics.verticalVelocity += force / object.physics.mass;
  }
}


================================================
FILE: client/src/systems/preloader-system.ts
================================================
import { type Ref, computed } from 'vue'
import { useGameStore } from '../stores/game'
import type { SocketSystem } from './socket-system'
import type { Item } from './item-system'
import { staticAssets } from '../assets'

export interface PreloadProgress {
  total: number
  loaded: number
  failed: number
  pending: number
}

// List of static assets to preload
const STATIC_ASSETS = Object.values(staticAssets)

export class PreloaderSystem {
  private socketSystem: SocketSystem
  private eventListenerIds: string[] = []
  private loadingQueue: Set<string> = new Set()
  private loadedImages: Set<string> = new Set()
  private failedImages: Set<string> = new Set()
  private progress: Ref<PreloadProgress>
  private isInitialLoadComplete: Ref<boolean>

  constructor(socketSystem: SocketSystem, progress: Ref<PreloadProgress>, isInitialLoadComplete: Ref<boolean>) {
    this.socketSystem = socketSystem
    this.progress = progress
    this.isInitialLoadComplete = isInitialLoadComplete
    
    // Subscribe to the same events as ItemSystem to preload item images
    this.eventListenerIds.push(this.socketSystem.addEventListener('inventory-items:*', this.handleInventoryItems.bind(this)))
    this.eventListenerIds.push(this.socketSystem.addEventListener('pulled-item', this.handlePulledItem.bind(this)))
    this.eventListenerIds.push(this.socketSystem.addEventListener('skill-results', this.handleSkillResults.bind(this)))
    this.eventListenerIds.push(this.socketSystem.addEventListener('discarded-results', this.handleDiscardedResults.bind(this)))

    // Automatically start loading static assets
    this.preloadStaticAssets(STATIC_ASSETS).catch(error => {
      console.error('[PreloaderSystem] Failed to load static assets:', error)
    })
  }

  /**
   * Preloads a single image and updates progress
   */
  private async preloadImage(url: string): Promise<void> {
    if (this.loadedImages.has(url) || this.failedImages.has(url) || this.loadingQueue.has(url)) {
      return
    }

    this.loadingQueue.add(url)
    this.updateProgress()

    try {
      const img = new Image()
      await new Promise((resolve, reject) => {
        img.onload = resolve
        img.onerror = reject
        img.src = url
      })
      this.loadedImages.add(url)
    } catch (error) {
      console.error(`[PreloaderSystem] Failed to load image: ${url}`, error)
      this.failedImages.add(url)
    } finally {
      this.loadingQueue.delete(url)
      this.updateProgress()
    }
  }

  /**
   * Updates the progress state
   */
  private updateProgress() {
    const newProgress = {
      total: this.loadedImages.size + this.failedImages.size + this.loadingQueue.size,
      loaded: this.loadedImages.size,
      failed: this.failedImages.size,
      pending: this.loadingQueue.size
    }
    this.progress.value = newProgress
    
    // Log progress update
    /*console.log('[PreloaderSystem] Progress Update:', {
      total: newProgress.total,
      loaded: newProgress.loaded,
      failed: newProgress.failed,
      pending: newProgress.pending,
      percentComplete: newProgress.total > 0 
        ? Math.round((newProgress.loaded / newProgress.total) * 100) 
        : 0
    })*/
  }

  /**
   * Preloads all static game assets
   */
  async preloadStaticAssets(staticAssets: string[]): Promise<void> {
    const promises = staticAssets.map(url => this.preloadImage(url))
    await Promise.all(promises)
    this.isInitialLoadComplete.value = true
  }

  /**
   * Preloads images from an array of items
   */
  private async preloadItemImages(items: Item[]): Promise<void> {
    const imageUrls = items
      .map(item => item.imageUrl)
      .filter(url => url && !this.loadedImages.has(url) && !this.failedImages.has(url))
    
    if (imageUrls.length > 0) {
      await Promise.all(imageUrls.map(url => this.preloadImage(url)))
    }
  }

  private handleInventoryItems(data?: any) {
    if (Array.isArray(data)) {
      this.preloadItemImages(data)
    }
  }

  private handlePulledItem(data?: any) {
    if (data?.item) {
      this.preloadItemImages([data.item])
    }
  }

  private handleSkillResults(data?: any) {
    const items: Item[] = []
    if (data.tool) items.push(data.tool)
    if (data.outputItems) items.push(...data.outputItems)
    if (items.length > 0) {
      this.preloadItemImages(items)
    }
  }

  private handleDiscardedResults(data?: any) {
    if (Array.isArray(data)) {
      this.preloadItemImages(data)
    }
  }

  cleanup() {
    this.eventListenerIds.forEach(id => {
      this.socketSystem.removeEventListener('discarded-results', id)
    })
    this.eventListenerIds = []
  }
} 


================================================
FILE: client/src/systems/socket-system.ts
================================================
import type { Ref } from 'vue'

export class SocketSystem {
  private ws: Ref<WebSocket | null>
  private wsConnected: Ref<boolean>
  private isAuthenticated: Ref<boolean>
  private eventListeners: Map<string, Map<string, (data?: any, eventType?: string) => void>>

  // Reconnection properties
  private reconnectAttempts: number = 0
  private maxReconnectAttempts: number = 10
  private baseReconnectDelay: number = 1000 // 1 second
  private maxReconnectDelay: number = 30000 // 30 seconds
  private reconnectTimeoutId: number | null = null

  // Ping properties
  private pingIntervalId: number | null = null
  private readonly PING_INTERVAL = 10000 // 10 seconds

  // Wildcard character for event pattern matching
  private readonly wildcardChar: string = '*'

  constructor(
    ws: Ref<WebSocket | null>,
    wsConnected: Ref<boolean>,
    isAuthenticated: Ref<boolean>
  ) {
    this.ws = ws
    this.wsConnected = wsConnected
    this.isAuthenticated = isAuthenticated
    this.eventListeners = new Map()
  }

  initWebSocket() {
    // Clear any existing reconnect timeout
    if (this.reconnectTimeoutId !== null) {
      clearTimeout(this.reconnectTimeoutId);
      this.reconnectTimeoutId = null;
    }

    // Allow override via environment variable, otherwise use current protocol, host, and port
    const wsUrl = import.meta.env.VITE_WS_URL || (
      (() => {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
        const host = window.location.hostname
        const port = window.location.port ? `:${window.location.port}` : ''
        return `${protocol}//${host}${port}/ws`
      })()
    )
    this.ws.value = new WebSocket(wsUrl)

    this.ws.value.onopen = () => {
      this.wsConnected.value = true
      console.log('WebSocket connected')

      // Reset reconnect attempts on successful connection
      this.reconnectAttempts = 0

      // Start ping interval
      this.startPingInterval()
    }

    this.ws.value.onclose = (event) => {
      this.wsConnected.value = false
      this.isAuthenticated.value = false
      console.log('WebSocket disconnected', event)

      // Clear ping interval
      this.clearPingInterval()

      // Attempt to reconnect
      this.scheduleReconnect()
    }

    this.ws.value.onerror = (error) => {
      console.error('WebSocket error:', error)
      // Error handling is done in onclose handler
    }

    this.ws.value.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data)
        console.log('Received message:', data)

        if (data.type === 'signin_success' || data.type === 'signup_success') {
          this.isAuthenticated.value = true
        }

        this.emitEvent(data.type, data.body)
      } catch (e) {
        console.error('Error parsing WebSocket message:', e)
      }
    }
  }

  /**
   * Adds an event listener for the specified event type.
   * Supports wildcard patterns like "inventory-items:*" for subscribing to multiple events.
   * 
   * @param eventType - The event type to listen for, can include wildcards
   * @param callback - The callback function to execute when the event is emitted
   * @returns A unique listener ID that can be used to remove the listener
   */
  addEventListener(eventType: string, callback: (data?: any, eventType?: string) => void): string {
    const listenerId = crypto.randomUUID()

    if (!this.eventListeners.has(eventType)) {
      this.eventListeners.set(eventType, new Map())
    }

    const eventMap = this.eventListeners.get(eventType)!
    eventMap.set(listenerId, callback)

    return listenerId
  }

  removeEventListener(eventType: string, listenerId: string) {
    const eventMap = this.eventListeners.get(eventType)
    if (!eventMap) {
      console.warn(`No listeners found for event type: ${eventType}`)
      return
    }

    if (!eventMap.has(listenerId)) {
      console.warn(`No listener found with ID ${listenerId} for event type: ${eventType}`)
      return
    }

    eventMap.delete(listenerId)

    // Clean up empty event maps
    if (eventMap.size === 0) {
      this.eventListeners.delete(eventType)
    }
  }

  /**
   * Checks if an event matches a pattern that may include wildcards.
   * For example, "inventory-items:123" matches the pattern "inventory-items:*"
   * 
   * @param eventType - The actual event type being emitted
   * @param pattern - The pattern to match against, may include wildcards
   * @returns True if the event matches the pattern
   */
  private matchesEventPattern(eventType: string, pattern: string): boolean {
    // If the pattern is exactly the event type, it's a direct match
    if (pattern === eventType) {
      return true
    }

    // If the pattern doesn't contain a wildcard, it can't be a match at this point
    if (!pattern.includes(this.wildcardChar)) {
      return false
    }

    // Convert the pattern to a regex by escaping special characters and replacing * with .*
    const regexPattern = pattern
      .replace(/[.+?^${}()|[\]\\]/g, '\\$&') // Escape special regex chars except *
      .replace(/\*/g, '.*'); // Replace * with .*

    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(eventType);
  }

  /**
   * Emits an event to all registered listeners for the event type.
   * Also triggers any wildcard listeners that match the event type.
   * 
   * @param eventType - The type of event to emit
   * @param data - Optional data to pass to the event listeners
   */
  emitEvent(eventType: string, data?: any) {
    // First, trigger exact match listeners
    const exactEventMap = this.eventListeners.get(eventType)
    if (exactEventMap) {
      exactEventMap.forEach(callback => callback(data, eventType))
    }

    // Then, check for wildcard patterns that match this event
    this.eventListeners.forEach((listenerMap, pattern) => {
      // Skip the exact match we already processed
      if (pattern !== eventType && this.matchesEventPattern(eventType, pattern)) {
        listenerMap.forEach(callback => callback(data, eventType))
      }
    })
  }

  pullItem() {
    if (!this.ws.value || !this.isAuthenticated.value) {
      console.error('Cannot pull item: not connected or not authenticated')
      return
    }

    const message = {
      type: 'pull-item'
    }

    this.ws.value.send(JSON.stringify(message))
  }

  listInventory(inventoryId: string) {
    if (!this.ws.value || !this.isAuthenticated.value) {
      console.error('Cannot list inventory: not connected or not authenticated')
      return
    }

    const message = {
      type: 'list-inventory',
      body: {
        inventoryId: inventoryId
      }
    }

    this.ws.value.send(JSON.stringify(message))
  }

  discardItem(itemId: string) {
    if (!this.ws.value || !this.isAuthenticated.value) {
      console.error('Cannot discard item: not connected or not authenticated')
      return
    }

    const message = {
      type: 'discard-item',
      body: {
        itemId: itemId
      }
    }

    this.ws.value.send(JSON.stringify(message))
  }

  moveItem(itemId: string, targetInventoryId: string) {
    if (!this.ws.value || !this.isAuthenticated.value) {
      console.error('Cannot move item: not connected or not authenticated')
      return
    }

    const message = {
      type: 'move-item',
      body: {
        itemId: itemId,
        targetInventoryId: targetInventoryId
      }
    }

    this.ws.value.send(JSON.stringify(message))
  }

  useSkill(toolId: string, toolSkillIndex: number, targetIds: string[]) {
    if (!this.ws.value || !this.isAuthenticated.value) {
      console.error('Cannot use skill: not connected or not authenticated')
      return
    }

    const message = {
      type: 'use-skill',
      body: {
        toolId,
        toolSkillIndex,
        targetIds
      }
    }

    this.ws.value.send(JSON.stringify(message))
  }

  sellItem(itemId: string) {
    if (!this.ws.value || !this.isAuthenticated.value) {
      console.error('Cannot sell item: not connected or not authenticated')
      return
    }

    const message = {
      type: 'sell-item',
      body: {
        itemId: itemId
      }
    }

    this.ws.value.send(JSON.stringify(message))
  }

  peekDiscarded(numberOfItems: number) {
    if (!this.ws.value || !this.isAuthenticated.value) {
      console.error('Cannot peek discarded items: not connected or not authenticated')
      return
    }

    const message = {
      type: 'peek-discarded',
      body: {
        numberOfItems
      }
    }

    this.ws.value.send(JSON.stringify(message))
  }

  buyDiscarded(itemId: string) {
    if (!this.ws.value || !this.isAuthenticated.value) {
      console.error('Cannot buy discarded item: not connected or not authenticated')
      return
    }

    const message = {
      type: 'buy-discarded',
      body: {
        itemId
      }
    }

    this.ws.value.send(JSON.stringify(message))
  }

  fetchPersona() {
    if (!this.ws.value || !this.isAuthenticated.value) {
      console.error('Cannot fetch persona: not connected or not authenticated')
      return
    }

    const message = {
      type: 'fetch-persona',
      body: {}
    }

    this.ws.value.send(JSON.stringify(message))
  }

  /**
   * Schedule a reconnection attempt with exponential backoff
   */
  private scheduleReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error(`Maximum reconnection attempts (${this.maxReconnectAttempts}) reached. Giving up.`)
      this.emitEvent('reconnect-failed')
      return
    }

    // Reset authentication state before reconnecting
    this.isAuthenticated.value = false

    // Calculate delay with exponential backoff: baseDelay * 2^attempts
    // with a maximum cap and some randomization to prevent thundering herd
    const exponentialDelay = this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts)
    const jitter = Math.random() * 0.5 + 0.75 // Random value between 0.75 and 1.25
    const delay = Math.min(exponentialDelay * jitter, this.maxReconnectDelay)

    console.log(`Scheduling reconnect attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts} in ${Math.round(delay)}ms`)

    this.reconnectTimeoutId = window.setTimeout(() => {
      this.reconnectAttempts++
      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`)
      this.emitEvent('reconnect-attempt', { attempt: this.reconnectAttempts, maxAttempts: this.maxReconnectAttempts })
      this.initWebSocket()
    }, delay)
  }

  /**
   * Manually attempt to reconnect, resetting the reconnect attempts
   */
  reconnect() {
    // Clear any existing reconnect timeout
    if (this.reconnectTimeoutId !== null) {
      clearTimeout(this.reconnectTimeoutId)
      this.reconnectTimeoutId = null
    }

    // Reset reconnect attempts
    this.reconnectAttempts = 0

    // Reset authentication state before reconnecting
    this.isAuthenticated.value = false

    // Close existing connection if any
    if (this.ws.value && (this.ws.value.readyState === WebSocket.OPEN || this.ws.value.readyState === WebSocket.CONNECTING)) {
      this.ws.value.close()
    }

    // Initiate new connection
    this.initWebSocket()
  }

  /**
   * Start sending periodic ping messages
   */
  private startPingInterval() {
    // Clear any existing interval
    this.clearPingInterval()

    // Set up new interval
    this.pingIntervalId = window.setInterval(() => {
      if (this.ws.value && this.ws.value.readyState === WebSocket.OPEN) {
        const message = {
          type: 'ping'
        }
        this.ws.value.send(JSON.stringify(message))
      }
    }, this.PING_INTERVAL)
  }

  /**
   * Clear the ping interval
   */
  private clearPingInterval() {
    if (this.pingIntervalId !== null) {
      clearInterval(this.pingIntervalId)
      this.pingIntervalId = null
    }
  }

  /**
   * Clean up resources when the component is unmounted
   */
  cleanup() {
    if (this.reconnectTimeoutId !== null) {
      clearTimeout(this.reconnectTimeoutId)
      this.reconnectTimeoutId = null
    }

    this.clearPingInterval()

    if (this.ws.value) {
      this.ws.value.close()
      this.ws.value = null
    }
  }
}


================================================
FILE: client/src/utils/init-world.ts
================================================
import PlayerCharacter from '../components/PlayerCharacter.vue'
import Dispenser from '../components/Dispenser.vue'
import Banner from '../components/Banner.vue'
import Workbench from '../components/Workbench.vue'
import Wall from '../components/Wall.vue'
import Chest from '../components/Chest.vue'
import PullLever from '../components/PullLever.vue'
import Garbage from '../components/Garbage.vue'
import Computer from '../components/Computer.vue'
import { PhysicsType } from './physics'

export function setupGameObjects(gameStore: any, gridSize: number) {
  // System items
  gameStore.addObject({
    id: 'player',
    type: PlayerCharacter,
    row: gridSize / 2,
    col: gridSize / 2,
    width: 1,
    depth: 1,
    height: 1,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 0.5,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0.3,
      mass: 1,
      physicsType: PhysicsType.Dynamic
    },
    props: {}
  })

  // System items
  gameStore.addObject({
    id: 'banner',
    type: Banner,
    row: 2,
    col: 2,
    width: gridSize - 2,
    depth: 1,
    props: {}
  })

  // Static blockers
  gameStore.addObject({
    id: 'backwall1',
    type: Wall,
    row: -2,
    col: 1,
    width: gridSize,
    depth: 7.9,
    height: 6,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      mass: Infinity,
      physicsType: PhysicsType.Static
    },
    props: {}
  })

  gameStore.addObject({
    id: 'leftwall',
    type: Wall,
    row: 1,
    col: -1, // Start 2 tiles outside the play area
    width: 3, // Increased width to 3
    depth: gridSize,
    height: 1000,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      mass: Infinity,
      physicsType: PhysicsType.Static
    },
    props: {}
  })

  gameStore.addObject({
    id: 'rightwall',
    type: Wall,
    row: 1,
    col: gridSize,
    width: 3, // Increased width to extend 2 tiles out of the play area
    depth: gridSize,
    height: 1000,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      mass: Infinity,
      physicsType: PhysicsType.Static
    },
    props: {}
  })

  gameStore.addObject({
    id: 'bottomwall-left',
    type: Wall,
    row: gridSize - 1.5,
    col: 1,
    width: 8,
    depth: 2.5,
    height: 5,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      mass: Infinity,
      physicsType: PhysicsType.Static
    },
    props: {}
  })

  gameStore.addObject({
    id: 'bottomwall-right',
    type: Wall,
    row: gridSize - 1.5,
    col: 13,
    width: 8,
    depth: 2.5,
    height: 5,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      mass: Infinity,
      physicsType: PhysicsType.Static
    },
    props: {}
  })

  gameStore.addObject({
    id: 'door-block',
    type: Wall,
    row: gridSize + .25,
    col: 9,
    width: 4,
    depth: .25,
    height: 1,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      mass: Infinity,
      physicsType: PhysicsType.Static
    },
    props: {}
  })

  gameStore.addObject({
    id: 'door-field',
    type: Wall,
    row: gridSize - 1.5,
    col: 9,
    width: 4,
    depth: 2,
    height: 1,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      event: 'near-door',
      physicsType: PhysicsType.Field
    },
    props: {}
  })

  gameStore.addObject({
    id: 'sell-field',
    type: Wall,
    row: gridSize + .5,
    col: 9,
    width: 4,
    depth: .1,
    height: 1,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      event: 'sell-item',
      physicsType: PhysicsType.Field
    },
    props: {}
  })

  // Interactive objects
  gameStore.addObject({
    id: 'chest1',
    type: Chest,
    row: 10.5,
    col: 17.75,
    width: 2,
    depth: 1.5,
    height: 3.5, // Helps prevent items getting stuck on top of chest
    interactive: true,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      mass: Infinity,
      physicsType: PhysicsType.Static
    },
    props: {}
  })

  gameStore.addObject({
    id: 'dispenser1',
    type: Dispenser,
    row: 4.9,
    col: 9.15,
    width: 2.5,
    depth: 3,
    height: 3.5,
    interactive: true,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      mass: Infinity,
      physicsType: PhysicsType.Static
    },
    props: {}
  })

  gameStore.addObject({
    id: 'workbench1',
    type: Workbench,
    row: 3.5,
    col: 16,
    width: 2.5,
    depth: 3,
    height: 3,
    interactive: true,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      mass: Infinity,
      physicsType: PhysicsType.Static
    },
    props: {}
  })

  gameStore.addObject({
    id: 'lever1',
    type: PullLever,
    row: 5.5,
    col: 11.9,
    width: 1.5,
    depth: 1.5,
    height: 0,
    interactive: true,
    props: {
      pivotPoint: {
        x: 51,
        y: 81
      },
      initialAngle: 45,
      maxRotationAngle: 90,
      rotationSpeed: 300,
      autoReset: true,
      resetDelay: 100,
      resetSpeed: 500
    }
  })

  // Add garbage on the back wall
  gameStore.addObject({
    id: 'garbage1',
    type: Garbage,
    row: 4.4,
    col: 3.85,
    width: 2,
    depth: 2,
    height: 4,
    interactive: true,
    props: {}
  })

  // Add computer on the left side
  gameStore.addObject({
    id: 'computer1',
    type: Computer,
    row: 12.4,
    col: 2.25,
    width: 2.5,
    depth: 1.9,
    height: 4,
    interactive: true,
    physics: {
      active: false,
      angle: 0,
      velocity: 0,
      friction: 1,
      height: 0,
      verticalVelocity: 0,
      bounceStrength: 0,
      mass: Infinity,
      physicsType: PhysicsType.Static
    },
    props: {}
  })
}


================================================
FILE: client/src/utils/items.ts
================================================

// Determine CSS class based on item value
export function getRarityClass(value?: number): string {
  if (value === undefined) return 'item-common';
  
  if (value > 1000) return 'item-legendary';
  if (value > 500) return 'item-epic';
  if (value > 250) return 'item-rare';
  if (value > 100) return 'item-uncommon';
  return 'item-common';
}



================================================
FILE: client/src/utils/physics.ts
================================================
export enum PhysicsType {
  Static = "static",
  Field = "field",
  Dynamic = "dynamic"
}

export interface PhysicsProperties {
  angle: number;  // Angle in degrees
  velocity: number;  // Velocity in tiles per second
  friction: number;  // Friction coefficient between 0 and 1
  active: boolean;
  event?: string; // Event to emit when this item collides with another item
  height: number;  // Current height above ground in tile units
  verticalVelocity: number;  // Vertical velocity in tile units per second
  bounceStrength: number;  // How much velocity is retained on bounce (0-1)
  mass: number;  // Mass of object for collision calculations
  physicsType?: PhysicsType;  // Type of physics object (static, field, or dynamic), defaults to dynamic
}

export interface Vector2D {
  x: number;
  y: number;
}

export interface CollisionResult {
  collided: boolean;
  newVelocity?: Vector2D;
  newPosition?: Vector2D;
}

// Convert angle in degrees and magnitude to a vector
export function angleToVector(angle: number, magnitude: number): Vector2D {
  const radians = angle * (Math.PI / 180);
  return {
    x: Math.cos(radians) * magnitude,
    y: Math.sin(radians) * magnitude
  };
}

// Convert a vector to angle in degrees and magnitude
export function vectorToAngle(vector: Vector2D): { angle: number, magnitude: number } {
  const magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
  let angle = Math.atan2(vector.y, vector.x) * (180 / Math.PI);
  if (angle < 0) angle += 360;
  return { angle, magnitude };
}

// Apply physics update to an object's position based on its physics properties
export function updatePhysicsPosition(
  row: number, 
  col: number, 
  physics: PhysicsProperties, 
  deltaTime: number
): { row: number, col: number, physics: PhysicsProperties } {
  if (!physics.active) {
    return { row, col, physics };
  }

  // Convert angle and velocity to vector
  const velocityVector = angleToVector(physics.angle, physics.velocity);
  
  // Update position based on velocity
  const newCol = col + (velocityVector.x * deltaTime);
  const newRow = row + (velocityVector.y * deltaTime);
  
  // Apply friction to slow down the object
  let newVelocity = physics.velocity * (1 - physics.friction * deltaTime);
  
  // Update vertical position based on vertical velocity
  let newHeight = physics.height + (physics.verticalVelocity * deltaTime);
  let newVerticalVelocity = physics.verticalVelocity;
  
  // Apply gravity if object is above ground
  const gravity = 9.8; // Gravity constant in tile units per second squared
  newVerticalVelocity -= gravity * deltaTime;
  
  // Check for ground collision
  if (newHeight <= 0) {
    newHeight = 0;
    // Bounce with reduced velocity based on bounce strength
    if (newVerticalVelocity < 0) {
      newVerticalVelocity = -newVerticalVelocity * physics.bounceStrength;
      
      // Apply some horizontal bounce effect too
      const horizontalBounceEffect = 0.8; // How much of the bounce affects horizontal movement
      newVelocity = newVelocity * (1 + (Math.abs(newVerticalVelocity) * horizontalBounceEffect * 0.1));
      
      // Stop very small bounces to prevent endless tiny bounces
      if (Math.abs(newVerticalVelocity) < 0.1) {
        newVerticalVelocity = 0;
      }
    }
  }
  
  // Stop physics if velocity is very low
  if (newVelocity < .1) {
    newVelocity = 0;
  }

  if (newHeight < .05 && Math.abs(newVerticalVelocity) < .05) {
    newHeight = 0;
    newVerticalVelocity = 0;
  }
  
  // Update physics properties
  const updatedPhysics = { 
    ...physics, 
    velocity: newVelocity,
    height: newHeight,
    verticalVelocity: newVerticalVelocity,
    active: newVelocity > 0 || newHeight > 0 || Math.abs(newVerticalVelocity) > 0
  };
  
  return { row: newRow, col: newCol, physics: updatedPhysics };
}

// Check for collision between two objects
export function checkCollision(
  obj1: { row: number, col: number, width: number, depth: number, physics: PhysicsProperties },
  obj2: { row: number, col: number, width: number, depth: number, physics: PhysicsProperties }
): boolean {
  // Improved height-based collision check
  // Calculate the effective height range for each object
  const obj1MinHeight = obj1.physics.height;
  const obj1MaxHeight = obj1.physics.height + Math.max(obj1.width, obj1.depth);
  const obj2MinHeight = obj2.physics.height;
  const obj2MaxHeight = obj2.physics.height + Math.max(obj2.width, obj2.depth);
  
  // Check if height ranges overlap
  if (obj1MaxHeight < obj2MinHeight || obj1MinHeight > obj2MaxHeight) {
    return false;
  }
  
  // Check for rectangle overlap
  return (
    obj1.col < obj2.col + obj2.width &&
    obj1.col + obj1.width > obj2.col &&
    obj1.row < obj2.row + obj2.depth &&
    obj1.row + obj1.depth > obj2.row
  );
}

// Handle collision between two objects with momentum transfer
export function handleCollision(
  obj1: { row: number, col: number, width: number, depth: number, physics: PhysicsProperties },
  obj2: { row: number, col: number, width: number, depth: number, physics: PhysicsProperties }
): { obj1Physics: PhysicsProperties, obj2Physics: PhysicsProperties } {
  // Convert angles and velocities to vectors
  const v1 = angleToVector(obj1.physics.angle, obj1.physics.velocity);
  const v2 = angleToVector(obj2.physics.angle, obj2.physics.velocity);
  
  // Calculate centers of objects
  const center1 = { x: obj1.col + obj1.width / 2, y: obj1.row + obj1.depth / 2 };
  const center2 = { x: obj2.col + obj2.width / 2, y: obj2.row + obj2.depth / 2 };
  
  // Calculate collision normal (direction from obj1 to obj2)
  const collisionNormal = {
    x: center2.x - center1.x,
    y: center2.y - center1.y
  };
  
  // Normalize the collision normal
  const distance = Math.sqrt(collisionNormal.x * collisionNormal.x + collisionNormal.y * collisionNormal.y);
  if (distance === 0) {
    // Objects are exactly at the same position, push in random direction
    const randomAngle = Math.random() * 360;
    collisionNormal.x = Math.cos(randomAngle * (Math.PI / 180));
    collisionNormal.y = Math.sin(randomAngle * (Math.PI / 180));
  } else {
    collisionNormal.x /= distance;
    collisionNormal.y /= distance;
  }
  
  // Calculate relative velocity
  const relativeVelocity = {
    x: v2.x - v1.x,
    y: v2.y - v1.y
  };
  
  // Calculate relative velocity in terms of the collision normal
  const velocityAlongNormal = relativeVelocity.x * collisionNormal.x + relativeVelocity.y * collisionNormal.y;
  
  // Do not resolve if objects are moving away from each other
  if (velocityAlongNormal > 0) {
    return { obj1Physics: obj1.physics, obj2Physics: obj2.physics };
  }
  
  // Calculate restitution (bounciness)
  const restitution = Math.min(obj1.physics.bounceStrength, obj2.physics.bounceStrength);
  
  // Calculate impulse scalar
  const impulseScalar = -(1 + restitution) * velocityAlongNormal / 
                        (1 / obj1.physics.mass + 1 / obj2.physics.mass);
  
  // Apply impulse
  const impulse = {
    x: impulseScalar * collisionNormal.x,
    y: impulseScalar * collisionNormal.y
  };
  
  // Update velocities
  const newV1 = {
    x: v1.x - (impulse.x / obj1.physics.mass),
    y: v1.y - (impulse.y / obj1.physics.mass)
  };
  
  const newV2 = {
    x: v2.x + (impulse.x / obj2.physics.mass),
    y: v2.y + (impulse.y / obj2.physics.mass)
  };
  
  // Convert back to angle and magnitude
  const newObj1 = vectorToAngle(newV1);
  const newObj2 = vectorToAngle(newV2);
  
  // Calculate height difference and adjust vertical velocities to separate objects vertically
  const heightDifference = obj1.physics.height - obj2.physics.height;
  let obj1VerticalVelocity = obj1.physics.verticalVelocity;
  let obj2VerticalVelocity = obj2.physics.verticalVelocity;
  
  // If objects are at similar heights, give them opposing vertical velocities to separate
  if (Math.abs(heightDifference) < 0.5) {
    const verticalSeparationImpulse = 2.0; // Strength of vertical separation
    if (heightDifference > 0) {
      // obj1 is higher, push it up more
      obj1VerticalVelocity = Math.max(obj1VerticalVelocity, verticalSeparationImpulse);
      obj2VerticalVelocity = Math.min(obj2VerticalVelocity, -verticalSeparationImpulse * 0.5);
    } else {
      // obj2 is higher, push it up more
      obj2VerticalVelocity = Math.max(obj2VerticalVelocity, verticalSeparationImpulse);
      obj1VerticalVelocity = Math.min(obj1VerticalVelocity, -verticalSeparationImpulse * 0.5);
    }
  } else {
    // Add a small random vertical bounce on collision
    obj1VerticalVelocity += Math.random() * 0.8 - 0.2; // -0.2 to 0.6 range
    obj2VerticalVelocity += Math.random() * 0.8 - 0.2;
  }
  
  // Create new physics objects with updated values
  const obj1Physics: PhysicsProperties = {
    ...obj1.physics,
    active: true,
    angle: newObj1.angle,
    velocity: newObj1.magnitude,
    verticalVelocity: obj1VerticalVelocity
  };
  
  const obj2Physics: PhysicsProperties = {
    ...obj2.physics,
    active: true,
    angle: newObj2.angle,
    velocity: newObj2.magnitude,
    verticalVelocity: obj2VerticalVelocity
  };
  
  return { obj1Physics, obj2Physics };
}

// Check for wall collisions and update physics accordingly
export function handleWallCollision(
  row: number,
  col: number,
  width: number,
  depth: number,
  physics: PhysicsProperties,
  walls: Array<{ row: number, col: number, width: number, depth: number, height?: number }>
): { row: number, col: number, physics: PhysicsProperties } {  
  let newRow = row;
  let newCol = col;
  let newPhysics = { ...physics };
  
  // Check collision with each wall
  for (const wall of walls) {
    // Get wall height (default to 1 if not specified)
    const wallHeight = wall.height !== undefined ? wall.height : 1;
    
    // Skip collision check if object's height is greater than wall's height
    if (physics.height > wallHeight) {
      continue;
    }
    
    // Check if object overlaps with wall
    if (
      col < wall.col + wall.width &&
      col + width > wall.col &&
      row < wall.row + wall.depth &&
      row + depth > wall.row
    ) {
      // Calculate overlap on each axis
      const overlapLeft = (wall.col + wall.width) - col;
      const overlapRight = (col + width) - wall.col;
      const overlapTop = (wall.row + wall.depth) - row;
      const overlapBottom = (row + depth) - wall.row;
      
      // Find the smallest overlap
      const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
      
      // Determine which side of the wall was hit
      if (minOverlap === overlapLeft) {
        // Hit left side of wall
        newCol = wall.col + wall.width;
        // Reflect angle
        const velocity = angleToVector(physics.angle, physics.velocity);
        velocity.x = -velocity.x * physics.bounceStrength;
        const newAngleData = vectorToAngle(velocity);
        newPhysics.angle = newAngleData.angle;
        newPhysics.velocity = newAngleData.magnitude;
      } else if (minOverlap === overlapRight) {
        // Hit right side of wall
        newCol = wall.col - width;
        // Reflect angle
        const velocity = angleToVector(physics.angle, physics.velocity);
        velocity.x = -velocity.x * physics.bounceStrength;
        const newAngleData = vectorToAngle(velocity);
        newPhysics.angle = newAngleData.angle;
        newPhysics.velocity = newAngleData.magnitude;
      } else if (minOverlap === overlapTop) {
        // Hit top side of wall
        newRow = wall.row + wall.depth;
        // Reflect angle
        const velocity = angleToVector(physics.angle, physics.velocity);
        velocity.y = -velocity.y * physics.bounceStrength;
        const newAngleData = vectorToAngle(velocity);
        newPhysics.angle = newAngleData.angle;
        newPhysics.velocity = newAngleData.magnitude;
      } else if (minOverlap === overlapBottom) {
        // Hit bottom side of wall
        newRow = wall.row - depth;
        // Reflect angle
        const velocity = angleToVector(physics.angle, physics.velocity);
        velocity.y = -velocity.y * physics.bounceStrength;
        const newAngleData = vectorToAngle(velocity);
        newPhysics.angle = newAngleData.angle;
        newPhysics.velocity = newAngleData.magnitude;
      }

      newPhysics.active = true;
    }
  }
  
  return { row: newRow, col: newCol, physics: newPhysics };
}

// Function to detect and fix objects that are stuck in the air
export function detectAndFixStuckObjects(
  obj: { row: number, col: number, width: number, depth: number, physics: PhysicsProperties }
): PhysicsProperties {
  const physics = obj.physics;
  
  // Check if object is potentially stuck (above ground but not moving much)
  if (
    physics.height > 0.1 && // Object is above ground
    Math.abs(physics.verticalVelocity) < 0.2 && // Very little vertical movement
    physics.velocity < 0.2 // Very little horizontal movement
  ) {
    // Object appears to be stuck, apply a small downward force to help it fall
    return {
      ...physics,
      active: true,
      verticalVelocity: -1.0, // Apply downward velocity
      // Add a tiny random horizontal impulse to help break free from overlaps
      angle: Math.random() * 360,
      velocity: 0.5 + Math.random() * 0.5
    };
  }
  
  // Check for objects that have been above ground with minimal movement for too long
  // This is a more aggressive unstuck mechanism that should rarely be needed
  if (
    physics.height > 3 && // Significantly above ground
    Math.abs(physics.verticalVelocity) < 0.1 && // Almost no vertical movement
    physics.velocity < 0.1 // Almost no horizontal movement
  ) {
    // Force object to ground level with a reset
    return {
      ...physics,
      active: true,
      height: 0,
      verticalVelocity: 0,
      velocity: 0
    };
  }
  
  return physics;
}


================================================
FILE: client/src/views/GameView.vue
================================================
<template>
  <div class="app">
    <TutorialScreen />
    <LoadingScreen :progress="gameStore.preloadProgress" />
    <div class="control-buttons">
      <div class="button-row">
        <button class="debug-button" @click="gameStore.debug = !gameStore.debug">Debug</button>
        <button class="source-button" @click="openSourceCode">Source</button>
        <button class="guide-button" @click="openGuide">Guide</button>
      </div>
      <div v-if="gameStore.debug" class="physics-indicator" :class="{ active: hasActivePhysics }">Physics</div>
    </div>
    <div class="game-container" :style="{ width: `${tileSize * gridSize}px`, height: `${tileSize * gridSize}px` }">
      <GameGrid :grid-size="gridSize" :tile-size="tileSize" />
      <GameObjects :gameObjects="gameStore.objects" :tileSize="tileSize" />
      <HintDisplay />
      <HUD />
      <RandomChat />
    </div>
    <div class="connection-status" :class="{ connected: gameStore.wsConnected }" />
    <!-- Dialogs are not constantly visible, but will appear as needed -->
    <ItemDialog />
    <SellDialog />
    <DiscardDialog />
    <SkillResultDialog />
    <!-- Preloader component to keep static assets in memory -->
    <Preloader />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useGameStore } from '../stores/game'
import GameGrid from '../components/GameGrid.vue'
import GameObjects from '../components/GameObjects.vue'
import HintDisplay from '../components/HintDisplay.vue'
import ItemDialog from '../components/ItemDialog.vue'
import SellDialog from '../components/SellDialog.vue'
import DiscardDialog from '../components/DiscardDialog.vue'
import SkillResultDialog from '../components/SkillResultDialog.vue'
import HUD from '../components/HUD.vue'
import RandomChat from '../components/RandomChat.vue'
import { setupGameObjects } from '../utils/init-world'
import { storeToRefs } from 'pinia'
import LoadingScreen from '../components/LoadingScreen.vue'
import TutorialScreen from '../components/TutorialScreen.vue'
import Preloader from '../components/Preloader.vue'

const gridSize = ref(20)
const gameStore = useGameStore()
const { tileSize } = storeToRefs(gameStore);
const { hasActivePhysics } = storeToRefs(gameStore)

const calculateTileSize = () => {
  const minDimension = Math.min(window.innerWidth, window.innerHeight)
  tileSize.value = Math.floor(minDimension / gridSize.value)
}

const initializeWorld = () => {
  setupGameObjects(gameStore, gridSize.value)
}

const openSourceCode = () => {
  window.open('https://github.com/kirodotdev/spirit-of-kiro/', '_blank')
}

const openGuide = () => {
  window.open('https://kiro.dev/docs/guides/learn-by-playing/', '_blank')
}

onMounted(() => {
  calculateTileSize()
  window.addEventListener('resize', calculateTileSize)
  initializeWorld()
  // Blur any focused elements
  if (document.activeElement instanceof HTMLElement) {
    document.activeElement.blur()
  }
})

onUnmounted(() => {
  window.removeEventListener('resize', calculateTileSize)
  gameStore.clearObjects()
  if (gameStore.ws) {
    gameStore.ws.close()
  }
})
</script>

<style scoped>
.app {
  position: relative;
  width: 100vw;
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
}

.game-container {
  position: relative;
}

.debug-button {
  top: 10px;
  left: 10px;
  padding: 8px 16px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.debug-button:hover {
  background-color: #45a049;
}

.source-button {
  top: 10px;
  left: 10px;
  padding: 8px 16px;
  background-color: #2196F3;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.source-button:hover {
  background-color: #1976D2;
}

.guide-button {
  top: 10px;
  left: 10px;
  padding: 8px 16px;
  background-color: #FF9800;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.guide-button:hover {
  background-color: #F57C00;
}

.control-buttons {
  position: absolute;
  top: 10px;
  left: 10px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: flex-start;
  z-index: 9999;
  /* Ensure debug panel is above all other elements */
}

.button-row {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
}

.physics-indicator {
  padding: 4px 11px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}

.physics-indicator.active {
  background-color: #ff4444;
}

.connection-status {
  position: absolute;
  bottom: 10px;
  left: 10px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background-color: #ff0000;
  transition: background-color 0.3s ease;
}

.connection-status.connected {
  background-color: #00ff00;
}
</style>



================================================
FILE: client/src/views/HomeView.vue
================================================
<script setup lang="ts">
const openSourceCode = () => {
  window.open('https://github.com/kirodotdev/spirit-of-kiro/', '_blank')
}

const openGuide = () => {
  window.open('https://kiro.dev/docs/guides/learn-by-playing/', '_blank')
}
</script>

<template>
  <div class="home">
    <div class="hero">
      <div class="hero-content">
        <img src="../assets/kiro-ghost/south.png" alt="Ghost" class="ghost-image" />
        <div class="hero-text">
          <h1>Spirit of Kiro</h1>
          <p class="tagline">Imagine endless possibilities</p>
          <div class="button-group">
            <router-link to="/play" class="play-button">
              Start Exploring
            </router-link>
            <div class="utility-buttons">
              <button class="source-button" @click="openSourceCode">Source</button>
              <button class="guide-button" @click="openGuide">Guide</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="content">
      <div class="section">
        <p class="large-text">Every item tells a story. Every discovery reveals a new world. Step into a realm where forgotten objects find new purpose.</p>
      </div>

      <div class="features">
        <div class="feature">
          <h3>Unique Treasures</h3>
          <p>Every AI generated item is unique. Each discovery is yours alone.</p>
        </div>
        <div class="feature">
          <h3>Infinite Crafting</h3>
          <p>Combine items into complex creations or break them down to their quantum essence.</p>
        </div>
        <div class="feature">
          <h3>Dynamic Interactions</h3>
          <p>Watch as your discoveries come alive with unexpected behaviors and reactions.</p>
        </div>
      </div>

      <div class="section">
        <h2>Your journey awaits.</h2>
        <p class="large-text">Collect. Examine. Transform. Every action shapes your experience in this ever-evolving workshop.</p>
      </div>
    </div>
  </div>
</template>

<style scoped>
.home {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
  color: white;
  text-align: center;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
}

.hero {
  padding: 6rem 2rem 3rem;
  width: 100%;
  max-width: 1200px;
  min-height: 80vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.content {
  width: 100%;
  max-width: 1200px;
  padding: 0 2rem 6rem;
}

h1 {
  font-size: 5.5rem;
  font-weight: 700;
  margin-bottom: 1rem;
  background: linear-gradient(135deg, #fff 0%, #a0a0a0 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  letter-spacing: -0.02em;
}

h2 {
  font-size: 3rem;
  font-weight: 600;
  margin-bottom: 1.5rem;
  letter-spacing: -0.02em;
}

.tagline {
  font-size: 1.8rem;
  color: #888;
  margin-bottom: 2.5rem;
  font-weight: 400;
  letter-spacing: 0.02em;
}

.large-text {
  font-size: 1.4rem;
  line-height: 1.4;
  color: #888;
  max-width: 800px;
  margin: 0 auto 3rem;
}

.section {
  margin-bottom: 6rem;
  padding: 0 2rem;
}

.features {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 2rem;
  margin: 3rem 0;
  padding: 0 2rem;
}

.feature {
  padding: 2rem;
  background-color: rgba(255, 255, 255, 0.02);
  border-radius: 20px;
  border: 1px solid rgba(255, 255, 255, 0.05);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.feature:hover {
  transform: translateY(-4px);
  background-color: rgba(255, 255, 255, 0.04);
  border-color: rgba(255, 255, 255, 0.1);
}

.feature h3 {
  margin-bottom: 1rem;
  color: #fff;
  font-size: 1.6rem;
  font-weight: 600;
  letter-spacing: -0.01em;
}

.feature p {
  font-size: 1.1rem;
  color: #888;
  line-height: 1.6;
}

.play-button {
  display: inline-block;
  padding: 1.2rem 4rem;
  font-size: 1.5rem;
  font-weight: 500;
  text-decoration: none;
  color: white;
  background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
  border-radius: 12px;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  border: none;
  box-shadow: 0 4px 20px rgba(76, 175, 80, 0.2);
}

.play-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 25px rgba(76, 175, 80, 0.3);
  background: linear-gradient(135deg, #45a049 0%, #4CAF50 100%);
}

.button-group {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
}

.utility-buttons {
  display: flex;
  gap: 1rem;
}

.source-button {
  padding: 0.8rem 2rem;
  background-color: #2196F3;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 500;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  text-decoration: none;
  display: inline-block;
  box-shadow: 0 2px 10px rgba(33, 150, 243, 0.2);
}

.source-button:hover {
  background-color: #1976D2;
  transform: translateY(-2px);
  box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
}

.guide-button {
  padding: 0.8rem 2rem;
  background-color: #FF9800;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 500;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  text-decoration: none;
  display: inline-block;
  box-shadow: 0 2px 10px rgba(255, 152, 0, 0.2);
}

.guide-button:hover {
  background-color: #F57C00;
  transform: translateY(-2px);
  box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
}

.hero-content {
  display: flex;
  align-items: flex-start;
  gap: 2rem;
  max-width: 1200px;
  margin: 0 auto;
  position: relative;
}

.hero-text {
  flex: 1;
  position: relative;
}

.ghost-image {
  width: 180px;
  height: auto;
  filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.2));
  position: absolute;
  left: -160px;
  top: 0;
  animation: float 2s ease-in-out infinite;
}

@keyframes float {
  0% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-8px);
  }
  100% {
    transform: translateY(0);
  }
}

@media (max-width: 768px) {
  .hero {
    padding: 4rem 1rem 2rem;
    min-height: 70vh;
  }

  .content {
    padding: 0 1rem 4rem;
  }

  h1 {
    font-size: 3.5rem;
  }

  h2 {
    font-size: 2.2rem;
  }

  .tagline {
    font-size: 1.4rem;
    margin-bottom: 2rem;
  }

  .large-text {
    font-size: 1.2rem;
  }

  .features {
    grid-template-columns: 1fr;
    padding: 0 1rem;
  }

  .section {
    padding: 0 1rem;
    margin-bottom: 3rem;
  }

  .play-button {
    padding: 1rem 3rem;
    font-size: 1.3rem;
  }

  .hero-content {
    flex-direction: column;
    gap: 1rem;
  }

  .ghost-image {
    position: relative;
    left: 0;
    top: 0;
    width: 120px;
    margin: 0 auto;
  }

  .utility-buttons {
    flex-direction: column;
    gap: 0.8rem;
  }

  .source-button,
  .guide-button {
    padding: 0.7rem 1.5rem;
    font-size: 0.9rem;
  }
}
</style>


================================================
FILE: client/src/views/SignInView.vue
================================================
<template>
  <div class="auth-screen">
    <div class="utility-buttons-top">
      <button class="source-button" @click="openSourceCode">Source</button>
      <button class="guide-button" @click="openGuide">Guide</button>
    </div>
    <div class="auth-wrapper">
      <router-link to="/" class="back-link">← Back to Home</router-link>
      <div class="auth-container">
        <h1>Login</h1>
        
        <form @submit.prevent="handleSubmit" class="auth-form">
          <div class="form-group">
            <label for="username">Email Adddress</label>
            <input 
              type="text" 
              id="username" 
              v-model="username" 
              required
              autocomplete="username"
            />
          </div>
          
          <div class="form-group">
            <label for="password">Password</label>
            <input 
              type="password" 
              id="password" 
              v-model="password" 
              required
              autocomplete="current-password"
            />
          </div>

          <div v-if="error" class="error-message">
            {{ error }}
          </div>

          <button type="submit" class="submit-button">
            Login
          </button>

          <router-link to="/signup" class="toggle-button">
            Need an account? Sign Up
          </router-link>
        </form>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onUnmounted, onMounted } from 'vue'
import { useGameStore } from '../stores/game'
import { useRouter } from 'vue-router'

const gameStore = useGameStore()
const router = useRouter()
const username = ref('')
const password = ref('')
const error = ref('')

// Store listener IDs
let successListenerId: string | null = null;
let failureListenerId: string | null = null;

// Setup event listeners
const setupListeners = () => {
  // Remove any existing listeners first
  removeListeners();
  
  successListenerId = gameStore.addEventListener('signin_success', (data) => {
    if (data && data.userId) {
      gameStore.userId = data.userId
    }
    router.push('/play')
    removeListeners();
  })
  
  failureListenerId = gameStore.addEventListener('signin_failure', (data) => {
    error.value = data || 'Authentication failed'
    removeListeners();
  })
}

// Cleanup event listeners
const removeListeners = () => {
  if (successListenerId) {
    gameStore.removeEventListener('signin_success', successListenerId)
    successListenerId = null;
  }
  if (failureListenerId) {
    gameStore.removeEventListener('signin_failure', failureListenerId)
    failureListenerId = null;
  }
}

const openSourceCode = () => {
  window.open('https://github.com/kirodotdev/spirit-of-kiro/', '_blank')
}

const openGuide = () => {
  window.open('https://kiro.dev/docs/guides/learn-by-playing/', '_blank')
}

const handleSubmit = async () => {
  error.value = ''
  try {
    if (!gameStore.ws) {
      // Try to reconnect if WebSocket is not available
      gameStore.reconnect()
      throw new Error('No WebSocket connection available. Attempting to reconnect...')
    }

    // Setup listeners before sending message
    setupListeners();

    const message = {
      type: 'signin',
      body: {
        username: username.value,
        password: password.value
      }
    }

    // Send authentication message
    gameStore.ws.send(JSON.stringify(message))
  } catch (e: any) {
    error.value = e.message || 'An error occurred'
  }
}

// Setup connection status listeners
let connectionListenerId: string | null = null;
let reconnectFailedId: string | null = null;

onMounted(() => {
  // Listen for connection status changes
  connectionListenerId = gameStore.addEventListener('reconnect-attempt', (data) => {
    error.value = `Connection lost. Reconnecting... (${data.attempt}/${data.maxAttempts})`;
  });
  
  reconnectFailedId = gameStore.addEventListener('reconnect-failed', () => {
    error.value = 'Failed to reconnect. Please try again later.';
  });
});

// Cleanup listeners when component is unmounted
onUnmounted(() => {
  removeListeners();
  
  // Clean up connection status listeners
  if (connectionListenerId) {
    gameStore.removeEventListener('reconnect-attempt', connectionListenerId);
  }
  
  if (reconnectFailedId) {
    gameStore.removeEventListener('reconnect-failed', reconnectFailedId);
  }
})
</script>

<style scoped>
.auth-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.auth-wrapper {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 400px;
}

.back-link {
  color: #4CAF50;
  text-decoration: none;
  font-size: 0.9rem;
  transition: color 0.3s;
  margin-bottom: 1rem;
  align-self: flex-start;
}

.auth-container {
  background: #1a1a1a;
  padding: 2rem;
  border-radius: 8px;
  width: 100%;
  max-width: 400px;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

h1 {
  color: #fff;
  text-align: center;
  margin-bottom: 2rem;
}

.auth-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

label {
  color: #fff;
  font-size: 0.9rem;
}

input {
  padding: 0.75rem;
  border-radius: 4px;
  border: 1px solid #333;
  background: #222;
  color: #fff;
  font-size: 1rem;
}

input:focus {
  outline: none;
  border-color: #4CAF50;
}

.submit-button {
  padding: 0.75rem;
  background: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.3s;
}

.submit-button:hover {
  background: #45a049;
}

.toggle-button {
  background: none;
  border: none;
  color: #4CAF50;
  cursor: pointer;
  padding: 0.5rem;
  font-size: 0.9rem;
  text-decoration: none;
  text-align: center;
}

.toggle-button:hover {
  text-decoration: underline;
}

.error-message {
  color: #ff4444;
  text-align: center;
  font-size: 0.9rem;
  margin-top: 0.5rem;
}

.utility-buttons-top {
  position: absolute;
  top: 20px;
  right: 20px;
  display: flex;
  gap: 10px;
  z-index: 1001;
}

.source-button {
  padding: 8px 16px;
  background-color: #2196F3;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.3s;
}

.source-button:hover {
  background-color: #1976D2;
}

.guide-button {
  padding: 8px 16px;
  background-color: #FF9800;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.3s;
}

.guide-button:hover {
  background-color: #F57C00;
}
</style> 


================================================
FILE: client/src/views/SignUpView.vue
================================================
<template>
  <div class="auth-screen">
    <div class="utility-buttons-top">
      <button class="source-button" @click="openSourceCode">Source</button>
      <button class="guide-button" @click="openGuide">Guide</button>
    </div>
    <div class="auth-wrapper">
      <router-link to="/" class="back-link">← Back to Home</router-link>
      <div class="auth-container">
        <h1>Sign Up</h1>
        
        <form @submit.prevent="handleSubmit" class="auth-form">
          <div class="form-group">
            <label for="username">Email Address</label>
            <input 
              type="text" 
              id="username" 
              v-model="username" 
              required
              autocomplete="username"
            />
          </div>
          
          <div class="form-group">
            <label for="password">Password</label>
            <input 
              type="password" 
              id="password" 
              v-model="password" 
              required
              autocomplete="new-password"
              @input="validatePassword"
            />
            <div class="password-requirements">
              <div class="requirement" :class="{ met: passwordValidation.length }">
                ✓ At least 8 characters
              </div>
              <div class="requirement" :class="{ met: passwordValidation.lowercase }">
                ✓ Contains lowercase letter
              </div>
              <div class="requirement" :class="{ met: passwordValidation.uppercase }">
                ✓ Contains uppercase letter
              </div>
              <div class="requirement" :class="{ met: passwordValidation.number }">
                ✓ Contains number
              </div>
              <div class="requirement" :class="{ met: passwordValidation.symbol }">
                ✓ Contains symbol
              </div>
            </div>
          </div>

          <div v-if="error" class="error-message">
            {{ error }}
          </div>

          <button 
            type="submit" 
            class="submit-button"
            :disabled="!isFormValid"
            :class="{ 'disabled': !isFormValid }"
          >
            Sign Up
          </button>

          <router-link to="/signin" class="toggle-button">
            Already have an account? Login
          </router-link>
        </form>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onUnmounted, onMounted, computed } from 'vue'
import { useGameStore } from '../stores/game'
import { useRouter } from 'vue-router'

const gameStore = useGameStore()
const router = useRouter()
const username = ref('')
const password = ref('')
const error = ref('')

// Store listener IDs
let successListenerId: string | null = null;
let failureListenerId: string | null = null;

// Setup event listeners
const setupListeners = () => {
  // Remove any existing listeners first
  removeListeners();
  
  successListenerId = gameStore.addEventListener('signup_success', (data) => {
    if (data && data.userId) {
      gameStore.userId = data.userId
    }
    router.push('/play')
    removeListeners();
  })
  
  failureListenerId = gameStore.addEventListener('signup_failure', (data) => {
    error.value = data || 'Authentication failed'
    removeListeners();
  })
}

// Cleanup event listeners
const removeListeners = () => {
  if (successListenerId) {
    gameStore.removeEventListener('signup_success', successListenerId)
    successListenerId = null;
  }
  if (failureListenerId) {
    gameStore.removeEventListener('signup_failure', failureListenerId)
    failureListenerId = null;
  }
}

const passwordValidation = ref({
  length: false,
  lowercase: false,
  uppercase: false,
  number: false,
  symbol: false
})

const openSourceCode = () => {
  window.open('https://github.com/kirodotdev/spirit-of-kiro/', '_blank')
}

const openGuide = () => {
  window.open('https://kiro.dev/docs/guides/learn-by-playing/', '_blank')
}

const validatePassword = () => {
  const pass = password.value
  passwordValidation.value = {
    length: pass.length >= 8,
    lowercase: /[a-z]/.test(pass),
    uppercase: /[A-Z]/.test(pass),
    number: /[0-9]/.test(pass),
    symbol: /[!@#$%^&*(),.?":{}|<>]/.test(pass)
  }
}

const handleSubmit = async () => {
  error.value = ''
  try {
    // Check if password meets all requirements
    if (!Object.values(passwordValidation.value).every(Boolean)) {
      error.value = 'Password does not meet all requirements'
      return
    }

    if (!gameStore.ws) {
      // Try to reconnect if WebSocket is not available
      gameStore.reconnect()
      throw new Error('No WebSocket connection available. Attempting to reconnect...')
    }

    // Setup listeners before sending message
    setupListeners();

    const message = {
      type: 'signup',
      body: {
        username: username.value,
        password: password.value
      }
    }

    // Send authentication message
    gameStore.ws.send(JSON.stringify(message))
  } catch (e: any) {
    error.value = e.message || 'An error occurred'
  }
}

// Setup connection status listeners
let connectionListenerId: string | null = null;
let reconnectFailedId: string | null = null;

onMounted(() => {
  // Listen for connection status changes
  connectionListenerId = gameStore.addEventListener('reconnect-attempt', (data) => {
    error.value = `Connection lost. Reconnecting... (${data.attempt}/${data.maxAttempts})`;
  });
  
  reconnectFailedId = gameStore.addEventListener('reconnect-failed', () => {
    error.value = 'Failed to reconnect. Please try again later.';
  });
});

// Cleanup listeners when component is unmounted
onUnmounted(() => {
  removeListeners();
  
  // Clean up connection status listeners
  if (connectionListenerId) {
    gameStore.removeEventListener('reconnect-attempt', connectionListenerId);
  }
  
  if (reconnectFailedId) {
    gameStore.removeEventListener('reconnect-failed', reconnectFailedId);
  }
})

const isFormValid = computed(() => {
  return username.value.length > 0 && 
         Object.values(passwordValidation.value).every(Boolean)
})
</script>

<style scoped>
.auth-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.auth-wrapper {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 400px;
}

.auth-container {
  position: relative;
  background: #1a1a1a;
  padding: 2rem;
  border-radius: 8px;
  width: 100%;
  max-width: 400px;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

h1 {
  color: #fff;
  text-align: center;
  margin-bottom: 2rem;
}

.auth-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

label {
  color: #fff;
  font-size: 0.9rem;
}

input {
  padding: 0.75rem;
  border-radius: 4px;
  border: 1px solid #333;
  background: #222;
  color: #fff;
  font-size: 1rem;
}

input:focus {
  outline: none;
  border-color: #4CAF50;
}

.submit-button {
  padding: 0.75rem;
  background: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.3s;
}

.submit-button:hover {
  background: #45a049;
}

.submit-button.disabled {
  background: #666;
  cursor: not-allowed;
  opacity: 0.7;
}

.submit-button.disabled:hover {
  background: #666;
}

.toggle-button {
  background: none;
  border: none;
  color: #4CAF50;
  cursor: pointer;
  padding: 0.5rem;
  font-size: 0.9rem;
  text-decoration: none;
  text-align: center;
}

.toggle-button:hover {
  text-decoration: underline;
}

.error-message {
  color: #ff4444;
  text-align: center;
  font-size: 0.9rem;
  margin-top: 0.5rem;
}

.back-link {
  color: #4CAF50;
  text-decoration: none;
  font-size: 0.9rem;
  transition: color 0.3s;
  margin-bottom: 1rem;
  align-self: flex-start;
}

.back-link:hover {
  color: #45a049;
}

.password-requirements {
  margin-top: 0.5rem;
  font-size: 0.8rem;
  color: #666;
}

.requirement {
  margin: 0.2rem 0;
  color: #666;
}

.requirement.met {
  color: #4CAF50;
}

.utility-buttons-top {
  position: absolute;
  top: 20px;
  right: 20px;
  display: flex;
  gap: 10px;
  z-index: 1001;
}

.source-button {
  padding: 8px 16px;
  background-color: #2196F3;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.3s;
}

.source-button:hover {
  background-color: #1976D2;
}

.guide-button {
  padding: 8px 16px;
  background-color: #FF9800;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.3s;
}

.guide-button:hover {
  background-color: #F57C00;
}
</style> 


================================================
FILE: docs/appsec-overview.md
================================================
# Application Security and Architecture Documentation

High level overview of the components and how they talk to each other:

```mermaid
graph LR
    Client[Game Client in Browser] -->|WSS|Server[Game Server in AWS Fargate] -->|HTTPS|Images[Item Images Service in AWS Fargate]
```

## Game Client

The Game Client is a Vue.js 3 single page application that provides the user interface and game experience in the user's browser. It maintains real-time state synchronization with the server through a WebSocket connection to the game server.

```mermaid
graph TB
    subgraph Player Browser
        UI[Running Game Client]
        Store[Pinia Store]
        Systems[Game Systems]
        UI --> Store
        Store <--> Systems
    end

    subgraph Out
        WS[Game Server]
        ImageDist[Images CloudFront]
        FrontendDist[Frontend CloudFront with Lambda@Edge basic auth]
    end

    subgraph Build
       Repo[Client Source Code]
       viteBuild[vite build]
       static[Static HTML, JS, and Image Assets]
       S3[S3 Bucket]
       Repo --> viteBuild --> static --> S3
    end

    Systems <-->|WSS|WS
    UI -->|HTTPS|ImageDist
    UI -->|HTTPS|FrontendDist -->|Origin Access Control|S3
```

### Technology Stack
- **Framework**: Vue.js 3 with Composition API
- **Build Tool**: Vite
- **Language**: TypeScript
- **State Management**: Pinia
- **Routing**: Vue Router
- **Hosting**: S3, accessed via CloudFront

The game client is built using Vite, and hosted as static HTML, JS, CSS, and image assets in an S3 bucket. Browsers fetch from the S3 bucket via CloudFront.

### Inbound Connections
- The player's browser loads the game client as static prebuilt assets delivered by CloudFront, using the S3 bucket as an origin. CloudFront uses an Origin Access Control policy to fetch from the S3 bucket. In preview, CloudFront also has a Lambda@Edge function that implements HTTP basic auth to restrict public access.

### Outbound Connections
- Browser running client connects via WSS to a WebSocket based game server via CloudFront in order to sync various forms of state:
  - Authentication (signin/signup) via WebSocket handlers
  - Item operations (pull, move, discard, appraise, buy)
  - Inventory queries and synchronization
  - Periodic ping/pong for connection health
- Browser running client connects via HTTPS to a CloudFront distribution that hosts dynamically generated item images
- Browser running client connects via HTTPS to it's own CloudFront distribution to load in additional static, prebuilt assets in the background as the user accesses new screens

## Game Server

The Game Server is a Bun-based WebSocket server that manages game state, player authentication, and coordinates interactions between clients and external services. It uses DynamoDB for persistent storage and integrates with AWS Bedrock for AI-powered item generation. It calls a downstream image generation service that creates dynamic images for game items.

```mermaid
graph TB
    subgraph Server
        WS[WebSocket Server in AWS Fargate]
        Handlers[Message Handlers]
        State[State Management]
    end

    subgraph In
        Client[Game Clients]
    end

    subgraph Out
        DB[DynamoDB]
        Bedrock[AWS Bedrock]
        Images[Item Images Service]
        Cognito[Amazon Cognito]
    end

    Client <--> WS
    WS --> Handlers
    Handlers --> State
    State -->|IAM|DB
    Handlers -->|IAM|Bedrock
    Handlers -->|HTTPS|Images
    Handlers -->|IAM|Cognito
```

### Technology Stack
- **Runtime**: Bun
- **Language**: TypeScript
- **WebSocket**: Native Bun WebSocket server
- **Database**: Amazon DynamoDB
- **Hosting:** AWS Fargate, orchestrated by Amazon ECS
- **AI Services**: AWS Bedrock

### Inbound Connections
- WebSocket connections from Game Clients, via **CloudFront**

### Outbound Connections
1. The game server persists data in **DynamoDB**. The game server uses an ECS task IAM role to grant it permissions to communicate with the following tables:
   - `Users` Table: User account metadata
   - `Usernames` Table: Maps usernames to user ID's
   - `Items` Table: Game item metadata
   - `Inventory` Table: Inventory ID to item mapping
   - `Location` Table: Item ID to inventory ID mapping
   - `Persona` Table: Metadata about player characters

2. The game server authenticates users via **Amazon Cognito**
   - The game server uses an ECS task IAM role to grant it permissions to verify tokens and manage users
   - Implements JWT token validation for WebSocket connections
   - Manages user sessions and authentication state

3. The game server requests image URL's from **Item Images Service**
   - HTTPS requests to Application Load Balancer fronting the server
   - Simple REST server that returns a JSON response

4. The game server uses **AWS Bedrock**
   - The game server uses an ECS task IAM role to grant it permissions to make Bedrock API calls.
   - LLM is used to generate new items, model dynamic interactions between items, and appraise items for sale.
   - Server implements and retry and fallback through the following models, in order: Anthropic Sonnet 4, Anthropic Sonnet 3.7, and Amazon Nova Pro

## Item Images Service

The Item Images Service is a specialized microservice that handles the generation, storage, and retrieval of game item images. It uses vector search capabilities with MemoryDB to index and lookup similar images as a cost savings measure. It uses Amazon Nova Canvas to generate images, stores the images in S3, and serves them via CloudFront.

```mermaid
graph TB
    subgraph ItemImages[Item Images Service]
        ALB[Application Load Balancer]
        HTTP[HTTP Server]
        Vector[Vector Search]
        ImageGen[Image Generation]
        ALB -->|Security Group|HTTP
        HTTP --> Vector
        HTTP --> ImageGen
    end

    subgraph In
        Server[Game Server]
    end

    subgraph Out
        MemoryDB[MemoryDB]
        S3[S3]
        CloudFront[CloudFront]
        Embeddings[Titan Text Embeddings]
        ImageModel[Nova Canvas]
    end

    Server -->|Security Group|ALB
    Vector -->|Security Group|MemoryDB
    Vector -->|IAM|Embeddings
    ImageGen -->|IAM|ImageModel
    ImageGen -->|IAM|S3
    S3 -->|Origin Access Control|CloudFront
```

### Technology Stack
- **Runtime**: Bun
- **Language**: TypeScript
- **Hosting:** AWS Fargate, orchestrated by Amazon ECS
- **Database**: AWS MemoryDB (Redis-compatible)
- **Storage**: Amazon S3
- **CDN**: CloudFront
- **AI Services**: 
  - Amazon Titan Text Embeddings v2
  - Amazon Nova Canvas

### Inbound Connections

- HTTPS requests from Game Server for image generation. Requests ingress via an HTTPS Application Load Balancer, and are distributed across Bun containers hosted in AWS Fargate.

### Outbound Connections
1. **MemoryDB**
   - Vector database to search for similar generated images
   - MemoryDB has a security group that only allows inbound connections
     from the security group of this service.

2. **S3**
   - Storage for generated images
   - Item images service has an IAM role that grants it permission to
     add items to the S3 bucket
   - No public ACL, CloudFront accesses the bucket via ab Origin Access Control policy.

4. **AI Services**
   - Titan Text Embeddings for embeddings that can be stored in vector database
   - Nova Canvas for image generation
   - Item images service has an IAM role that grants it permission to talk to Bedrock




================================================
FILE: docs/architecture.md
================================================
# Spirit of Kiro Game Documentation

This game uses a client server architecture. There are three main components:

```mermaid
graph LR
    Client[Game Client] --> Server[Game Server] --> Images[Item Images Service]
```

## Game Client:
  * Vue.js based game engine which represents game objects as
    Vue components.
  * Flexible tile grid system that adapts to varying screen sizes
  * Interactive game objects (dispenser, workbench, garbage, storage chest, computer)
  * Physics-based movement and collision system
  
## Game Server:
  * WebSocket protocol for low latency bi-directional communication between client and server
  * DynamoDB storage of inventories and item metadata.
  * AWS Bedrock integration powering the following features:
     * Random item generation. Infinite variations of items. Unique item names,
       descriptions, damage, and skills, written by generative AI.
     * Crafting. Transform, improve, combine, and consume items in a
       realistic manner.
     * Appraisal. Sell your crafted items to see what the AI thinks
       they are worth.
  * Amazon Cognito integration for user authentication and authorization
  
## Item Images Server:
  * AWS Bedrock integration powering the following features:
    * Amazon Nova Canvas to generate unique images for generated items
    * Amazon Titan Text Embeddings v2 to generate vector embeddings of item descriptions
  * Amazon MemoryDB vector database to do vector matching of previously generated item images to new item image requests
  * S3 to store item images, CloudFront distribution as ingress.

## Architecture Map

The following map shows the relationships and data flow through the end to end architecture:

```mermaid
graph TB
    subgraph Game Client in Browser
        UI[Vue Components]
        Store[Pinia Store]
        subgraph Systems
            Physics[Physics System]
            Socket[Socket + Event System]
            GameObject[Game Object System]
            Item[Item System]
            Inventory[Inventory System]
            Persona[Persona System]
            Preloader[Image Preload]
        end
        UI --> Store
        Store <--> Systems

        GameObject <--> Socket
        Item <--> Socket
        Inventory <--> Socket
        Persona <--> Socket
        Preloader <--> Socket
    end

    subgraph Amazon CloudFront
      ImageDist[Images Distribution]
      WebDist[Website Distribution]
      Socket <--> WebDist
      UI --> ImageDist
    end

    subgraph Game Server
        WS[WebSocket Server]
        Handlers[Message Handlers]
        State[State Management]
        DB[DynamoDB]
        claude[Sonnet 4, Sonnet 3.7, Nova Pro]
        Cognito[Amazon Cognito]

        WebDist <--> WS
        WS --> Handlers
        Handlers --> State
        State --> DB 
        Handlers --> claude
        Handlers --> Cognito
    end

    subgraph Image Server
      HTTP[HTTP Server]
      Handlers --> HTTP

      Vector[Vector Match]
      ImageGen[Image generation]
      titanText[Titan Text Embeddings v2]
      novaCanvas[Amazon Nova Canvas]
      MemoryDB[MemoryDB]
      S3[S3]

      HTTP --> Vector --> ImageGen
      Vector -->titanText
      Vector -->MemoryDB
      ImageGen -->novaCanvas
      ImageGen -->S3
      ImageDist -->S3
    end
```

## Frontend Game Client Systems

The client is built with Vue.js 3 and uses the Composition API throughout. The architecture follows these key patterns:

- **Component-based UI**: Vue components for all game UI elements
- **System-based Architecture**: Game logic is separated into independent systems that engage with each other through events.
- **Reactive State Management**: Using Pinia and Vue's reactivity system
- **Server-driven Events**: WebSocket events from the server feed into the frontend event system to drive game state changes

### Socket System
- Manages connection to the WebSocket server, including reconnection on disconnect
- Provides methods to dispatch WebSocket messages to the server.
- On incoming message from the server, fans that message out to other systems
  that are subscribing to that message.

### Game Object System
- Tracks all game objects that are drawn on screen
- Handles object creation, updates, and removal

### Physics System
- Handles all physics calculations and collision detection for game objects, including object movement, collisions, and gravity
- Supports different types of physics interactions (static, dynamic, field)
- Implements bounce, friction, and mass-based interactions

### Item System
- Keeps track of all game items and their properties
- Synchronizes with server state via event subscriptions

### Inventory System
- Keeps track of which inventory an item is in
- Handles item pickup, drop, and transfer
- Synchronizes with server state via event subscriptions

### Persona System
- Manages player personas and character data
- Handles persona customization and state
- Synchronizes with server state via event subscriptions

### Preloader System
- Manages asset loading and initialization
- Tracks loading progress
- Uses event subscription to watch for new images to load

## Server Architecture

The server is a Bun-based WebSocket server that handles:

- Real-time game state synchronization
- Message-based communication
- AI integration for item generation
- State persistence using AWS services

## Infrastructure

The game uses AWS services for:

- CloudFront distribution
- S3 storage for AI-generated images
- DynamoDB for state persistence
- Bedrock for AI integration

## Development

The project uses Docker for local development with separate containers for:
- Client (Vue.js application)
- Server (Bun WebSocket server)
- Infrastructure deployment



================================================
FILE: docs/CHALLENGE.md
================================================
# Challenge Tasks

This project has a few bugs and feature gaps that were
deliberately left behind so you could experiment with AI
engineering.

## Challenge 1: Weak home page

See if you can get the coding agent to explore the codebase,
figure out the game's features and selling points, and
create a better home page for the game.

__Tip:__ Try out different styles such as: "Apple product marketing page",
"Retro", or "Startup" and/or ask for specific things that you want like a
"carousel", "quotes", or "animations".

## Challenge 2: Physics bug

If you have items in an active physics state (such as the
player character actively moving, and colliding with an object)
then if you tab out of the game, wait a few seconds, and tab
back in, you will see the items do a tremendous bounce!

![](gifs/bounce-bug-optimized.gif)

Easy reproduction is to pull the lever, switch browser tabs while the
item is generated so that the item is dispensed while the
tab is backgrounded, then switch back to the game tab. 

Can AI figure out the cause of this bug and then fix it?

_Extra credit: There are multiple potential solutions to this problem. Be sure to ask the AI to dig deeper and suggest alternate solutions. Think about the various potential solutions, and use your strengths as a human to select the right one(s)._

## Challenge 3: Interactions bug

Sometimes when the player is closer to the wall than to an interactive object like an item or the chest, then the interact prompt does not appear over the interactive object.

![](gifs/interactions-bug-optimized.gif)

Can you fix this using AI?

## Challenge 4: Sounds

The game currently has no sounds. Can you add a sound system to the game?
There is a list of royalty free, no attribution required sounds available here:
https://sonniss.com/gameaudiogdc/
Consider how to load a list of background and interaction sounds, then trigger
these sounds to play via events that are emitted from all relevant components.

## Challenge 5: Implement email verification, then password reset

This application uses Amazon Cognito for auth. Cognito requires emails to be verified
in order to use them as a password reset option.

Currently the application just uses an admin method to verify user accounts
without verfiying the user's email. This means that password resets
can't be implemented. 

Can you implement email verification, then implement password reset across the client
and the backend server?




================================================
FILE: docs/client-events.md
================================================
# Client-Side Events Documentation

This document lists all client-side events emitted throughout the game, their purpose, and their payload structure.

## Connection Events

### `reconnect-failed`
Emitted when a reconnection attempt to the server fails.
- **Payload**: None

### `reconnect-attempt`
Emitted when attempting to reconnect to the server.
- **Payload**:
  ```typescript
  {
    attempt: number;    // Current attempt number
    maxAttempts: number; // Maximum number of attempts allowed
  }
  ```

## Player Interaction Events

### `player-interaction`
Emitted when the player uses the "E" key to interact
- **Payload**: None

### `inspect-item`
Emitted when a player inspects an item.
- **Payload**:
  ```typescript
  {
    item: Item;  // The item being inspected
  }
  ```

### `item-pickup`
Emitted when a player picks up an item.
- **Payload**:
  ```typescript
  {
    item: Item;  // The item being picked up
  }
  ```

### `drop-item`
Emitted when a player drops an item.
- **Payload**:
  ```typescript
  {
    itemId: string;  // ID of the item being dropped
  }
  ```

## Workbench Events

### `clean-workbench-results`
Emitted to clear workbench results.
- **Payload**: None

### `workbench-overflow-item`
Emitted when an item overflows from the workbench.
- **Payload**:
  ```typescript
  {
    itemId: string;  // ID of the overflowing item
  }
  ```

### `skill-invoked`
Emitted when a skill is used at the workbench.
- **Payload**:
  ```typescript
  {
    skill: string;  // The skill being invoked
  }
  ```

## UI Events

### `hint`
Emitted to show a hint to the player.
- **Payload**:
  ```typescript
  {
    message: string;  // The hint message
  }
  ```

### `clear-hint`
Emitted to clear the current hint.
- **Payload**: None

### `announce`
Emitted to show an announcement.
- **Payload**:
  ```typescript
  {
    message: string;  // The announcement message
  }
  ```

## Game State Events

### `gold-update`
Emitted when the player's gold amount changes.
- **Payload**:
  ```typescript
  {
    gold: number;  // New gold amount
  }
  ```

### `intent-to-discard-item`
Emitted when a player intends to discard an item.
- **Payload**:
  ```typescript
  {
    itemId: string;  // ID of the item to discard
  }
  ```

## Physics Events
These events are emitted during physics interactions between objects.

#### `near-door`
Emitted when the player enters the door field area. Used to trigger a dialog from the shopkeeper.
- **Payload**:
  ```typescript
  {
    id: string;  // ID of the field object ('door-field')
  }
  ```

#### `sell-item`
Emitted when a thrown item enters the selling area field. Used to trigger the appraise and sell dialog.
- **Payload**:
  ```typescript
  {
    id: string;  // ID of the field object ('sell-field')
  }
  ```

## Lever Events

### `lever-pulled`
Emitted when the pull lever is pulled.
- **Payload**: None

### `pulled-item`
Emitted when the pull lever component finishes pulling an item from the server. Dispenser uses this to trigger.
- **Payload**:
  ```typescript
  {
    item: Item;  // The pulled item
  }
  ```

### `lever-reset`
Emitted when the lever resets.
- **Payload**:
  ```typescript
  {
    // Reset state information
  }
  ``` 


================================================
FILE: docs/guiding-principles.md
================================================
# Spirit of Kiro - Guiding Principles

## Core Principles

### 1. AI is used to enable emergent interactions that are impossible in traditional gaming

In most traditional games, crafting is essentially hardcoded: specific items combine in
specific ways to produce specific outputs. In this game, crafting is free form. Items have
skills/quirks that can be used on other items. AI calculates an outcome. There is no required,
hardcoded schema for item metadata. In fact, it is theoretically possible to have an item 
with a "hack" type skill that specializes in modifying the metadata of other items. The AI
doesn't care what the structure or shape of an item's metadata looks like, as long as it is
semantically meaningful.

### 2. Scale enables efficiency and improved player experience

The game's performance should improve with more players.

Example 1: AI is used to generate net new items with unique stories, properties, and skills and
it can take around 10 seconds for the LLM to "mint" a new item from scratch. However,
if another player discards or consumes an item, rather than completely deleting it, we put it into
a shared pool to pull from later. This means a second player to the server can pull a previously
minted item nearly instantly, without needing to wait on the AI. This mechanic scales better and
better the more players there are. Eventually only a tiny fraction of the player base is waiting
on brand new item minting, and although there is a constant stream of new items being minted, the
number of new items that are minted naturally decreases over time.

Example 2: By far the biggest cost and biggest wait in this game is item image generation. As
an optimization, we keep a vector database of embeddings that match generated item descriptions.
If an item is visually similar to another pre-existing item, we reuse that other items image
rather than needing to generate a new image from scratch. Over time the vector database will
start matching a higher and higher percentage of items. AI usage will decrease, and players will
receive items with images almost instantly.




================================================
FILE: docs/local-setup.md
================================================
# Setup and Dependencies

You can run the game locally by launching the "client" and "server" components.
At this time it is not necessary to run the item images server locally, as a remote
version of the service is provided.

## 1. Clone repo

To get started:

```sh
git clone git@github.com:kirodotdev/kiro-demo-game.git
```

## 2. Setup your environment and install dependencies

Running this project relies on the following dependencies:

* A local installation of [Docker Desktop](https://www.docker.com/products/docker-desktop/) or [Podman](https://podman.io/).
* An AWS account, [credentials to access that AWS account](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-prereqs.html), and [`aws` CLI](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html).
* AWS Bedrock access to the following models
   - One or more of:
      - Amazon Nova Pro
      - Anthropic Claude Sonnet 3.7
      - Anthropic Claude Sonnet 4
   - Amazon Titan Text Embeddings v2 (only if you want to generate item images yourself)
   - Amazon Nova Canvas (only if you want to generate item images yourself)

Run the following script to verify that the dependencies are fulfilled:

```sh
./scripts/check-dependencies.sh
```

## 3. Deploy Cognito Resources to AWS

This game uses Amazon Cognito for authentication. You must deploy the Cognito resources first, prior to launching the stack.

```sh
./scripts/deploy-cognito.sh game-auth
```
_You can substitute your own custom CloudFormation stack name instead of `game-auth`_

## 4. Launch the game stack

Launch the game stack using the following command:

```sh
podman compose build && podman compose up --watch --remove-orphans --timeout 0 --force-recreate
```
_(You can substitute `docker` for `podman` if you choose to use Docker Desktop)_

On some systems the virtual machine can experience a time desync
issue on system sleep. This will cause issues with
credentials. If you encounter this you can fix it with the following
command:

```sh
podman machine ssh sudo systemctl restart chronyd.service
```

## 5. Bootstrap the DynamoDB tables

The first time you run the stack, the local DynamoDB that starts up will be
empty, with no tables. Run the following commands to create the required tables:

```sh
podman exec server mkdir -p /app/server/iac &&
podman cp scripts/bootstrap-local-dynamodb.js server:/app/ &&
podman cp server/iac/dynamodb.yml server:/app/server/iac/ &&
podman exec server bun run /app/bootstrap-local-dynamodb.js
```
_(You can substitute `docker` for `podman` if you choose to use Docker Desktop)_

Note: If you add a new table to the infrastructure as code, or modify a table structure
then you should delete `docker/dynamodb/shared-local-instance.db` and rerun the command above.

# Don't like containers?

It is also possible to run the project outside of the Docker Compose stack if you prefer to run all the dependencies locally. You will 
need to install the following dependencies:

* [Bun](https://bun.sh/) - JavaScript runtime for running the client and server. 
* [DynamoDB Local](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html)

Then:
* You will need to run `bun install` in three places:
   1. Root of the project
   2. `client` folder
   3. `server` folder
* You will need to run `bun ./scripts/bootstrap-local-dynamodb.js` script to setup the DynamoDB tables
* You will also still need to run `./scripts/deploy-cognito.sh` to deploy the Cognito resources to AWS. You will then need
  to copy the `dev.env` file that is created in the root of the project, into the `server` directory so that
  the server process can access the Cognito details it needs.

You can then launch the components of the stack locally, directly on your host:

- Client: `cd client && bun run dev`
- Server: `cd server && bun --watch server.ts` 


================================================
FILE: docs/remote-deploy.md
================================================
# Infrastructure Operations Guide

This guide explains how to deploy the Spirit of Kiro infrastructure to AWS. The infrastructure consists of several components:

- Server:
  * DynamoDB tables for data storage
  * ECS Fargate service for running the server
  * Application Load Balancer for routing traffic
  * ECR repository for container images

- Item Images Service:
  * S3 bucket for image storage
  * CloudFront distribution for image delivery
  * MemoryDB cluster for vector storage
  * ECS Fargate service for image generation
  * ECR repository for container images

- Client:
  * S3 bucket for static website hosting
  * CloudFront distribution with basic authentication
  * Lambda@Edge for authentication

## Prerequisites

Before deploying the infrastructure, ensure you have:

1. An AWS account with appropriate permissions
2. AWS CLI installed and configured with credentials
3. Podman or Docker installed locally
4. Access to the following AWS services:
   - AWS Bedrock (for AI features)
   - Amazon ECS
   - Amazon ECR
   - Amazon DynamoDB
   - Amazon VPC
   - Amazon CloudWatch
   - Amazon S3
   - Amazon CloudFront
   - Amazon MemoryDB
   - AWS Lambda

## Deployment Steps

### Clone and Prepare the Repository

```bash
git clone git@github.com:kirodotdev/kiro-demo-game.git
cd kiro-demo-game
```

### Production Deployment

For production deployments, use the automated deployment script that handles all components in the correct order:

```bash
./scripts/prod-deploy.sh
```

This script will:
1. Deploy the item-images service to `us-west-2`
2. Deploy the server to `us-west-2`
3. Deploy the client to `us-east-1` (Necessary for Lamdbda@Edge)
4. Configure all necessary connections between components

### Manual Deployment Steps

If you need to deploy components individually, follow these steps:

#### Deploy the Item Images Service

The item images service deployment will:
1. Create an S3 bucket for image storage
2. Set up a CloudFront distribution
3. Create a MemoryDB cluster for vector storage
4. Deploy the Fargate service for image generation

To deploy, run:

```bash
cd item-images/iac
./deploy.sh <stack-name-prefix>
```

_The demo deployment uses stack name `kiro-game-images`_

The script will:
- Use the default VPC and subnets
- Create an ECR repository
- Build and push the container image
- Deploy the CloudFormation templates

#### Deploy the Server Infrastructure

The server deployment process is automated using a deployment script. The script will:
1. Create DynamoDB tables
2. Set up an ECR repository
3. Build and push the container image
4. Deploy the Fargate service

To deploy, run:

```bash
cd server/iac
./deploy.sh <address of item image server>
```

The script will:
- Use the default VPC and subnets
- Create an ECR repository
- Build and push the container image
- Deploy the CloudFormation templates

#### Deploy the Client Application

The client deployment will:
1. Build the Vue.js application
2. Use CloudFormation to deploy an S3 bucket for static hosting and a CloudFront distribution with basic authentication
3. Upload the static site built to S3 and invalidate the CFN distribution

To deploy, run:

```bash
cd client/iac
./deploy.sh <websocket-server-address>
```

_The demo deployment uses stack name `web-app`_

Replace `<websocket-server-address>` with the address of your deployed server (e.g., `alb-123456.us-east-1.elb.amazonaws.com:8080`).

### Verify the Deployment

After deployment completes, you can verify each component:

1. Server:
   - Check the CloudFormation stacks in the AWS Console
   - Verify the ECS service is running
   - Test the Load Balancer endpoint

2. Item Images Service:
   - Verify the S3 bucket is created
   - Check the CloudFront distribution is enabled
   - Confirm the MemoryDB cluster is active
   - Test the image generation service

3. Client:
   - Access the CloudFront distribution URL
   - Verify basic authentication works
   - Test WebSocket connectivity
   - Check that the game loads correctly

## Infrastructure Components

### Server Components
- DynamoDB Tables:
  * `Items`: Stores game item metadata
  * `Inventory`: Tracks player inventories
  * `Location`: Maps items to game locations
  * `Users`: Stores user information
  * `Usernames`: Maps usernames to user IDs
  * `Persona`: Stores user persona details

- ECS Fargate Service:
  * Runs on ARM64 architecture
  * Uses Fargate for serverless container execution
  * Configured with auto-scaling capabilities
  * Includes CloudWatch logging

### Item Images Service Components
- S3 Bucket:
  * Versioning enabled
  * Private access
  * CloudFront origin

- CloudFront Distribution:
  * HTTPS enabled
  * S3 origin with OAC
  * Caching configured

- MemoryDB Cluster:
  * Redis 7.1
  * Vector search enabled
  * Multi-AZ deployment

- ECS Fargate Service:
  * Image generation service
  * Bedrock integration
  * Vector storage integration

### Client Components
- S3 Bucket:
  * Static website hosting
  * Private access
  * CloudFront origin

- CloudFront Distribution:
  * Basic authentication
  * WebSocket routing
  * SPA routing support
  * HTTPS enabled

## Monitoring and Maintenance

### CloudWatch Logs
- Server logs: `/ecs/<stack-name>`
- Item Images logs: `/ecs/<stack-name>-images`
- Retention period: 30 days

### Scaling
Each service is configured to run 2 tasks by default. You can adjust this by:
1. Modifying the `DesiredCount` parameter in the CloudFormation template
2. Setting up auto-scaling policies based on metrics

### Updates
To update any component:
1. Make your code changes
2. Run the deployment script again with the same stack name prefix
3. The script will build a new container image and update the service

## Security Considerations

- IAM roles with least privilege
- Security groups restrict access to necessary ports
- All tables use on-demand capacity mode
- Basic authentication for client access
- CloudFront with HTTPS
- MemoryDB with VPC security
- Consider enabling AWS WAF for additional protection

## Troubleshooting

Common issues and solutions:

1. **Deployment fails with VPC errors**
   - Ensure you have a default VPC in your AWS account
   - Verify you have sufficient subnets in the VPC

2. **Container fails to start**
   - Check CloudWatch logs for error messages
   - Verify environment variables are correctly set

3. **Load Balancer health checks fail**
   - Ensure the application is listening on the correct port
   - Check security group rules allow traffic

4. **DynamoDB access issues**
   - Verify IAM roles have correct permissions
   - Check table names match environment variables

5. **WebSocket connection fails**
   - Verify the WebSocket endpoint is correctly configured
   - Check CloudFront WebSocket routing settings
   - Ensure security groups allow WebSocket traffic

6. **Image generation fails**
   - Verify Bedrock permissions
   - Check MemoryDB connectivity
   - Ensure S3 bucket permissions are correct

For additional help, check the CloudFormation stack events in the AWS Console. 


================================================
FILE: docs/ROADMAP.md
================================================
# Spirit of Kiro Roadmap

## Player-to-Player Trading System
- Implement a basic player marketplace where users can list their crafted items for sale to other players, and see other players items to buy

## Player Workbench Sharing
- If you have a great workbench full of powerful tools
  you should be able to grant other players access to your workbench in exchange for a fee. The secure workbench sharing feature allows other players to use your tools to craft on their own items.

## Enhanced persona system
- Right now the only character persona data being tracked is how much money the character has
- Add AI generated passives that get leveled up based on your usage
  of item quirks. For example, if interacting with many "gothic" themed items you might gain a
  "vampire" passive and level it up each time you interact with a "gothic" item.
- Consider player passives for the crafting outcome. (Additional token burden might require faster models)
- Add a mirror / vanity table for player character to inspect their stats and passives.

## Image conditioning
- Rather than having the image generator create a new image from scratch when
  and item's appearance changes, supply the original image as a reference, thereby increasing the similarity between the newly modified item's image and the existing image.

## Basic progression system
- Consider using the persona system to keep track of purchasable upgrades.
- Maybe tool bench starts out with only a few item slots, can purchase upgraded tool benches with more slots and more power?
- Ability to buy another storage chest?
- Ability to upgrade "computer" from old model to a sleek modern laptop that lets you "order" AI generated items from specific themes and categories rather than pulling completely randomly.

## AI Shop System
- Expand the basic "item appraisal" system into a full shop. You should be able to walk through the door at the bottom
  to access your shop. Implement display cases for showcasing items for sale.
- Create an AI guest system that:
  - Generates diverse AI customers with different preferences
  - Enables natural conversation about items
  - Implements a haggling system with realistic price negotiations
  - Provides feedback on item quality and desirability

## Daily Crafting Contests
- Create a contest system with random daily themes. You
  submit a crafted item to the daily contest in exchange for rewards.
- Implement AI judging system that evaluates:
  - Theme adherence
  - Craftsmanship quality
  - Creativity and originality
  - Technical execution
- Develop a playoff system for top performers:
  - Weekly finals for top 100 players
  - Advanced AI judging criteria
  - Prize system for winners
- Add contest history and leaderboards
- Implement contest notifications and reminders

## Fashion Show
- Submit a set of stylish, whacky, or otherwise interesting themed clothing
- AI matches you to another player, and judges your outfit relative to the other
  players outfit, somewhat like Infinity Nikki.
- Range of different AI generated judge personas. You must analyze the set of
  judges and then pick and choose your best items to try to impress them based
  on the judge personas.

## Battle System
- Hire an AI champion, and equip them with your unique crafted
  items as armor or weapons.
- Dispatch your warrior to fight randomly generated AI monsters.
- Equipment will take real damage that needs to be repaired, and
  monster slaying will return interesting loot.
- Potential for PvP battles with other player's AI champions. Both players pick their champion's gear, and the AI simulates the battle results between both champions using the gear to the best of their abilities.




================================================
FILE: docs/server-messages.md
================================================
# Server Message Types

This document outlines all the message types that the game server handles via WebSocket connections.

## Message Format

All messages should be sent as JSON strings with the following structure:
```json
{
  "type": "message_type",
  // Additional message-specific fields
}
```

## Response Format

The server responds to all messages using a standardized format:
```json
{
  "type": "response_type",
  "body": {} // Optional response data
}
``` 

## Error Responses

All message types can return the following error responses:
```json
{
  "type": "error",
  "body": "Authentication required"
}
```

## Item Structure

Items in responses follow this structure:
```json
{
  "id": "string",
  "name": "string",
  "description": "string",
  "icon": "string",
  "imageUrl": "string",
  "value": "number",
  "weight": "string",
  "damage": "string",
  "materials": ["string"],
  "skills": [
    {
      "name": "string",
      "description": "string",
      "targets": "number" // 0 for self, 1 for single target, 2 for two targets
    }
  ]
}
```

## Message Types

### ping
A simple ping message to check server connectivity.

Request:
```json
{
  "type": "ping"
}
```

Response:
```json
{
  "type": "pong"
}
```

### signup
Message for user registration.

Request:
```json
{
  "type": "signup",
  "body": {
    "username": "string",
    "password": "string"
  }
}
```

Response:
```json
{
  "type": "signup_success",
  "body": {
    "userId": "string"
  }
}
```

### signin
Message for user authentication.

Request:
```json
{
  "type": "signin",
  "body": {
    "username": "string",
    "password": "string"
  }
}
```

Response:
```json
{
  "type": "signin_success",
  "body": {
    "userId": "string"
  }
}
```

### pull-item
Message to pull/retrieve an item.

Request:
```json
{
  "type": "pull-item"
}
```

Response:
```json
{
  "type": "pulled-item",
  "body": {
    "story": "string",
    "item": {
      "id": "string",
      "name": "string",
      "description": "string",
      "icon": "string",
      "imageUrl": "string",
      "value": "number",
      "weight": "string",
      "damage": "string",
      "materials": ["string"],
      "skills": [
        {
          "name": "string",
          "description": "string",
          "targets": "number"
        }
      ]
    }
  }
}
```

### list-inventory
Message to retrieve the user's inventory contents.

Request:
```json
{
  "type": "list-inventory",
  "body": {
    "inventoryId": "string"
  }
}
```

Response:
```json
{
  "type": "inventory-items:inventoryName",
  "body": [
    {
      "id": "string",
      "name": "string",
      "description": "string",
      "icon": "string",
      "imageUrl": "string",
      "value": "number",
      "weight": "string",
      "damage": "string",
      "materials": ["string"],
      "skills": [
        {
          "name": "string",
          "description": "string",
          "targets": "number"
        }
      ]
    }
  ]
}
```

Error Responses:
```json
{
  "type": "error",
  "body": "Cannot access inventory {inventoryId}"
}
```

### discard-item
Message to discard/remove an item from inventory.

Request:
```json
{
  "type": "discard-item",
  "body": {
    "itemId": "string"
  }
}
```

Response:
```json
{
  "type": "item-discarded",
  "body": {
    "itemId": "string"
  }
}
```

Error Responses:
```json
{
  "type": "error",
  "body": "Item not found"
}
```
```json
{
  "type": "error",
  "body": "Item not in your inventory"
}
```

### move-item
Message to move an item within the inventory.

Request:
```json
{
  "type": "move-item",
  "body": {
    "itemId": "string",
    "targetInventoryId": "string"
  }
}
```

Response:
```json
{
  "type": "item-moved",
  "body": {
    "itemId": "string",
    "targetInventoryId": "string"
  }
}
```

Error Responses:
```json
{
  "type": "error",
  "body": "Item not found"
}
```
```json
{
  "type": "error",
  "body": "Can't move item that you don't own"
}
```
```json
{
  "type": "error",
  "body": "Invalid target inventory"
}
```
```json
{
  "type": "error",
  "body": "Item is already in the given inventory"
}
```

### use-skill
Message to use a skill, which may affect the WebSocket connection.

Request:
```json
{
  "type": "use-skill",
  "body": {
    "toolId": "string",
    "toolSkillIndex": "number",
    "targetIds": ["string"]
  }
}
```

Responses:
```json
{
  "type": "skill-use-story",
  "body": {
    "story": "string"
  }
}
```
```json
{
  "type": "skill-results",
  "body": {
    "story": "string",
    "tool": {
      "id": "string",
      "name": "string",
      "description": "string",
      "icon": "string",
      "imageUrl": "string",
      "value": "number",
      "weight": "string",
      "damage": "string",
      "materials": ["string"],
      "skills": [
        {
          "name": "string",
          "description": "string",
          "targets": "number"
        }
      ]
    },
    "outputItems": [
      {
        "id": "string",
        "name": "string",
        "description": "string",
        "icon": "string",
        "imageUrl": "string",
        "value": "number",
        "weight": "string",
        "damage": "string",
        "materials": ["string"],
        "skills": [
          {
            "name": "string",
            "description": "string",
            "targets": "number"
          }
        ]
      }
    ],
    "removedItemIds": ["string"]
  }
}
```

Error Responses:
```json
{
  "type": "error",
  "body": "Tool item not found"
}
```
```json
{
  "type": "error",
  "body": "Can't use a tool that you don't own"
}
```
```json
{
  "type": "error",
  "body": "Tool item does not have a skill at index {index}"
}
```
```json
{
  "type": "error",
  "body": "Can't use a skill on an item that you don't own"
}
```

### sell-item
Message to sell an item.

Request:
```json
{
  "type": "sell-item",
  "body": {
    "itemId": "string"
  }
}
```

Response:
```json
{
  "type": "item-sold",
  "body": {
    "itemId": "string",
    "appraisal": {
      "appraisal": {
        "saleAmount": "number"
      }
    },
    "gold": "number"
  }
}
```

Error Responses:
```json
{
  "type": "error",
  "body": "Item not found"
}
```
```json
{
  "type": "error",
  "body": "Item not in your inventory"
}
```

### fetch-persona
Message to retrieve user persona information.

Request:
```json
{
  "type": "fetch-persona",
  "body": {}
}
```

Response:
```json
{
  "type": "persona-details",
  "body": {
    "gold": "string",
    // Additional persona details
  }
}
```

### peek-discarded
Message to view discarded items.

Request:
```json
{
  "type": "peek-discarded",
  "body": {
    "numberOfItems": "number"
  }
}
```

Response:
```json
{
  "type": "discarded-results",
  "body": [
    {
      "id": "string",
      "name": "string",
      "description": "string",
      "icon": "string",
      "imageUrl": "string",
      "value": "number",
      "weight": "string",
      "damage": "string",
      "materials": ["string"],
      "skills": [
        {
          "name": "string",
          "description": "string",
          "targets": "number"
        }
      ]
    }
  ]
}
```

### buy-discarded
Message to purchase previously discarded items.

Request:
```json
{
  "type": "buy-discarded",
  "body": {
    "itemId": "string"
  }
}
```

Response:
```json
{
  "type": "buy-results",
  "body": {
    "itemId": "string",
    "item": {
      "id": "string",
      "name": "string",
      "description": "string",
      "icon": "string",
      "imageUrl": "string",
      "value": "number",
      "weight": "string",
      "damage": "string",
      "materials": ["string"],
      "skills": [
        {
          "name": "string",
          "description": "string",
          "targets": "number"
        }
      ]
    },
    "gold": "number",
    "purchasePrice": "number"
  }
}
```

Error Responses:
```json
{
  "type": "error",
  "body": "Item not found in discarded items"
}
```
```json
{
  "type": "error",
  "body": "Not enough gold to purchase this item"
}
```



================================================
FILE: item-images/README.md
================================================
# Item Images Server

A REST API server, for generating and managing item images for this game. 

There is an officially deployed central version of this service,
so you don't necessarily need to build, deploy, and run this service yourself.

The officially hosted version is available at: http://kiro-game-images-service-alb-559009974.us-west-2.elb.amazonaws.com/

This service is used by the main game server to generate images for items pulled from dispensers or recycled from the garbage chute.

## Features

- Generate images for items, based on a short description of them
- Uses vector embeddings to keep track of all it's generated images, by description
- Match incoming image requests to previously generated images using a vector database, as an optimization
- Stores item images in S3, with a CloudFront distribution in front
- Integrated with the main game server for item visualization
- Used for both new items and recycled items from the garbage chute

## API Endpoints

__`GET /`__

Simple healthcheck. Just returns 200 status code

__`GET /image?description=red%20bag`__

Fetch an image. The image will either be freshly generated if this
is the first time anyone has requested an image with this description.
Or a previously generated matching image will be returned, if a
closely matching image is found in the vector database.

Returned images will have a dimension of 320 pixels by 320 pixels, and will be in a cute pixel art style. Expect response times of about 600ms if a previously generated image is found, and response times of about 5-10 seconds if no matching image is found, and a fresh image must be generated from scratch.

Example response:

```json
{
  "id": "b3108a46-3054-423d-87dd-02d2865069d4",
  "description": "red bag",
  "imageUrl": "https://d8a4w5rlouwtf.cloudfront.net/e63251b2-5f61-4c1c-84e1-be0c6f8fd79b.png"
}
```




================================================
FILE: item-images/config.ts
================================================
import { readFileSync } from 'fs';

const ENV = process.env.ENVIRONMENT || 'prod'
const FILENAME=`${ENV}.env`;

// Try to load environment variables from shared volume
let envConfig = {};
try {
  const envFile = readFileSync(FILENAME, 'utf8');
  
  // Parse the .env file content
  envConfig = envFile.split('\n').reduce((acc, line) => {
    const match = line.match(/^\s*([\w.-]+)\s*=\s*(.*)?\s*$/);
    if (match) {
      const key = match[1];
      let value = match[2] || '';
      // Remove surrounding quotes if they exist
      value = value.replace(/^['"]|['"]$/g, '');
      acc[key] = value;
    }
    return acc;
  }, {});
  
  console.log(`Successfully loaded environment variables from ${FILENAME}`);
} catch (error) {
  console.log(`Could not load environment variables from ${FILENAME}, falling back to process.env`);
  console.log(`Error details: ${error.message}`);
}

// Merge loaded config with process.env, with process.env taking precedence
const getEnv = (key) => {
  return process.env[key] || envConfig[key];
};

export const S3_CONFIG = {
  bucketName: getEnv('S3_BUCKET_NAME'),
};

export const CLOUDFRONT_CONFIG = {
  domain: getEnv('CLOUDFRONT_DOMAIN'),
};

export const REDIS_CONFIG = {
  host: getEnv('REDIS_HOST') || 'localhost',
  port: 6379
};


================================================
FILE: item-images/Dockerfile
================================================
FROM oven/bun:1.2.15

WORKDIR /app

# Copy package.json for better layer caching
COPY package.json ./

# Install dependencies
RUN bun install

# Copy the rest of the server files
COPY . .

# Expose port 3000
EXPOSE 3000

# Add healthcheck
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000 || exit 1

# Switch to non-root user
USER bun

# Set the command to run the server
CMD ["bun", "server.ts"]


================================================
FILE: item-images/local.env
================================================
S3_BUCKET_NAME=kiro-game-images-images-s3-imagesbucket-air3q3idvtae
CLOUDFRONT_DOMAIN=d8a4w5rlouwtf.cloudfront.net
REDIS_HOST=localhost
REDIS_PORT=6379



================================================
FILE: item-images/package.json
================================================
{
  "name": "item-images-server",
  "version": "1.0.0",
  "description": "REST server for managing item images",
  "main": "server.ts",
  "type": "module",
  "scripts": {
    "start": "bun server.ts",
    "dev": "bun --watch server.ts",
    "test": "bun test"
  },
  "dependencies": {
    "bun": "^1.0.0",
    "sharp": "^0.34.1",
    "@aws-sdk/client-bedrock-runtime": "^3.0.0",
    "@aws-sdk/client-s3": "^3.0.0",
    "redis": "^5.0.1"
  },
  "devDependencies": {
    "@types/node": "^20.0.0"
  }
}


================================================
FILE: item-images/prod.env
================================================
S3_BUCKET_NAME=kiro-game-images-images-s3-imagesbucket-air3q3idvtae
CLOUDFRONT_DOMAIN=d8a4w5rlouwtf.cloudfront.net
REDIS_HOST=kiro-game-images-memorydb-memorydb.ivx1rc.clustercfg.memorydb.us-west-2.amazonaws.com
REDIS_PORT=6379



================================================
FILE: item-images/server.ts
================================================
import { serve } from "bun";
import { handleImageRoute } from "./handlers/image-handler";

// Configuration
const PORT = process.env.PORT || 3001;

// CORS headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type",
};

// Main server
const server = serve({
  port: PORT,
  async fetch(req: Request): Promise<Response> {
    const url = new URL(req.url);
    const method = req.method;

    console.log(`${method} ${url.pathname}`);

    // Handle CORS preflight requests
    if (method === "OPTIONS") {
      return new Response(null, {
        headers: corsHeaders,
        status: 204,
      });
    }

    // Handle /health endpoint
    if (url.pathname === "/" && method === "GET") {
      return new Response("OK", {
        status: 200,
        headers: {
          ...corsHeaders,
          "Content-Type": "text/plain"
        }
      });
    }

    // Handle /image endpoint
    if (url.pathname === "/image" && method === "GET") {
      return handleImageRoute(req);
    }

    // Handle 404 for unknown routes
    return new Response(JSON.stringify({ error: "Not found" }), {
      status: 404,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  },
});

console.log(`Item images server running at http://localhost:${PORT}`);


================================================
FILE: item-images/.dockerignore
================================================
*.env
scripts


================================================
FILE: item-images/handlers/image-handler.ts
================================================
import { randomUUID } from 'node:crypto';
import { getImage } from '../lib/item-image';

// CORS headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type",
};

/**
 * Interface for an item object
 */
interface Item {
  id: string;
  icon: string;
}

/**
 * Handler for the /image route
 * Generates an image based on the provided description
 * 
 * @param req - The request object
 * @returns Response - The response object
 */
export async function handleImageRoute(req: Request): Promise<Response> {
  try {
    const url = new URL(req.url);
    const description = url.searchParams.get('description');

    // Validate description parameter
    if (!description || description.trim() === '') {
      return new Response(JSON.stringify({ error: 'Description query parameter is required' }), {
        status: 400,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }

    // Create a simple item object with the description as the icon
    const item: Item = {
      id: randomUUID(),
      icon: description
    };

    // Use getImage function to generate an image for this item
    const imageUrl = await getImage(item);

    const response = {
      id: item.id,
      description: item.icon,
      imageUrl: imageUrl
    };

    // Return the image URL in a JSON response
    return new Response(JSON.stringify(response), {
      status: 200,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  } catch (error) {
    console.error('Error in /image route:', error);
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  }
}


================================================
FILE: item-images/iac/deploy.sh
================================================
#!/bin/bash
set -e

# Check if stack name prefix is provided
if [ -z "$1" ]; then
  echo "Error: Stack name prefix is required"
  echo "Usage: $0 <stack-name-prefix>"
  exit 1
fi

STACK_PREFIX=$1
S3_STACK_NAME="${STACK_PREFIX}-images-s3"
DISTRIBUTION_STACK_NAME="${STACK_PREFIX}-distribution"
MEMORYDB_STACK_NAME="${STACK_PREFIX}-memorydb"
FARGATE_STACK_NAME="${STACK_PREFIX}-service"
ECR_REPOSITORY_NAME="${STACK_PREFIX}-images"

echo "Deploying CloudFormation stacks with prefix: $STACK_PREFIX"

# Deploy the S3 bucket stack first
echo "Deploying S3 bucket stack: $S3_STACK_NAME"
aws cloudformation deploy \
  --template-file images-s3.yml \
  --stack-name $S3_STACK_NAME \
  --capabilities CAPABILITY_IAM

# Check if deployment was successful
if [ $? -ne 0 ]; then
  echo "Error: Failed to deploy S3 bucket stack"
  exit 1
fi

# Get outputs from the S3 stack
echo "Getting outputs from S3 stack"
IMAGES_BUCKET_NAME=$(aws cloudformation describe-stacks --stack-name $S3_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='ImagesBucketName'].OutputValue" --output text)
IMAGES_BUCKET_ARN=$(aws cloudformation describe-stacks --stack-name $S3_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='ImagesBucketArn'].OutputValue" --output text)

if [ -z "$IMAGES_BUCKET_NAME" ] || [ -z "$IMAGES_BUCKET_ARN" ]; then
  echo "Error: Failed to get outputs from S3 stack"
  exit 1
fi

echo "S3 Bucket Name: $IMAGES_BUCKET_NAME"
echo "S3 Bucket ARN: $IMAGES_BUCKET_ARN"

# Deploy the CloudFront distribution stack
echo "Deploying CloudFront distribution stack: $DISTRIBUTION_STACK_NAME"
aws cloudformation deploy \
  --template-file distribution.yml \
  --stack-name $DISTRIBUTION_STACK_NAME \
  --capabilities CAPABILITY_IAM \
  --parameter-overrides \
    ImagesBucketName=$IMAGES_BUCKET_NAME \
    ImagesBucketArn=$IMAGES_BUCKET_ARN

# Check if deployment was successful
if [ $? -ne 0 ]; then
  echo "Error: Failed to deploy CloudFront distribution stack"
  exit 1
fi

# Get outputs from the CloudFront distribution stack
echo "Getting outputs from CloudFront distribution stack"
DISTRIBUTION_ID=$(aws cloudformation describe-stacks --stack-name $DISTRIBUTION_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='DistributionId'].OutputValue" --output text)
DISTRIBUTION_DOMAIN=$(aws cloudformation describe-stacks --stack-name $DISTRIBUTION_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='DistributionDomainName'].OutputValue" --output text)

echo "Deployment completed successfully!"
echo "CloudFront Distribution ID: $DISTRIBUTION_ID"
echo "CloudFront Distribution Domain: $DISTRIBUTION_DOMAIN"

# Find default VPC and subnets
echo "Looking up default VPC and subnets"
DEFAULT_VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query "Vpcs[0].VpcId" --output text)

if [ -z "$DEFAULT_VPC_ID" ] || [ "$DEFAULT_VPC_ID" == "None" ]; then
  echo "Error: No default VPC found in this account/region"
  exit 1
fi

echo "Found default VPC: $DEFAULT_VPC_ID"

# Get subnet IDs from the default VPC
SUBNET_IDS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$DEFAULT_VPC_ID" --query "Subnets[*].SubnetId" --output text | tr '\t' ',')

if [ -z "$SUBNET_IDS" ] || [ "$SUBNET_IDS" == "None" ]; then
  echo "Error: No subnets found in the default VPC"
  exit 1
fi

echo "Found subnets: $SUBNET_IDS"

# Deploy the MemoryDB cluster stack
echo "Deploying MemoryDB cluster stack: $MEMORYDB_STACK_NAME"
aws cloudformation deploy \
  --template-file memorydb.yml \
  --stack-name $MEMORYDB_STACK_NAME \
  --capabilities CAPABILITY_IAM \
  --disable-rollback \
  --parameter-overrides \
    VpcId=$DEFAULT_VPC_ID \
    SubnetIds=$SUBNET_IDS

# Check if deployment was successful
if [ $? -ne 0 ]; then
  echo "Error: Failed to deploy MemoryDB cluster stack"
  exit 1
fi

# Get outputs from the MemoryDB cluster stack
echo "Getting outputs from MemoryDB cluster stack"
REDIS_ENDPOINT=$(aws cloudformation describe-stacks --stack-name $MEMORYDB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='MemoryDBEndpoint'].OutputValue" --output text)
REDIS_PORT=6379

# Get the MemoryDB security group ID
echo "Getting MemoryDB security group ID"
MEMORYDB_SG_RESOURCE_ID=$(aws cloudformation describe-stack-resources --stack-name $MEMORYDB_STACK_NAME --logical-resource-id MemoryDBSecurityGroup --query "StackResources[0].PhysicalResourceId" --output text)

if [ -z "$MEMORYDB_SG_RESOURCE_ID" ]; then
  echo "Error: Failed to get MemoryDB security group resource ID"
  exit 1
fi

echo "MemoryDB Security Group Resource ID: $MEMORYDB_SG_RESOURCE_ID"

if [ -z "$REDIS_ENDPOINT" ] || [ -z "$REDIS_PORT" ]; then
  echo "Error: Failed to get outputs from MemoryDB cluster stack"
  exit 1
fi

echo "MemoryDB Endpoint: $REDIS_ENDPOINT"
echo "MemoryDB Port: $REDIS_PORT"

# Create or ensure the ECR repository exists
echo "Creating ECR repository: $ECR_REPOSITORY_NAME"
aws ecr describe-repositories --repository-names "$ECR_REPOSITORY_NAME" > /dev/null 2>&1 || \
aws ecr create-repository --repository-name "$ECR_REPOSITORY_NAME" > /dev/null

if [ $? -ne 0 ]; then
  echo "Error: Failed to create or verify ECR repository"
  exit 1
fi

# Get the ECR repository URI
ECR_REPOSITORY_URI=$(aws ecr describe-repositories --repository-names "$ECR_REPOSITORY_NAME" --query "repositories[0].repositoryUri" --output text)

if [ -z "$ECR_REPOSITORY_URI" ]; then
  echo "Error: Failed to get ECR repository URI"
  exit 1
fi

echo "ECR Repository URI: $ECR_REPOSITORY_URI"

# Create a timestamp-based tag for the Docker image
TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
IMAGE_TAG="${TIMESTAMP}"
echo "Using image tag: $IMAGE_TAG"

# Get ECR login token and login with Podman
echo "Logging in to ECR with Podman"
aws ecr get-login-password | podman login --username AWS --password-stdin "$ECR_REPOSITORY_URI"

if [ $? -ne 0 ]; then
  echo "Error: Failed to login to ECR with Podman"
  exit 1
fi

# Build the Docker image using Podman
echo "Building Docker image with Podman"
cd ..
podman build -t "$ECR_REPOSITORY_NAME" .

if [ $? -ne 0 ]; then
  echo "Error: Failed to build Docker image"
  exit 1
fi

# Tag the image with the ECR repository URI and timestamp
echo "Tagging Docker image with timestamp"
podman tag "$ECR_REPOSITORY_NAME" "$ECR_REPOSITORY_URI:$IMAGE_TAG"
podman tag "$ECR_REPOSITORY_NAME" "$ECR_REPOSITORY_URI:latest"

if [ $? -ne 0 ]; then
  echo "Error: Failed to tag Docker image"
  exit 1
fi

# Push the images to ECR
echo "Pushing Docker images to ECR"
podman push "$ECR_REPOSITORY_URI:$IMAGE_TAG"
podman push "$ECR_REPOSITORY_URI:latest"

if [ $? -ne 0 ]; then
  echo "Error: Failed to push Docker images to ECR"
  exit 1
fi

echo "Successfully pushed Docker images to ECR with tag: $IMAGE_TAG"

# Return to the iac directory
cd iac

# Deploy the Fargate stack
echo "Deploying Fargate stack: $FARGATE_STACK_NAME"

# Get public and private subnet IDs
PUBLIC_SUBNET_IDS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$DEFAULT_VPC_ID" "Name=map-public-ip-on-launch,Values=true" --query "Subnets[*].SubnetId" --output text | tr '\t' ',')
PRIVATE_SUBNET_IDS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$DEFAULT_VPC_ID" "Name=map-public-ip-on-launch,Values=false" --query "Subnets[*].SubnetId" --output text | tr '\t' ',')

# If no private subnets found, use public subnets for both
if [ -z "$PRIVATE_SUBNET_IDS" ] || [ "$PRIVATE_SUBNET_IDS" == "None" ]; then
  echo "No private subnets found, using public subnets for both public and private"
  PRIVATE_SUBNET_IDS=$PUBLIC_SUBNET_IDS
fi

if [ -z "$PUBLIC_SUBNET_IDS" ] || [ "$PUBLIC_SUBNET_IDS" == "None" ]; then
  echo "No public subnets found, using all subnets for both public and private"
  PUBLIC_SUBNET_IDS=$SUBNET_IDS
  PRIVATE_SUBNET_IDS=$SUBNET_IDS
fi

echo "Public subnets: $PUBLIC_SUBNET_IDS"
echo "Private subnets: $PRIVATE_SUBNET_IDS"

# Deploy the Fargate stack
aws cloudformation deploy \
  --template-file fargate.yml \
  --stack-name $FARGATE_STACK_NAME \
  --capabilities CAPABILITY_IAM \
  --parameter-overrides \
    Environment="prod" \
    CpuArchitecture="ARM64" \
    ContainerImageUrl="$ECR_REPOSITORY_URI:$IMAGE_TAG" \
    S3BucketName=$IMAGES_BUCKET_NAME \
    CloudFrontDomain=$DISTRIBUTION_DOMAIN \
    RedisHost=$REDIS_ENDPOINT \
    MemoryDBSecurityGroupId=$MEMORYDB_SG_RESOURCE_ID \
    VpcId=$DEFAULT_VPC_ID \
    PrivateSubnetIds=$PRIVATE_SUBNET_IDS \
    PublicSubnetIds=$PUBLIC_SUBNET_IDS

# Check if deployment was successful
if [ $? -ne 0 ]; then
  echo "Error: Failed to deploy Fargate stack"
  exit 1
fi

# Get outputs from the Fargate stack
echo "Getting outputs from Fargate stack"
SERVICE_URL=$(aws cloudformation describe-stacks --stack-name $FARGATE_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='ServiceURL'].OutputValue" --output text)

if [ -z "$SERVICE_URL" ]; then
  echo "Warning: Could not retrieve Service URL from Fargate stack"
else
  echo "Fargate Service URL: $SERVICE_URL"
fi

# Create .env file with S3 bucket name, CloudFront domain, and Redis information
echo "Creating .env file with deployment information"
echo "S3_BUCKET_NAME=$IMAGES_BUCKET_NAME" > ../prod.env
echo "CLOUDFRONT_DOMAIN=$DISTRIBUTION_DOMAIN" >> ../prod.env
echo "REDIS_HOST=$REDIS_ENDPOINT" >> ../prod.env
echo "REDIS_PORT=$REDIS_PORT" >> ../prod.env
echo "Environment file created at ../prod.env"


================================================
FILE: item-images/iac/distribution.yml
================================================
AWSTemplateFormatVersion: '2010-09-09'
Description: Sets up a CloudFront distribution to serve item images from the S3 bucket with global edge caching. This distribution provides fast, secure, and reliable delivery of game item images to players worldwide, with HTTPS enforcement and optimized caching policies.

Parameters:
  ImagesBucketName:
    Type: String
    Description: Name of the S3 bucket containing images
  ImagesBucketArn:
    Type: String
    Description: ARN of the S3 bucket containing images
  DomainName:
    Type: String
    Description: Domain name for the CloudFront distribution
    Default: item-images.nathanpeck.gg
  CertificateArn:
    Type: String
    Description: ARN of the ACM certificate
    Default: arn:aws:acm:us-east-1:784059518401:certificate/94e1f477-2af7-4f9a-a547-5f4ddd59474b

Resources:
  ImagesBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref ImagesBucketName
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: 's3:GetObject'
            Resource: !Sub "${ImagesBucketArn}/*"
            Condition:
              StringEquals:
                'AWS:SourceArn': !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}'
              Bool:
                aws:SecureTransport: "true"

  CloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub "OAC for ${AWS::StackName}"
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  CloudFrontLoggingBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-cf-logs-${AWS::AccountId}"
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  CloudFrontLoggingBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref CloudFrontLoggingBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:PutObject
            Resource: !Sub "${CloudFrontLoggingBucket.Arn}/*"
            Condition:
              StringEquals:
                'AWS:SourceArn': !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}'
              Bool:
                aws:SecureTransport: "true"

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        DefaultCacheBehavior:
          ViewerProtocolPolicy: redirect-to-https
          TargetOriginId: ItemImagesBucketOrigin
          AllowedMethods:
            - GET
            - HEAD
          ForwardedValues:
            QueryString: false
          MinTTL: 3600
          DefaultTTL: 86400
          MaxTTL: 31536000
          Compress: true
        Enabled: true
        HttpVersion: http3
        Aliases:
          - !Ref DomainName
        ViewerCertificate:
          AcmCertificateArn: !Ref CertificateArn
          SslSupportMethod: sni-only
          MinimumProtocolVersion: TLSv1.2_2021
        Logging:
          Bucket: !Sub "${CloudFrontLoggingBucket.DomainName}"
          Prefix: cf-logs/
          IncludeCookies: false
        Origins:
          - Id: ItemImagesBucketOrigin
            DomainName: !Sub '${ImagesBucketName}.s3.amazonaws.com'
            OriginAccessControlId: !GetAtt CloudFrontOriginAccessControl.Id
            S3OriginConfig:
              OriginAccessIdentity: ''

Outputs:
  DistributionId:
    Description: ID of the CloudFront distribution
    Value: !Ref CloudFrontDistribution
    Export:
      Name: !Sub "${AWS::StackName}-DistributionId"
  DistributionDomainName:
    Description: Domain name of the CloudFront distribution
    Value: !GetAtt CloudFrontDistribution.DomainName
    Export:
      Name: !Sub "${AWS::StackName}-DistributionDomainName"
  PlaceholderOutput:
    Description: Placeholder output value
    Value: "placeholder-cloudfront-distribution-value"




================================================
FILE: item-images/iac/fargate.yml
================================================
AWSTemplateFormatVersion: '2010-09-09'
Description: Deploys the item-images microservice to AWS Fargate, which handles image generation, storage, and retrieval for the Spirit of Kiro game. This service integrates with Amazon Bedrock for AI image generation, S3 for storage, CloudFront for delivery, and MemoryDB for vector search capabilities.

Parameters:
  Environment:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - prod
    Description: Environment (dev or prod)

  CpuArchitecture:
    Type: String
    Default: ARM64
    AllowedValues:
      - ARM64
      - X86_64
    Description: CPU architecture for the Fargate task

  ContainerImageUrl:
    Type: String
    Description: The URL of the container image to deploy

  S3BucketName:
    Type: String
    Description: Name of the S3 bucket for storing images

  CloudFrontDomain:
    Type: String
    Description: Domain name of the CloudFront distribution

  RedisHost:
    Type: String
    Description: Hostname of the Redis instance for vector storage

  MemoryDBSecurityGroupId:
    Type: AWS::EC2::SecurityGroup::Id
    Description: Security group ID of the MemoryDB cluster

  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC where the service will be deployed

  PrivateSubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Private subnets where the service will be deployed

  PublicSubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Public subnets where the load balancer will be deployed

  ContainerPort:
    Type: Number
    Default: 3001
    Description: Port exposed by the container

  ContainerCpu:
    Type: Number
    Default: 1024
    Description: CPU units for the container (1024 = 1 vCPU)

  ContainerMemory:
    Type: Number
    Default: 2048
    Description: Memory for the container in MiB

  DesiredCount:
    Type: Number
    Default: 2
    Description: Number of task instances to run

  DomainName:
    Type: String
    Default: item-images.nathanpeck.gg
    Description: Domain name for the ALB

  CertificateArn:
    Type: String
    Default: arn:aws:acm:us-west-2:784059518401:certificate/14770f21-c779-4947-aeb9-df15e77c549e
    Description: ARN of the ACM certificate

Resources:
  # ECS Cluster
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub "${AWS::StackName}-cluster"
      CapacityProviders:
        - FARGATE
        - FARGATE_SPOT
      DefaultCapacityProviderStrategy:
        - CapacityProvider: FARGATE
          Weight: 1
      ClusterSettings:
        - Name: containerInsights
          Value: "enhanced"

  # CloudWatch Log Group
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/ecs/${AWS::StackName}"
      RetentionInDays: 30

  # Task Execution Role
  TaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "${AWS::StackName}-task-execution-policy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                Resource: "*"
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/ecs/${AWS::StackName}:*"

  # Task Role (for application permissions)
  TaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "${AWS::StackName}-task-policy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # S3 permissions for image storage
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !Sub "arn:aws:s3:::${S3BucketName}"
                  - !Sub "arn:aws:s3:::${S3BucketName}/*"
              # Bedrock permissions for image generation
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                Resource: "*"

  # Task Definition
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Sub "${AWS::StackName}-task"
      Cpu: !Ref ContainerCpu
      Memory: !Ref ContainerMemory
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !GetAtt TaskExecutionRole.Arn
      TaskRoleArn: !GetAtt TaskRole.Arn
      RuntimePlatform:
        OperatingSystemFamily: LINUX
        CpuArchitecture: !Ref CpuArchitecture
      ContainerDefinitions:
        - Name: !Sub "${AWS::StackName}-container"
          Image: !Ref ContainerImageUrl
          Essential: true
          PortMappings:
            - ContainerPort: !Ref ContainerPort
              HostPort: !Ref ContainerPort
              Protocol: tcp
          Environment:
            - Name: PORT
              Value: !Ref ContainerPort
            - Name: ENVIRONMENT
              Value: !Ref Environment
            - Name: S3_BUCKET_NAME
              Value: !Ref S3BucketName
            - Name: CLOUDFRONT_DOMAIN
              Value: !Ref CloudFrontDomain
            - Name: REDIS_HOST
              Value: !Ref RedisHost
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref LogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs

  # Security Group for ECS Tasks
  ServiceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for item-images service
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !Ref ContainerPort
          ToPort: !Ref ContainerPort
          SourceSecurityGroupId: !Ref LoadBalancerSecurityGroup
          Description: Allow inbound traffic from load balancer to container port
      SecurityGroupEgress:
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic

  # Security Group Ingress Rule for MemoryDB
  MemoryDBIngressRule:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref MemoryDBSecurityGroupId
      IpProtocol: tcp
      FromPort: 6379
      ToPort: 6379
      SourceSecurityGroupId: !Ref ServiceSecurityGroup
      Description: Allow traffic from Fargate service to MemoryDB

  # Security Group for ALB
  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for item-images load balancer
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: Allow inbound HTTP traffic from anywhere
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: Allow inbound HTTPS traffic from anywhere
      SecurityGroupEgress:
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic

  # S3 Bucket for ALB Access Logs
  AlbLogsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-alb-logs-${AWS::AccountId}"
      AccessControl: Private
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  AlbLogsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref AlbLogsBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: logdelivery.elasticloadbalancing.amazonaws.com
            Action: 
              - s3:PutObject
            Resource: !Sub "arn:aws:s3:::${AlbLogsBucket}/alb-logs/AWSLogs/${AWS::AccountId}/*"
            Condition:
              ArnLike:
                aws:SourceArn: !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:loadbalancer/*"
              Bool:
                aws:SecureTransport: "true"
          - Effect: Allow
            Principal:
              Service: logdelivery.elasticloadbalancing.amazonaws.com
            Action: s3:GetBucketAcl
            Resource: !Sub "arn:aws:s3:::${AlbLogsBucket}"
            Condition:
              ArnLike:
                aws:SourceArn: !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:loadbalancer/*"
              Bool:
                aws:SecureTransport: "true"

  # Application Load Balancer
  LoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub "${AWS::StackName}-alb"
      Subnets: !Ref PublicSubnetIds
      SecurityGroups:
        - !Ref LoadBalancerSecurityGroup
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '60'
        - Key: routing.http.drop_invalid_header_fields.enabled
          Value: 'true'
        - Key: access_logs.s3.enabled
          Value: 'true'
        - Key: access_logs.s3.bucket
          Value: !Ref AlbLogsBucket
        - Key: access_logs.s3.prefix
          Value: 'alb-logs'

  # Target Group
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub "${AWS::StackName}-tg"
      Port: !Ref ContainerPort
      Protocol: HTTP
      VpcId: !Ref VpcId
      TargetType: ip
      HealthCheckPath: /
      HealthCheckIntervalSeconds: 30
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 3

  # HTTP Listener (redirects to HTTPS)
  HttpListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref LoadBalancer
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Protocol: HTTPS
            Port: '443'
            Host: !Ref DomainName
            Path: '/#{path}'
            Query: '#{query}'
            StatusCode: HTTP_301

  # HTTPS Listener
  HTTPSListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref LoadBalancer
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref CertificateArn
      SslPolicy: ELBSecurityPolicy-TLS-1-2-2017-01
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup

  # ECS Service
  Service:
    Type: AWS::ECS::Service
    DependsOn:
     - HttpListener
     - HTTPSListener
    Properties:
      ServiceName: !Sub "${AWS::StackName}-service"
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinition
      DeploymentConfiguration:
        MinimumHealthyPercent: 100
        MaximumPercent: 200
      DesiredCount: !Ref DesiredCount
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref ServiceSecurityGroup
          Subnets: !Ref PublicSubnetIds
      LoadBalancers:
        - ContainerName: !Sub "${AWS::StackName}-container"
          ContainerPort: !Ref ContainerPort
          TargetGroupArn: !Ref TargetGroup

Outputs:
  ServiceURL:
    Description: URL of the item-images service
    Value: !Sub "http://${LoadBalancer.DNSName}"
    Export:
      Name: !Sub "${AWS::StackName}-ServiceURL"

  ServiceName:
    Description: Name of the ECS service
    Value: !Ref Service
    Export:
      Name: !Sub "${AWS::StackName}-ServiceName"

  ClusterName:
    Description: Name of the ECS cluster
    Value: !Ref ECSCluster
    Export:
      Name: !Sub "${AWS::StackName}-ClusterName"

  TaskDefinitionArn:
    Description: ARN of the task definition
    Value: !Ref TaskDefinition
    Export:
      Name: !Sub "${AWS::StackName}-TaskDefinitionArn"

  LoadBalancerDNS:
    Description: DNS name of the load balancer
    Value: !GetAtt LoadBalancer.DNSName
    Export:
      Name: !Sub "${AWS::StackName}-LoadBalancerDNS"

  PlaceholderOutput:
    Description: Placeholder output value
    Value: "placeholder-fargate-service-value"


================================================
FILE: item-images/iac/images-s3.yml
================================================
AWSTemplateFormatVersion: '2010-09-09'
Description: Creates an S3 bucket for storing and serving item images in the Spirit of Kiro game. This bucket is used to store all item images that players can find and collect in the game.

Resources:
  ImagesBucket:
    Type: AWS::S3::Bucket
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LoggingConfiguration:
        DestinationBucketName: !Ref ImagesLoggingBucket
        LogFilePrefix: images-access-logs/

  ImagesLoggingBucket:
    Type: AWS::S3::Bucket
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  ImagesLoggingBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref ImagesLoggingBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: s3.amazonaws.com
            Action: 
              - s3:PutObject
            Resource: !Sub "${ImagesLoggingBucket.Arn}/*"
            Condition:
              StringEquals:
                'AWS:SourceAccount': !Ref AWS::AccountId
              Bool:
                aws:SecureTransport: "true"

Outputs:
  ImagesBucketName:
    Description: Name of the images S3 bucket
    Value: !Ref ImagesBucket
    Export:
      Name: !Sub "${AWS::StackName}-ImagesBucketName"
  ImagesBucketArn:
    Description: ARN of the images S3 bucket
    Value: !GetAtt ImagesBucket.Arn
    Export:
      Name: !Sub "${AWS::StackName}-ImagesBucketArn"
  ImagesLoggingBucketName:
    Description: Name of the images logging S3 bucket
    Value: !Ref ImagesLoggingBucket
    Export:
      Name: !Sub "${AWS::StackName}-ImagesLoggingBucketName"
  PlaceholderOutput:
    Description: Placeholder output value
    Value: "placeholder-s3-bucket-value"
  



================================================
FILE: item-images/iac/memorydb.yml
================================================
AWSTemplateFormatVersion: '2010-09-09'
Description: Creates an AWS MemoryDB cluster for the item images service, providing a Redis-compatible in-memory database with vector search capabilities. This cluster stores image metadata, handles image search queries, and manages image caching for the Spirit of Kiro game's item discovery system.

Parameters:
  NodeType:
    Type: String
    Description: The compute and memory capacity of the nodes in the MemoryDB cluster
    Default: db.r6g.large
    AllowedValues:
      - db.t4g.small
      - db.t4g.medium
      - db.r6g.large
      - db.r6g.xlarge
      - db.r6g.2xlarge
  
  NumShards:
    Type: Number
    Description: The number of shards in the MemoryDB cluster
    Default: 1
    MinValue: 1
    MaxValue: 500
  
  NumReplicasPerShard:
    Type: Number
    Description: The number of replicas per shard in the MemoryDB cluster
    Default: 0
    MinValue: 0
    MaxValue: 5
  
  EngineVersion:
    Type: String
    Description: The version of Redis OSS to use
    Default: '7.1'
    AllowedValues:
      - '6.2'
      - '7.0'
      - '7.1'
  
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: The ID of the VPC where the MemoryDB cluster will be deployed
  
  SubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: The IDs of the subnets where the MemoryDB cluster will be deployed

Resources:
  MemoryDBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for MemoryDB cluster
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 6379
          ToPort: 6379
          CidrIp: 10.0.0.0/16  # Restrict to VPC CIDR - adjust as needed
          Description: Allow inbound Redis traffic from VPC CIDR
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-memorydb-sg"

  MemoryDBSubnetGroup:
    Type: AWS::MemoryDB::SubnetGroup
    Properties:
      Description: Subnet group for MemoryDB cluster
      SubnetIds: !Ref SubnetIds
      SubnetGroupName: !Sub "${AWS::StackName}-memorydb-subnet-group"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-memorydb-subnet-group"

  MemoryDBCluster:
    Type: AWS::MemoryDB::Cluster
    Properties:
      ClusterName: !Sub "${AWS::StackName}-memorydb"
      NodeType: !Ref NodeType
      EngineVersion: !Ref EngineVersion
      NumShards: !Ref NumShards
      NumReplicasPerShard: !Ref NumReplicasPerShard
      SubnetGroupName: !Ref MemoryDBSubnetGroup
      # Immutable parameter group that enables Vector Search
      ParameterGroupName: default.memorydb-redis7.search
      SecurityGroupIds:
        - !GetAtt MemoryDBSecurityGroup.GroupId
      ACLName: open-access
      TLSEnabled: false  # Disable TLS for simplicity, enable for production
      MaintenanceWindow: "sun:05:00-sun:06:00"
      SnapshotRetentionLimit: 7

Outputs:
  MemoryDBEndpoint:
    Value: !GetAtt MemoryDBCluster.ClusterEndpoint.Address
  PlaceholderOutput:
    Description: Placeholder output value
    Value: "placeholder-memorydb-cluster-value"




================================================
FILE: item-images/lib/item-image.ts
================================================
import { BedrockRuntimeClient, InvokeModelCommand } from "@aws-sdk/client-bedrock-runtime";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { randomUUID } from 'node:crypto';
import sharp from 'sharp';
import { S3_CONFIG, CLOUDFRONT_CONFIG } from '../config';
import { nearestMatch, storeKeyValue } from '../state/vector-store';

const IMAGES_BUCKET_NAME = S3_CONFIG.bucketName;
if (!IMAGES_BUCKET_NAME) {
  throw new Error('S3_BUCKET_NAME environment variable is required');
}

const CLOUDFRONT_DISTRIBUTION_DOMAIN_NAME = CLOUDFRONT_CONFIG.domain;
if (!CLOUDFRONT_DISTRIBUTION_DOMAIN_NAME) {
  throw new Error('CLOUDFRONT_DOMAIN environment variable is required');
}

const bedrockRuntime = new BedrockRuntimeClient({ region: "us-east-1" });
const s3Client = new S3Client();

export async function generateImage(prompt) {
  const params = {
    modelId: 'amazon.nova-canvas-v1:0',
    contentType: 'application/json',
    accept: 'application/json',
    body: JSON.stringify({
      taskType: "TEXT_IMAGE", 
      textToImageParams: {
        text: prompt,
        negativeText: 'shadow, floor, human, person, realistic'
      },
      imageGenerationConfig: {
        cfgScale: 9.9,
        seed: Math.floor(Math.random() * 1000000),
        quality: "standard", 
        // Smallest possible size for Nova canvas (https://docs.aws.amazon.com/nova/latest/userguide/image-gen-access.html#image-gen-resolutions)
        width: 320, 
        height: 320,
        numberOfImages: 1
      }
    })
  };

  try {
    const command = new InvokeModelCommand(params);
    const response = await bedrockRuntime.send(command);
    const responseBody = JSON.parse(new TextDecoder().decode(response.body));
    return responseBody.images[0];
  } catch (error) {
    console.error('Error generating image:', error);
    throw error;
  }
}

export async function uploadToS3(imageData, fileName) {
  // Resize the base64 image to 320x320 pixels
  const resizedImageBuffer = await sharp(Buffer.from(imageData, 'base64'))
    .resize(320, 320)
    .toBuffer();

  const params = {
    Bucket: IMAGES_BUCKET_NAME,
    Key: fileName,
    Body: resizedImageBuffer,
    ContentType: "image/png",
    CacheControl: "public, max-age=31536000"
  };

  try {
    const command = new PutObjectCommand(params);
    await s3Client.send(command);
    return `https://${CLOUDFRONT_DISTRIBUTION_DOMAIN_NAME}/${fileName}`;
  } catch (error) {
    console.error('Error uploading to S3:', error);
    throw error;
  }
}

export async function generateAndUploadImage(item) {
  const imagePrompt = `Single, standalone ${item.icon}. Simple, rounded pixel art design, soft pastel colors. Neutral, solid color background`;
  let attempts = 0;
  let imageData;
  while (attempts < 3) {
    try {
      imageData = await generateImage(imagePrompt);
      break;
    } catch (error) {
      attempts++;
      if (attempts === 3) {
        throw error;
      }
      console.log(`Image generation attempt ${attempts} failed, retrying...`);
    }
  }  const fileName = `${item.id}.png`;
  const s3Url = await uploadToS3(imageData, fileName);
  return s3Url;
}

/**
 * Gets the key to use for vector operations for an item
 * @param {Object} item - The item object
 * @returns {string} - Key for vector operations
 */
function getItemVectorKey(item) {
  // Use the item's icon as the key for vector operations
  return item.icon;
}

/**
 * Gets an image for an item, either from the vector store or by generating a new one
 * @param {Object} item - The item object to get an image for
 * @param {number} [similarityThreshold=0.3] - Threshold for considering images similar (0-1)
 * @returns {Promise<string>} - URL of the image
 */
export async function getImage(item, similarityThreshold = 0.25) {
  let similarImage;
  try {
    // Get the key for vector operations
    const itemKey = getItemVectorKey(item);
    
    // Search for similar images in the vector store
    similarImage = await nearestMatch(itemKey);

    if (similarImage && similarImage.value.score < similarityThreshold) {
      console.log(`MATCH: "${item.icon}" to "${similarImage.value.text}" with score ${similarImage.value.score}: ${similarImage.value.value}`);
      return similarImage.value.value;
    }
    
    // No similar image found, generate a new one
    const imageUrl = await generateAndUploadImage(item);
    
    // Store the new image with its key
    await storeKeyValue(
      itemKey,  // Use item icon as the key
      imageUrl,  // Store the image URL as the value
      { id: item.id, text: itemKey }  // Store item metadata
    );
    
    console.log(`NEW: "${item.icon}" Closest match "${similarImage.value.key_text}" with score ${similarImage.value.score}: ${imageUrl}`);
    return imageUrl;
  } catch (error) {

    if (similarImage) {
      console.log(`"ERROR: ${item.icon}" fallback to "${similarImage.value.text}" with score ${similarImage.value.score}: ${similarImage.value.value}`);      
      return similarImage.value.value;
    } else {
      throw error;
    }
  }
}


================================================
FILE: item-images/scripts/generate-random-images.js
================================================
#!/usr/bin/env bun

import fetch from 'node-fetch';
import { randomInspiration } from '../../server/llm/word-lists/index.js';

// Configuration
const SERVER_URL = process.env.SERVER_URL || 'http://localhost:3001';
const NUM_IMAGES = process.env.NUM_IMAGES ? parseInt(process.env.NUM_IMAGES) : 5;

async function generateImage(description) {
  try {
    const url = `${SERVER_URL}/image?description=${encodeURIComponent(description)}`;
    console.log(`Generating image for: ${description}`);
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log(`✅ Generated image: ${data.imageUrl}`);
    return data;
  } catch (error) {
    console.error(`❌ Error generating image for "${description}":`, error.message);
    return null;
  }
}

async function main() {
  console.log(`Generating ${NUM_IMAGES} random images...`);
  
  const results = [];
  
  for (let i = 0; i < NUM_IMAGES; i++) {
    const description = randomInspiration();
    const result = await generateImage(description);
    
    if (result) {
      results.push(result);
    }
    
    // Add a small delay between requests
    if (i < NUM_IMAGES - 1) {
      await new Promise(resolve => setTimeout(resolve, 3000));
    }
  }
  
  console.log('\nSummary:');
  console.log(`Total images requested: ${NUM_IMAGES}`);
  console.log(`Successfully generated: ${results.length}`);
  console.log(`Failed: ${NUM_IMAGES - results.length}`);
}

main().catch(error => {
  console.error('Unhandled error:', error);
  process.exit(1);
});


================================================
FILE: item-images/state/redis-client.ts
================================================
import { createClient } from 'redis';
import { REDIS_CONFIG } from '../config';

console.log(`Connecting to redis://${REDIS_CONFIG.host}:${REDIS_CONFIG.port}`)

const redisClient = createClient({
    url: `redis://${REDIS_CONFIG.host}:${REDIS_CONFIG.port}`
});

redisClient.on('error', err => console.error('Redis Client Error', err));

// Connect to redis
await redisClient.connect();

export default redisClient;


================================================
FILE: item-images/state/vector-store.ts
================================================
/**
 * Vector Store implementation using Redis and AWS Bedrock Titan Embeddings
 * 
 * This module provides functionality to:
 * 1. Generate embeddings from text using AWS Bedrock Titan model
 * 2. Store key-value pairs in Redis with vector search capabilities
 * 3. Find nearest matches for input keys using vector similarity
 */

import { BedrockRuntimeClient, InvokeModelCommand } from "@aws-sdk/client-bedrock-runtime";
import redisClient from './redis-client';
import { randomUUID } from 'node:crypto';

// Constants
const VECTOR_INDEX = 'vector_index';
const VECTOR_DIM = 256; // Titan embeddings dimension
const TITAN_MODEL_ID = 'amazon.titan-embed-text-v2:0';

// Initialize Bedrock client
const bedrockRuntime = new BedrockRuntimeClient({ region: "us-east-1" });

const float32Buffer = (arr) => {
  const floatArray = new Float32Array(arr);
  const float32Buffer = Buffer.from(floatArray.buffer);
  return float32Buffer;
};

/**
 * Ensures the vector index exists in Redis
 * Creates the index if it doesn't exist
 * 
 * @returns Promise<boolean> - True if index exists or was created successfully
 */
let checkedIndex = false;
async function ensureVectorIndex(): Promise<boolean> {
  if (checkedIndex == true) {
    return true;
  }

  try {
    // Check if index exists
    const indices = await redisClient.sendCommand(['FT._LIST']);
    if (indices.includes(VECTOR_INDEX)) {
      return true;
    }

    // Create vector index with COSINE distance metric
    await redisClient.sendCommand([
      'FT.CREATE', VECTOR_INDEX,
      'ON', 'HASH', 'PREFIX', '1', 'vector:',
      'SCHEMA',
        'vector', 'VECTOR', 'HNSW', '6', 'TYPE', 'FLOAT32', 'DIM', VECTOR_DIM.toString(), 'DISTANCE_METRIC', 'COSINE',
        'value', 'TEXT',
        'key_text', 'TEXT',
        'metadata', 'TEXT',
        'createdAt', 'TEXT'
    ]);

    checkedIndex = true;
    
    console.log('Vector index created successfully');
    return true;
  } catch (error) {
    console.error('Error creating vector index:', error);
    return false;
  }
}

/**
 * Generates text embeddings using AWS Bedrock Titan model
 * 
 * @param text - Input text to generate embeddings for
 * @returns Promise<number[]> - Vector representation of the input text
 * @throws Error if embedding generation fails
 */
async function generateEmbeddings(text: string): Promise<number[]> {
  try {
    const params = {
      modelId: TITAN_MODEL_ID,
      contentType: 'application/json',
      accept: 'application/json',
      body: JSON.stringify({
        inputText: text,
        dimensions: VECTOR_DIM
      })
    };

    const command = new InvokeModelCommand(params);
    const response = await bedrockRuntime.send(command);
    const responseBody = JSON.parse(new TextDecoder().decode(response.body));
    
    if (!responseBody.embedding || !Array.isArray(responseBody.embedding)) {
      throw new Error('Invalid embedding response from Bedrock');
    }
    
    return responseBody.embedding;
  } catch (error) {
    console.error('Error generating embeddings:', error);
    throw new Error(`Failed to generate embeddings: ${error.message}`);
  }
}

/**
 * Stores a key-value pair in the vector store
 * Uses Bedrock Titan embeddings to generate a vector representation of the key
 * 
 * @param inputKey - Key to store (will be converted to vector representation)
 * @param inputValue - Value to associate with the key
 * @param metadata - Optional metadata to store with the key-value pair
 * @returns Promise<string> - ID of the stored vector entry
 */
export async function storeKeyValue(
  inputKey: string,
  inputValue: string,
  metadata?: Record<string, any>
): Promise<string> {
  try {
    // Ensure vector index exists
    const indexExists = await ensureVectorIndex();
    if (!indexExists) {
      throw new Error('Failed to ensure vector index exists');
    }
    
    // Generate embeddings for the input key
    const vector = await generateEmbeddings(inputKey);
    
    // Generate a unique ID for this entry
    const id = randomUUID();
    
    // Store vector data in Redis
    await redisClient.hSet(`vector:${id}`, {
      vector: Buffer.from(new Float32Array(vector).buffer),
      value: inputValue,
      key_text: inputKey,
      metadata: metadata ? JSON.stringify(metadata) : '{}',
      createdAt: new Date().toISOString()
    });
    
    return id;
  } catch (error) {
    console.error('Error storing key-value pair:', error);
    throw new Error(`Failed to store key-value pair: ${error.message}`);
  }
}

/**
 * Finds the nearest match for an input key in the vector store
 * Uses Bedrock Titan embeddings to generate a vector representation of the key
 * 
 * @param inputKey - Key to find nearest match for
 * @param limit - Maximum number of results to return (default: 1)
 * @returns Promise<VectorSearchResult | null> - Nearest match or null if no match found
 */
export async function nearestMatch(
  inputKey: string,
  limit: number = 1
): Promise<any> {
  try {
    // Ensure vector index exists
    const indexExists = await ensureVectorIndex();
    if (!indexExists) {
      throw new Error('Failed to ensure vector index exists');
    }
    
    // Generate embeddings for the input key
    const vector = await generateEmbeddings(inputKey);
    
    // Perform vector search in Redis
    const searchQuery = `*=>[KNN 1 @vector $query_vector AS score]`;
    const results = await redisClient.ft.search(VECTOR_INDEX, searchQuery, {
      PARAMS: {
        query_vector: float32Buffer(vector)
      },
      RETURN: ['score', 'value', 'key_text', 'metadata'],
      SORTBY: {
        BY: 'score'
      }
    })

    if (!results) {
      return;
    }

    if (results && results.total == 0) {
      return;
    }

    if (!results.documents) {
      return;
    }

    return results.documents[0];
    
    /*if (!results || results.length <= 1) {
      return null;
    }
    
    // Parse results
    const totalResults = results[0] as number;
    if (totalResults === 0) {
      return null;
    }
    
    // Get the first (closest) result
    const id = (results[1] as string).replace('vector:', '');
    const fields = results[2] as string[];
    
    // Extract fields
    const value = fields[fields.indexOf('value') + 1] as string;
    const score = parseFloat(fields[fields.indexOf('score') + 1] as string);
    const metadataStr = fields[fields.indexOf('metadata') + 1] as string;
    
    return {
      id,
      score,
      value,
      metadata: metadataStr ? JSON.parse(metadataStr) : undefined
    };*/
  } catch (error) {
    console.error('Error finding nearest match:', error);
    throw new Error(`Failed to find nearest match: ${error.message}`);
  }
}

/**
 * Deletes a vector entry by ID
 * 
 * @param id - Vector entry ID
 * @returns Promise<boolean> - True if successful
 */
export async function deleteVector(id: string): Promise<boolean> {
  try {
    await redisClient.del(`vector:${id}`);
    return true;
  } catch (error) {
    console.error('Error deleting vector:', error);
    return false;
  }
}


================================================
FILE: scripts/bootstrap-local-dynamodb.js
================================================
const { DynamoDBClient, CreateTableCommand } = require("@aws-sdk/client-dynamodb");
const { readFileSync } = require('fs');
const { parse } = require('yaml');

// Configuration
const DYNAMODB_ENDPOINT = process.env.DYNAMODB_ENDPOINT || 'http://localhost:8000';
const REGION = 'us-west-2'; // This doesn't matter for local DynamoDB
const TEMPLATE_PATH = './server/iac/dynamodb.yml';

// Initialize DynamoDB client
const dynamoClient = new DynamoDBClient({
  endpoint: DYNAMODB_ENDPOINT,
  region: REGION,
  credentials: {
    accessKeyId: 'dummy',
    secretAccessKey: 'dummy'
  }
});

async function createTable(tableDef) {
  try {
    const command = new CreateTableCommand({
      TableName: tableDef.TableName,
      BillingMode: tableDef.BillingMode,
      AttributeDefinitions: tableDef.AttributeDefinitions,
      KeySchema: tableDef.KeySchema
    });

    await dynamoClient.send(command);
    console.log(`✅ Created table: ${tableDef.TableName}`);
  } catch (error) {
    if (error.name === 'ResourceInUseException') {
      console.log(`ℹ️ Table already exists: ${tableDef.TableName}`);
    } else {
      console.error(`❌ Error creating table ${tableDef.TableName}:`, error.message);
      throw error;
    }
  }
}

async function bootstrapLocalDynamoDB() {
  console.log('🚀 Starting local DynamoDB bootstrap...');
  
  // Read and parse the CloudFormation template
  console.log(`📋 Reading template file: ${TEMPLATE_PATH}`);
  const templateContent = readFileSync(TEMPLATE_PATH, 'utf8');
  const template = parse(templateContent);
  
  // Extract table definitions from the template
  const tables = Object.entries(template.Resources)
    .filter(([_, resource]) => resource.Type === 'AWS::DynamoDB::Table')
    .map(([_, resource]) => ({
      TableName: resource.Properties.TableName,
      BillingMode: resource.Properties.BillingMode,
      AttributeDefinitions: resource.Properties.AttributeDefinitions,
      KeySchema: resource.Properties.KeySchema
    }));

  console.log(`🔍 Found ${tables.length} tables to create:`);
  tables.forEach(table => {
    console.log(`   - ${table.TableName}`);
  });

  // Create each table
  for (const table of tables) {
    console.log(`\n🔄 Processing table: ${table.TableName}`);
    console.log('   📝 Table details:');
    console.log(`      Billing Mode: ${table.BillingMode}`);
    
    console.log('   🔑 Attribute Definitions:');
    table.AttributeDefinitions.forEach(attr => {
      console.log(`      - ${attr.AttributeName} (${attr.AttributeType})`);
    });
    
    console.log('   🔐 Key Schema:');
    table.KeySchema.forEach(key => {
      console.log(`      - ${key.AttributeName} (${key.KeyType})`);
    });
    
    console.log('   🚀 Creating table...');
    await createTable(table);
  }

  console.log('\n✨ Local DynamoDB bootstrap complete!');
}

// Run the bootstrap
bootstrapLocalDynamoDB().catch(error => {
  console.error('❌ Bootstrap failed:', error);
  process.exit(1);
}); 


================================================
FILE: scripts/check-dependencies.sh
================================================
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "Checking dependencies..."

# Function to print instructions
print_instructions() {
    echo -e "\n${YELLOW}How to fix:${NC}"
    echo -e "$1"
}

# Check for Docker or Podman
if command -v docker &> /dev/null; then
    echo -e "${GREEN}✓ Docker is installed${NC}"
    docker_version=$(docker --version)
    echo "  Version: $docker_version"
elif command -v podman &> /dev/null; then
    echo -e "${GREEN}✓ Podman is installed${NC}"
    podman_version=$(podman --version)
    echo "  Version: $podman_version"
else
    echo -e "${RED}✗ Neither Docker nor Podman is installed${NC}"
    print_instructions "1. Install Docker Desktop:
   - Visit https://www.docker.com/products/docker-desktop
   - Download and install for your operating system
   - Start Docker Desktop after installation

OR

2. Install Podman:
   - macOS: brew install podman
   - Linux: Use your distribution's package manager
   - Windows: Use WSL2 and install via package manager"
    exit 1
fi

# Check AWS credentials
if ! command -v aws &> /dev/null; then
    echo -e "${RED}✗ AWS CLI is not installed${NC}"
    print_instructions "1. Install AWS CLI:
   - macOS: brew install awscli
   - Linux: pip install awscli
   - Windows: Download the MSI installer from AWS website

2. Verify installation:
   aws --version"
    exit 1
fi

echo -e "${GREEN}✓ AWS CLI is installed${NC}"

# Check AWS credentials
if ! aws sts get-caller-identity &> /dev/null; then
    echo -e "${RED}✗ AWS credentials are not configured or invalid${NC}"
    print_instructions "1. Configure AWS credentials:
   aws configure

2. Enter your credentials when prompted:
   - AWS Access Key ID
   - AWS Secret Access Key
   - Default region (e.g., us-east-1)
   - Default output format (json)

3. If you don't have credentials:
   - Log into AWS Console
   - Go to IAM → Users → Your User
   - Create new access key
   - Save the Access Key ID and Secret Access Key"
    exit 1
fi

echo -e "${GREEN}✓ AWS credentials are valid${NC}"

# Check AWS Bedrock access
echo "Checking AWS Bedrock model access..."

# List of required models
required_models=(
    "amazon.nova-pro"
    "anthropic.claude-3-sonnet-20240229"
    "anthropic.claude-3-sonnet-20240229-v1:0"
)

# List of optional models (for image generation)
optional_models=(
    "amazon.titan-text-embedding-v2"
    "amazon.nova-canvas"
)

# Get available models
available_models=$(aws bedrock list-foundation-models --query "modelSummaries[*].modelId" --output text)

# Check required models
echo -e "\nChecking required models:"
all_required_models_available=true
missing_required_models=()
for model in "${required_models[@]}"; do
    if echo "$available_models" | grep -q "$model"; then
        echo -e "${GREEN}✓ Access to $model is available${NC}"
    else
        echo -e "${RED}✗ No access to $model${NC}"
        all_required_models_available=false
        missing_required_models+=("$model")
    fi
done

if [ "$all_required_models_available" = false ]; then
    echo -e "${RED}Some required AWS Bedrock models are not accessible${NC}"
    print_instructions "1. Enable AWS Bedrock access:
   - Log into AWS Console
   - Navigate to Amazon Bedrock
   - Request access to the following models:
     ${missing_required_models[*]}

2. Wait for model access approval (usually takes <24 hours)

3. Verify access:
   aws bedrock list-foundation-models"
    exit 1
fi

# Check optional models
echo -e "\nChecking optional models (for image generation):"
missing_optional_models=()
for model in "${optional_models[@]}"; do
    if echo "$available_models" | grep -q "$model"; then
        echo -e "${GREEN}✓ Access to $model is available${NC}"
    else
        echo -e "${YELLOW}⚠ No access to $model (optional)${NC}"
        missing_optional_models+=("$model")
    fi
done

if [ ${#missing_optional_models[@]} -gt 0 ]; then
    echo -e "\n${YELLOW}Note: The following optional models are not available:${NC}"
    for model in "${missing_optional_models[@]}"; do
        echo "  - $model"
    done
    print_instructions "To enable image generation capabilities:
1. Log into AWS Console
2. Navigate to Amazon Bedrock
3. Request access to the missing models
4. Wait for approval (usually takes <24 hours)

These models are only needed if you want to generate item images yourself."
fi

echo -e "\n${GREEN}All required dependencies are satisfied!${NC}"
echo -e "${YELLOW}Note: Optional models are only needed if you want to generate item images yourself.${NC}" 


================================================
FILE: scripts/deploy-cognito.sh
================================================
#!/bin/bash

# Exit on error
set -e

# Store the original directory
ORIGINAL_DIR=$(pwd)

# Check if stack name is provided
if [ -z "$1" ]; then
  echo "Usage: $0 <stack-name>"
  echo "Example: $0 game"
  exit 1
fi

STACK_PREFIX=$1
COGNITO_STACK_NAME="${STACK_PREFIX}-cognito"
REGION=${AWS_REGION:-us-west-2}

echo "Deploying Cognito resources for stack: $COGNITO_STACK_NAME"
echo "Region: $REGION"

# Change to the iac directory
cd "$(dirname "$0")/../server/iac"

# Deploy the Cognito stack
echo "Deploying Cognito stack..."
aws cloudformation deploy \
  --template-file cognito.yml \
  --stack-name $COGNITO_STACK_NAME \
  --capabilities CAPABILITY_IAM \
  --region $REGION

# Get Cognito outputs
echo "Getting Cognito outputs..."
COGNITO_USER_POOL_ID=$(aws cloudformation describe-stacks \
  --stack-name $COGNITO_STACK_NAME \
  --query "Stacks[0].Outputs[?OutputKey=='UserPoolId'].OutputValue" \
  --output text \
  --region $REGION)

COGNITO_CLIENT_ID=$(aws cloudformation describe-stacks \
  --stack-name $COGNITO_STACK_NAME \
  --query "Stacks[0].Outputs[?OutputKey=='UserPoolClientId'].OutputValue" \
  --output text \
  --region $REGION)

COGNITO_USER_POOL_ARN=$(aws cloudformation describe-stacks \
  --stack-name $COGNITO_STACK_NAME \
  --query "Stacks[0].Outputs[?OutputKey=='UserPoolArn'].OutputValue" \
  --output text \
  --region $REGION)

echo "Deployment completed successfully!"
echo "Cognito User Pool ID: $COGNITO_USER_POOL_ID"
echo "Cognito Client ID: $COGNITO_CLIENT_ID"
echo "Cognito User Pool ARN: $COGNITO_USER_POOL_ARN"

# Return to original directory before creating .env file
cd "$ORIGINAL_DIR"

# Create a .env file with the Cognito configuration
echo "Creating .env file with Cognito configuration..."
cat > dev.env << EOL
COGNITO_USER_POOL_ID=$COGNITO_USER_POOL_ID
COGNITO_CLIENT_ID=$COGNITO_CLIENT_ID
COGNITO_USER_POOL_ARN=$COGNITO_USER_POOL_ARN
EOL

echo "Created .env file with Cognito configuration"
echo "You can now use these values in your application" 


================================================
FILE: scripts/podman-cleanup.sh
================================================
#!/bin/bash

echo "Stopping all running containers..."
podman stop $(podman ps -q) 2>/dev/null || echo "No running containers to stop"

echo "Removing all containers..."
podman rm -f $(podman ps -a -q) 2>/dev/null || echo "No containers to remove"

echo "Removing all images..."
podman rmi -f $(podman images -q) 2>/dev/null || echo "No images to remove"

echo "Removing all volumes..."
podman volume rm $(podman volume ls -q) 2>/dev/null || echo "No volumes to remove"

echo "Removing all networks..."
podman network rm $(podman network ls -q) 2>/dev/null || echo "No networks to remove"

echo "Podman cleanup complete!"



================================================
FILE: scripts/prod-deploy.sh
================================================
#!/bin/bash

# Exit on error
set -e

# Define stack prefixes and regions
ITEM_IMAGES_PREFIX="kiro-game-images"
SERVER_PREFIX="game-server"
WEST_REGION="us-west-2"
EAST_REGION="us-east-1"

# Deploy item-images
echo "📸 Deploying item-images..."
cd item-images/iac
AWS_REGION=$WEST_REGION ./deploy.sh "$ITEM_IMAGES_PREFIX"
cd ../..

# Deploy server
echo "🖥️ Deploying server..."
cd server/iac
AWS_REGION=$WEST_REGION ./deploy.sh "$SERVER_PREFIX"
cd ../..

# Get the server's load balancer DNS
echo "Getting server load balancer DNS..."
SERVER_DNS=$(AWS_REGION=$WEST_REGION aws cloudformation describe-stacks --stack-name "$SERVER_PREFIX" --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" --output text)
SERVER_ENDPOINT="game-server.nathanpeck.gg:443"

# Deploy client
echo "🌐 Deploying client..."
cd client/iac
AWS_REGION=$EAST_REGION ./deploy.sh "$SERVER_ENDPOINT" "nathanpeck.gg" "arn:aws:acm:us-east-1:784059518401:certificate/94e1f477-2af7-4f9a-a547-5f4ddd59474b"
cd ../..

echo "✅ Production deployment completed successfully!" 


================================================
FILE: server/README.md
================================================
# Game Server

This project implements a WebSocket-based game server that handles real-time multiplayer game interactions.

## Overview

The server is built using WebSocket technology to provide bidirectional communication between the game clients and the server. It manages game state, player connections, and real-time updates.

## Features

- Real-time WebSocket communication
- Player connection management
- Game state synchronization
- Secure WebSocket implementation
- Inventory management (pull, move, discard items)
- Item ownership tracking and history

## Technical Details

The server is implemented in TypeScript using the WebSocket protocol. It handles:

- Connection establishment and management
- Player authentication and session handling
- Real-time game state updates
- Error handling and connection recovery
- Item lifecycle management (creation, updates, movement between locations)
- Item ownership history tracking

## Getting Started

1. Install dependencies:
```bash
npm install
```

2. Start the server:
```bash
npm start
```

The WebSocket server will start listening for connections on the configured port.

## Configuration

The server can be configured through environment variables:
- `PORT`: The port number for the WebSocket server (default: 8080)

## Security

The server implements standard WebSocket security practices including:
- Connection validation
- Input sanitization
- Rate limiting

## Error Handling

The server includes robust error handling for:
- Connection failures
- Invalid messages
- Protocol errors
- Resource cleanup on disconnection

## API Messages

### Discard Item

**Request:**
```json
{
  "type": "discard-item",
  "body": {
    "itemId": "string"
  }
}
```

**Response (Success):**
```json
{
  "type": "item-discarded",
  "body": {
    "itemId": "string"
  }
}
```

**Response (Error):**
```json
{
  "type": "error",
  "body": "Error message"
}
```

When an item is discarded, the server tracks the last owner of the item, allowing for potential item recycling and ownership history.

### Pull Item

**Request:**
```json
{
  "type": "pull-item"
}
```

**Response (Success - Recycled Item):**
```json
{
  "type": "pulled-item",
  "body": {
    "story": "You found a discarded item and restored it to working condition.",
    "item": { /* item object */ }
  }
}
```

**Response (Success - New Item):**
```json
{
  "type": "pulled-item",
  "body": {
    "story": "Generated story about the item",
    "item": { /* item object */ }
  }
}
```

**Response (Error):**
```json
{
  "type": "error",
  "body": "Error message"
}
```

The pull-item handler first attempts to find a discarded item that wasn't previously owned by the current user. If found, it moves the item to the user's inventory. If no suitable discarded item is found, it generates a new item using the LLM. The system will try up to 5 times to find a suitable discarded item before generating a new one, to account for potential skips due to ownership history.

## Item Lifecycle

Items in the game follow a lifecycle:

1. **Creation**: Items are either generated by the LLM or recycled from the discard pile
2. **Ownership**: Items are assigned to a player's inventory
3. **Usage**: Items have skills that can be used on other items
4. **Discarding**: Items can be discarded, which marks them with their last owner
5. **Recycling**: Discarded items can be found by other players (but not by their previous owner)

The recycling system is designed to prevent players from repeatedly discarding and retrieving the same items. When a player discards an item, it's marked with their user ID in the `lastOwner` field. When pulling items from the dispenser, the system first tries to find discarded items. If a discarded item's `lastOwner` matches the current user's ID, that item is skipped, and the system tries to find another one. This ensures that players can't exploit the system by repeatedly discarding and retrieving the same items, while also encouraging item circulation among different players. The more users a server has and the more discarded items from different users, the less likely a player will encounter this ownership restriction.

The `updateItem` function allows for modifying item properties while automatically preserving critical fields like ID, userId, and creation timestamp. This is implemented through the update expression logic, which skips these fields when building the update expression. This approach is used when tracking ownership history through the `lastOwner` field.




================================================
FILE: server/bunfig.toml
================================================
[test]
preload = ["./__tests__/setup.ts"]
coverage = true


================================================
FILE: server/config.ts
================================================
import { readFileSync } from 'fs';

// Try to load environment variables from shared volume
let envConfig = {};
try {
  const envFile = readFileSync('/shared/.env', 'utf8');
  
  // Parse the .env file content
  envConfig = envFile.split('\n').reduce((acc, line) => {
    const match = line.match(/^\s*([\w.-]+)\s*=\s*(.*)?\s*$/);
    if (match) {
      const key = match[1];
      let value = match[2] || '';
      // Remove surrounding quotes if they exist
      value = value.replace(/^['"]|['"]$/g, '');
      acc[key] = value;
    }
    return acc;
  }, {});
  
  console.log('Successfully loaded environment variables from /shared/.env');
} catch (error) {
  console.log('Could not load environment variables from /shared/.env, falling back to process.env');
  console.log(`Error details: ${error.message}`);
}

// Merge loaded config with process.env, with process.env taking precedence
const getEnv = (key) => {
  return process.env[key] || envConfig[key];
};

export const DYNAMODB_CONFIG = {
  // If we are passing a real table name then we are in a live environment,
  // just use the normal DynamoDB endpoint, otherwise use the local endpoint
  endpoint: getEnv('DYNAMODB_ENDPOINT') || (getEnv('DYNAMODB_TABLE_ITEMS') ? undefined : 'http://localhost:8000'),
  tables: {
    items: getEnv('DYNAMODB_TABLE_ITEMS') || 'Items',
    inventory: getEnv('DYNAMODB_TABLE_INVENTORY') || 'Inventory',
    location: getEnv('DYNAMODB_TABLE_LOCATION') || 'Location',
    users: getEnv('DYNAMODB_TABLE_USERS') || 'Users',
    usernames: getEnv('DYNAMODB_TABLE_USERNAMES') || 'Usernames',
    persona: getEnv('DYNAMODB_TABLE_PERSONA') || 'Persona'
  }
};

export const S3_CONFIG = {
  bucketName: getEnv('S3_BUCKET_NAME'),
};

export const CLOUDFRONT_CONFIG = {
  domain: getEnv('CLOUDFRONT_DOMAIN'),
};

export const REDIS_CONFIG = {
  host: getEnv('REDIS_HOST') || 'localhost',
  port: 6379
};

export const ITEM_IMAGES_SERVICE_CONFIG = {
  url: getEnv('ITEM_IMAGES_SERVICE_URL') || 'https://item-images.nathanpeck.gg',
};

export const COGNITO_CONFIG = {
  userPoolId: getEnv('COGNITO_USER_POOL_ID') || '',
  clientId: getEnv('COGNITO_CLIENT_ID') || '',
  region: getEnv('AWS_REGION') || 'us-west-2'
};


================================================
FILE: server/devfile.yaml
================================================
schemaVersion: 2.0.0
components:
  - name: dev 
    container:
      image: public.ecr.aws/aws-mde/universal-image:latest
      env: 
        - name: DYNAMODB_ENDPOINT
          value: http://dynamodb:8000
      endpoints:
        - name: api
          targetPort: 8080
          protocol: ws
  - name: dynamodb    
    container:
      image: public.ecr.aws/aws-dynamodb-local/aws-dynamodb-local:latest
      endpoints:
        - name: dynamodb
          targetPort: 8000
          protocol: http
          secure: false
      
commands:
  - id: install
    exec:
      component: dev
      commandLine: "npx bun install"
  - id: test 
    exec:
      component: dev
      commandLine: "npx bun test __tests__/server.test.ts"


================================================
FILE: server/Dockerfile
================================================
FROM oven/bun:1.2.15

WORKDIR /app

# Copy package.json for better layer caching
COPY package.json ./

# Install dependencies
RUN bun install

# Copy the rest of the server files
COPY . .

# Create necessary directories
RUN mkdir -p /app/server/iac

# Expose port 3000
EXPOSE 3000

# Add healthcheck
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000 || exit 1

# Switch to non-root user
USER bun

# Set the command to run the server
CMD ["bun","--watch", "server.ts"]


================================================
FILE: server/package.json
================================================
{
  "name": "websocket-server",
  "version": "1.0.1",
  "description": "A simple Node.js websocket server",
  "main": "server.js",
  "scripts": {
    "start": "bun server.js",
    "test": "bun test --bail --reporter=junit --reporter-outfile=./bun-tests.xml",
    "bootstrap-dynamodb": "bun scripts/bootstrap-local-dynamodb.ts"
  },
  "dependencies": {
    "@aws-sdk/client-bedrock-runtime": "^3.0.0",
    "@aws-sdk/client-cognito-identity-provider": "^3.825.0",
    "@aws-sdk/client-dynamodb": "^3.0.0",
    "@aws-sdk/client-s3": "^3.0.0",
    "@aws-sdk/lib-dynamodb": "^3.0.0",
    "js-yaml": "^4.1.0",
    "redis": "^5.0.1",
    "sharp": "^0.34.1",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "@types/bun": "^1.1.14",
    "yaml": "^2.3.4"
  },
  "aiEditorAgent": {
    "testConfig": {
      "script": "test",
      "testReportPath": "./bun-tests.xml"
    }
  }
}



================================================
FILE: server/server.ts
================================================
import { type Serve } from 'bun';
import { ServerWebSocket } from 'bun';
import handlePing from './handlers/ping';
import handleSignin from './handlers/signin';
import handleSignup from './handlers/signup';
import handlePullItem from './handlers/pull-item';
import handleListInventory from './handlers/list-inventory';
import handleDiscardItem from './handlers/discard-item';
import handleMoveItem from './handlers/move-item';
import handleUseSkill from './handlers/use-skill';
import handleSellItem from './handlers/sell-item';
import handleFetchPersona from './handlers/fetch-persona';
import handlePeekDiscarded from './handlers/peek-discarded';
import handleBuyDiscarded from './handlers/buy-discarded';
import { formatMessage } from './utils/message';
import { WebSocketMessage, SignupMessage, SigninMessage, PullItemMessage, ListInventoryMessage, DiscardItemMessage, MoveItemMessage, UseSkillMessage, SellItemMessage, FetchPersonaMessage, PeekDiscardedMessage, BuyDiscardedMessage, ConnectionState } from './types';
import * as config from './config';

interface WebSocketData {
  state: ConnectionState;
}

/**
 * Logs all configuration values for debugging purposes
 */
function logConfigForDebugging() {  
  console.log('\n[DYNAMODB CONFIG]');
  console.log(JSON.stringify(config.DYNAMODB_CONFIG, null, 2));
  
  console.log('\n[S3 CONFIG]');
  console.log(JSON.stringify(config.S3_CONFIG, null, 2));
  
  console.log('\n[CLOUDFRONT CONFIG]');
  console.log(JSON.stringify(config.CLOUDFRONT_CONFIG, null, 2));
}

// Log all configuration values before starting the server
logConfigForDebugging();

// Handle graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received. Shutting down gracefully...');
  // Close any open connections or cleanup here if needed
  process.exit(0);
});

export default {
  port: 8080,
  async fetch(req, server) {
    // Upgrade to websocket
    if (req.headers.get('Upgrade') === 'websocket') {
      if (server.upgrade(req)) {
        return;
      }
      return new Response('Upgrade failed', { status: 500 });
    }

    // Return 200 for root path
    if (req.url.endsWith('/')) {
      return new Response('OK', { status: 200 });
    }

    return new Response("404!", { status: 404 });
  },
  websocket: {
    open(ws: ServerWebSocket<WebSocketData>) {
      const state: ConnectionState = { ws };
      ws.data = { state };
      console.log('A client connected');
    },
    async message(ws: ServerWebSocket<WebSocketData>, message: string | Buffer) {
      if (typeof message !== 'string') {
        ws.send(formatMessage('error', 'Invalid message format'));
        return;
      }

      let data: WebSocketMessage;
      try {
        data = JSON.parse(message);
      } catch (e) {
        ws.send(formatMessage('error', 'Invalid message format'));
        return;
      }

      if (!ws.data?.state) {
        ws.send(formatMessage('error', 'No connection state'));
        return;
      }

      let result: {
        type: string;
        body?: any;
      };

      console.log(`> ${ws.data.state.userId} - ${data.type}`);

      switch (data.type) {
        case 'ping':
          result = await handlePing(ws.data.state);
          ws.send(formatMessage(result.type))
          break;
        case 'signup':
          result = await handleSignup(ws.data.state, data as SignupMessage);
          ws.send(formatMessage(result.type, result.body))
          break;
        case 'signin':
          result = await handleSignin(ws.data.state, data as SigninMessage);
          ws.send(formatMessage(result.type, result.body))
          break;
        case 'pull-item':
          result = await handlePullItem(ws.data.state, data as PullItemMessage);
          ws.send(formatMessage(result.type, result.body))
          break;
        case 'list-inventory':
          result = await handleListInventory(ws.data.state, data as ListInventoryMessage);
          ws.send(formatMessage(result.type, result.body))
          break;
        case 'discard-item':
          result = await handleDiscardItem(ws.data.state, data as DiscardItemMessage);
          ws.send(formatMessage(result.type, result.body));
          break;
        case 'move-item':
          result = await handleMoveItem(ws.data.state, data as MoveItemMessage);
          ws.send(formatMessage(result.type, result.body));
          break;
        case 'use-skill':
          result = await handleUseSkill(ws.data.state, data as UseSkillMessage, ws);
          ws.send(formatMessage(result.type, result.body));
          break;
        case 'sell-item':
          result = await handleSellItem(ws.data.state, data as SellItemMessage);
          ws.send(formatMessage(result.type, result.body));
          break;
        case 'fetch-persona':
          result = await handleFetchPersona(ws.data.state, data as FetchPersonaMessage);
          ws.send(formatMessage(result.type, result.body));
          break;
        case 'peek-discarded':
          result = await handlePeekDiscarded(ws.data.state, data as PeekDiscardedMessage);
          ws.send(formatMessage(result.type, result.body));
          break;
        case 'buy-discarded':
          result = await handleBuyDiscarded(ws.data.state, data as BuyDiscardedMessage);
          ws.send(formatMessage(result.type, result.body));
          break;
        default:
          ws.send(formatMessage('error', 'Invalid message type'));
      }
    },
    close(_ws, _code, _message) {
      console.log('Client disconnected');
    },
    drain(_ws) { }
  }
} satisfies Serve;



================================================
FILE: server/types.ts
================================================
import { ServerWebSocket } from 'bun';

export interface ConnectionState {
  ws: ServerWebSocket;
  userId?: string;
  username?: string;
}

export interface SignupMessage {
    type: 'signup';
    body: {
        username: string;
        password: string;
    };
}

export interface SigninMessage {
    type: 'signin';
    body: {
        username: string;
        password: string;
    };
}

export interface PullItemMessage {
    type: 'pull-item';
    params: {
        userId: string;
    };
}

export interface ListInventoryMessage {
    type: 'list-inventory';
    body: {
        inventoryId: string;
    };
}

export interface DiscardItemMessage {
    type: 'discard-item';
    body: {
        itemId: string;
    };
}

export interface MoveItemMessage {
    type: 'move-item';
    body: {
        itemId: string;
        targetInventory: string;
    };
}

export interface UseSkillMessage {
    type: 'use-skill';
    body: {
        toolId: string;
        toolSkillIndex: number;
        targetIds: string[];
    };
}

export interface SellItemMessage {
    type: 'sell-item';
    body: {
        itemId: string;
    };
}

export interface FetchPersonaMessage {
  type: 'fetch-persona';
  body: {};
}

export interface PeekDiscardedMessage {
    type: 'peek-discarded';
    body: {
        numberOfItems: number;
    };
}

export interface BuyDiscardedMessage {
    type: 'buy-discarded';
    body: {
        itemId: string;
    };
}

export type WebSocketMessage = SignupMessage | SigninMessage | PullItemMessage | ListInventoryMessage | DiscardItemMessage | MoveItemMessage | UseSkillMessage | SellItemMessage | FetchPersonaMessage | PeekDiscardedMessage | BuyDiscardedMessage;



================================================
FILE: server/.dockerignore
================================================
node_modules


================================================
FILE: server/__tests__/server.test.ts
================================================
import { describe, beforeAll, afterAll, expect, test } from 'bun:test';
import { eventToData, once, setupDatabase } from './util';

let socket: WebSocket;

beforeAll(async () => {
  await setupDatabase();
  // amazonq-ignore-next-line
  socket = new WebSocket("ws://localhost:8080");

  await new Promise((resolve, reject) => {
    socket.onopen = resolve;
    socket.onerror = reject;
  });
});

afterAll(() => {
  if (socket) {
    socket.close();
  }
});

describe('WebSocket server', () => {
  test('should handle malformed messages', async () => {
    socket.send('malformed message');
    const event = await once(socket, 'message');
    const data = eventToData(event);
    expect(data).toEqual({ type: 'error', body: 'Invalid message format' })
  });

  test('should handle unknown message types', async () => {
    socket.send(JSON.stringify({ type: 'unknown' }));
    const event = await once(socket, 'message');
    const data = eventToData(event);
    expect(data).toEqual({ type: 'error', body: 'Invalid message type' })
  });
});


================================================
FILE: server/__tests__/setup.ts
================================================
import { serve } from "bun";
import { beforeAll, afterAll } from "bun:test";
import * as ServerSettings from '../server.js';
import { setupDatabase } from './util';

let Server: ReturnType<typeof serve>;

beforeAll(async () => {
  await setupDatabase();
  Server = serve(ServerSettings.default);
});

afterAll(() => {
  Server.stop();
});



================================================
FILE: server/__tests__/util.ts
================================================

import { DynamoDBClient, CreateTableCommand, DeleteTableCommand, DescribeTableCommand } from '@aws-sdk/client-dynamodb';
import { DYNAMODB_CONFIG } from '../config';

export function eventToData(event: { data: string }) {
  if (!event.data) {
    console.error("Malformed event: ", event);
    return null;
  }

  try {
    return JSON.parse(event.data)
  } catch (e) {
    console.error("Malformed event data: ", event.data);
    return null;
  }
}

export function formatMessage(messageType: string, params?: any) {
  return JSON.stringify({
    type: messageType,
    body: params
  })
}

// Utility to convert WebSocket events to promises
export function once<T extends keyof WebSocketEventMap>(
  socket: WebSocket,
  eventName: T
): Promise<WebSocketEventMap[T]> {
  return new Promise((resolve, reject) => {
    socket.addEventListener(eventName, resolve, { once: true });
    socket.addEventListener('error', reject, { once: true });
  });
}

// Helper functions
export async function setupSocket(url: string): Promise<WebSocket> {
  const socket = new WebSocket(url);
  await once(socket, 'open');
  return socket;
}

export async function signupUser(socket: WebSocket, user: any): Promise<void> {
  socket.send(formatMessage('signup', user));
  const event = await once(socket, 'message');
  const data = eventToData(event);

  if (data.type !== 'signup_success') {
    console.error('Failed to signup user: ', data);
    process.exit(1);
  }
}

export async function signinUser(socket: WebSocket, user: any): Promise<{ userId: string }> {
  socket.send(formatMessage('signin', user));
  const event = await once(socket, 'message');
  const data = eventToData(event);

  if (data.type !== 'signin_success') {
    console.error('Failed to signup user: ', data);
    process.exit(1);
  }

  return data.body;
}

export async function setupDatabase() {
  const client = new DynamoDBClient(DYNAMODB_CONFIG);
  // Check and delete existing tables
  const tables = ['Users', 'Usernames', 'Items', 'Inventory', 'Location', 'Persona'];

  for (const table of tables) {
    try {
      await client.send(new DescribeTableCommand({ TableName: table }));
      // Table exists, delete it
      await client.send(new DeleteTableCommand({ TableName: table }));
    } catch (err: any) {
      // Table doesn't exist, continue
      if (err.name !== 'ResourceNotFoundException') {
        console.error(`Error checking/deleting table ${table}:`, err);
      }
    }
  }

  // Create Users table
  try {
    await client.send(new CreateTableCommand({
      TableName: 'Users',
      AttributeDefinitions: [{
        AttributeName: 'userId',
        AttributeType: 'S'
      }],
      KeySchema: [{
        AttributeName: 'userId',
        KeyType: 'HASH'
      }],
      ProvisionedThroughput: {
        ReadCapacityUnits: 1,
        WriteCapacityUnits: 1
      }
    }));

    // Create Usernames table
    await client.send(new CreateTableCommand({
      TableName: 'Usernames',
      AttributeDefinitions: [{
        AttributeName: 'username',
        AttributeType: 'S'
      }],
      KeySchema: [{
        AttributeName: 'username',
        KeyType: 'HASH'
      }],
      ProvisionedThroughput: {
        ReadCapacityUnits: 1,
        WriteCapacityUnits: 1
      }
    }));

    // Create Items table
    await client.send(new CreateTableCommand({
      TableName: 'Items',
      AttributeDefinitions: [{
        AttributeName: 'id',
        AttributeType: 'S'
      }],
      KeySchema: [{
        AttributeName: 'id',
        KeyType: 'HASH'
      }],
      ProvisionedThroughput: {
        ReadCapacityUnits: 1,
        WriteCapacityUnits: 1
      }
    }));

    // Create Inventory table
    await client.send(new CreateTableCommand({
      TableName: 'Inventory',
      KeySchema: [
        { AttributeName: 'id', KeyType: 'HASH' },
        { AttributeName: 'itemId', KeyType: 'RANGE' }
      ],
      AttributeDefinitions: [
        { AttributeName: 'id', AttributeType: 'S' },
        { AttributeName: 'itemId', AttributeType: 'S' }
      ],
      ProvisionedThroughput: {
        ReadCapacityUnits: 5,
        WriteCapacityUnits: 5
      }
    }));

    // Create Location table
    await client.send(new CreateTableCommand({
      TableName: 'Location',
      KeySchema: [
        { AttributeName: 'itemId', KeyType: 'HASH' },
        { AttributeName: 'location', KeyType: 'RANGE' }
      ],
      AttributeDefinitions: [
        { AttributeName: 'itemId', AttributeType: 'S' },
        { AttributeName: 'location', AttributeType: 'S' }
      ],
      ProvisionedThroughput: {
        ReadCapacityUnits: 5,
        WriteCapacityUnits: 5
      }
    }));

    // Create Persona table
    await client.send(new CreateTableCommand({
      TableName: 'Persona',
      KeySchema: [
        { AttributeName: 'userId', KeyType: 'HASH' },
        { AttributeName: 'detail', KeyType: 'RANGE' }
      ],
      AttributeDefinitions: [
        { AttributeName: 'userId', AttributeType: 'S' },
        { AttributeName: 'detail', AttributeType: 'S' }
      ],
      ProvisionedThroughput: {
        ReadCapacityUnits: 5,
        WriteCapacityUnits: 5
      }
    }));

  } catch (err) {
    console.error('Error creating tables:', err);
  }
}



================================================
FILE: server/__tests__/ws.d.ts
================================================
declare module 'ws';


================================================
FILE: server/handlers/buy-discarded.ts
================================================
import { moveItemLocation, locationForItemId, getItemById } from '../state/item-store';
import { ConnectionState } from '../types';
import { appraiseItem } from '../llm/prompts';
import { getPersonaDetails, incrementPersonaDetail } from '../state/user-store';

interface BuyDiscardedMessage {
  type: 'buy-discarded';
  body: {
    itemId: string;
  };
}

interface BuyDiscardedResponse {
  type: string;
  body?: any;
}

export default async function handleBuyDiscarded(state: ConnectionState, data: BuyDiscardedMessage): Promise<BuyDiscardedResponse> {
  if (!state.userId) {
    return {
      type: 'error',
      body: 'Authentication required'
    };
  }

  try {
    // Verify the item exists and is in the discarded location
    const currentLocation = await locationForItemId(data.body.itemId);
    if (!currentLocation || currentLocation !== 'discarded') {
      return {
        type: 'error',
        body: 'Item not found in discarded items'
      };
    }

    // Get the item details
    const item = await getItemById(data.body.itemId);
    if (!item) {
      return {
        type: 'error',
        body: 'Item not found'
      };
    }

    // Get the item's value directly from the item
    const purchasePrice = item.value || 0;

    // Check if player has enough gold
    const personaDetails = await getPersonaDetails(state.userId);
    const currentGold = parseInt(personaDetails.gold || '0', 10);
    if (currentGold < purchasePrice) {
      return {
        type: 'error',
        body: 'Not enough gold to purchase this item'
      };
    }

    // Deduct the gold (using incrementPersonaDetail with negative amount)
    const newGold = await incrementPersonaDetail(state.userId, 'gold', -purchasePrice);

    // Move the item to the player's inventory
    await moveItemLocation(data.body.itemId, 'discarded', `${state.userId}:main`);
    
    return {
      type: 'buy-results',
      body: { 
        itemId: data.body.itemId,
        item: item,
        gold: newGold,
        purchasePrice
      }
    };
  } catch (error) {
    console.error('Error buying discarded item:', error);
    return {
      type: 'error',
      body: 'Failed to buy item'
    };
  }
} 


================================================
FILE: server/handlers/discard-item.ts
================================================
import { moveItemLocation, locationForItemId, getItemById, updateItem } from '../state/item-store';
import { ConnectionState } from '../types';

interface DiscardItemMessage {
  type: 'discard-item';
  body: {
    itemId: string;
  };
}

interface DiscardItemResponse {
  type: string;
  body?: any;
}

export default async function handleDiscardItem(state: ConnectionState, data: DiscardItemMessage): Promise<DiscardItemResponse> {
  if (!state.userId) {
    return {
      type: 'error',
      body: 'Authentication required'
    };
  }

  try {
    const currentLocation = await locationForItemId(data.body.itemId);

    if (!currentLocation) {
      return {
        type: 'error',
        body: 'Item not found'
      };
    }

    if (!currentLocation.startsWith(state.userId)) {
      return {
        type: 'error',
        body: 'Item not in your inventory'
      };
    }

    // Get the item and update it to set the lastOwner field
    const item = await getItemById(data.body.itemId);
    if (item) {
      // Set the lastOwner field to the current user's ID
      await updateItem(data.body.itemId, { lastOwner: state.userId });
    }

    // Move the item to the discarded location
    await moveItemLocation(data.body.itemId, currentLocation, 'discarded');
    return {
      type: 'item-discarded',
      body: { itemId: data.body.itemId }
    };
  } catch (error) {
    console.error('Error discarding item:', error);
    return {
      type: 'error',
      body: 'Failed to discard item'
    };
  }
}


================================================
FILE: server/handlers/fetch-persona.ts
================================================
import { ConnectionState } from '../types';
import { getPersonaDetails } from '../state/user-store';

interface FetchPersonaMessage {
  type: 'fetch-persona';
  body: {};
}

interface FetchPersonaResponse {
  type: string;
  body?: any;
}

export default async function handleFetchPersona(state: ConnectionState, _data: FetchPersonaMessage): Promise<FetchPersonaResponse> {
  if (!state.userId) {
    return {
      type: 'error',
      body: 'Authentication required'
    };
  }

  try {
    const details = await getPersonaDetails(state.userId);
    return {
      type: 'persona-details',
      body: details
    };
  } catch (error) {
    console.error('Error fetching persona details:', error);
    return {
      type: 'error',
      body: 'Failed to fetch persona details'
    };
  }
} 


================================================
FILE: server/handlers/list-inventory.ts
================================================
import { ConnectionState } from '../types';
import { listInventoryItems } from '../state/item-store';

interface ListInventoryMessage {
  type: 'list-inventory';
  body: {
    inventoryId: string;
  };
}

interface ListInventoryResponse {
  type: string;
  body: any;
}

export default async function handleListInventory(state: ConnectionState, data: ListInventoryMessage): Promise<ListInventoryResponse> {
  if (!state.userId) {
    return {
      type: 'error',
      body: 'Authentication required'
    };
  }

  // Check if trying to access someone else's inventory
  if (!data.body.inventoryId.startsWith(state.userId)) {
    return {
      type: 'error',
      body: `Cannot access inventory ${data.body.inventoryId}`
    };
  }

  try {
    const items = await listInventoryItems(data.body.inventoryId);
    // Extract inventory name from inventoryId (format: userId:inventoryName)
    const inventoryName = data.body.inventoryId.split(':')[1] || 'unknown';
    return {
      type: `inventory-items:${inventoryName}`,
      body: items
    };
  } catch (error) {
    console.error('Error listing inventory items:', error);
    return {
      type: 'error',
      body: 'Failed to list inventory items'
    };
  }
}



================================================
FILE: server/handlers/move-item.ts
================================================
import { ConnectionState } from '../types';
import { moveItemLocation, locationForItemId } from '../state/item-store';

interface MoveItemMessage {
  type: 'move-item';
  body: {
    itemId: string;
    targetInventoryId: string;
  };
}

interface MoveItemResponse {
  type: string;
  body?: any;
}

const VALID_DESTINATION_INVENTORIES = ['main', 'chest1', 'workbench-working', 'workbench-tools'];
const VALID_SOURCE_INVENTORIES = ['main', 'chest1', 'workbench-working', 'workbench-tools', 'workbench-results'];

export default async function handleMoveItem(state: ConnectionState, data: MoveItemMessage): Promise<MoveItemResponse> {
  if (!state.userId) {
    return {
      type: 'error',
      body: 'Authentication required'
    };
  }

  const { itemId, targetInventoryId } = data.body;

  if (!itemId) {
    return {
      type: 'error',
      body: '`itemId` required'
    };
  }

  if (!targetInventoryId) {
    return {
      type: 'error',
      body: '`targetInventoryId` required'
    };
  }

  const [targetInventoryUser, targetInventoryName] = targetInventoryId.split(':');
  
  // Validate that targetInventory is a valid inventory name
  if (!VALID_DESTINATION_INVENTORIES.includes(targetInventoryName)) {
    return {
      type: 'error',
      body: `Invalid target inventory \`${targetInventoryName}\`, only valid options are ${VALID_DESTINATION_INVENTORIES}`
    };
  }

  try {
    // Check that the item exists
    const currentLocation = await locationForItemId(itemId);
    
    if (!currentLocation) {
      return {
        type: 'error',
        body: `Item ${itemId} not found`
      };
    }

    // Parse the current location to get the source inventory
    const [sourceUserId, sourceInventoryName] = currentLocation.split(':');
    
    // Check that the item belongs to the current user
    if (sourceUserId !== state.userId) {
      return {
        type: 'error',
        body: `Can't move item that you don't own. Item is in inventory ${currentLocation}`
      };
    }
    
    // Check that the source inventory is valid
    if (!VALID_SOURCE_INVENTORIES.includes(sourceInventoryName)) {
      return {
        type: 'error',
        body: `Source item is not in a valid inventory for moving. Item is in inventory ${currentLocation}`
      };
    }
    
    // Check that source and target are not the same
    if (sourceInventoryName === targetInventoryName) {
      return {
        type: 'error',
        body: 'Item is already in the given inventory'
      };
    }

    // Move the item from the source inventory to the target inventory
    const targetInventoryId = `${state.userId}:${targetInventoryName}`;
    await moveItemLocation(itemId, currentLocation, targetInventoryId);
    
    return {
      type: 'item-moved',
      body: { itemId, targetInventoryId }
    };
  } catch (error) {
    console.error('Error moving item:', error);
    return {
      type: 'error',
      body: error.message
    };
  }
}


================================================
FILE: server/handlers/peek-discarded.ts
================================================
import { ConnectionState } from '../types';
import { findJunkItem } from '../state/item-store';
import { ItemResponse } from '../state/item-store';

interface PeekDiscardedMessage {
  type: 'peek-discarded';
  body: {
    numberOfItems: number;
  };
}

interface PeekDiscardedResponse {
  type: string;
  body?: any;
}

export default async function handlePeekDiscarded(state: ConnectionState, data: PeekDiscardedMessage): Promise<PeekDiscardedResponse> {
  if (!state.userId) {
    return {
      type: 'error',
      body: 'Authentication required'
    };
  }

  try {
    const { numberOfItems } = data.body;
    const items: ItemResponse[] = [];
    const seenItemIds = new Set<string>();
    let attempts = 0;
    const MAX_ATTEMPTS = 30;

    // Find the requested number of items
    while (items.length < numberOfItems && attempts < MAX_ATTEMPTS) {
      const item = await findJunkItem();
      if (item && !seenItemIds.has(item.id)) {
        items.push(item);
        seenItemIds.add(item.id);
      }
      attempts++;
    }

    return {
      type: 'discarded-results',
      body: items
    };
  } catch (error) {
    console.error('Error peeking discarded items:', error);
    return {
      type: 'error',
      body: 'Failed to peek discarded items'
    };
  }
} 


================================================
FILE: server/handlers/ping.ts
================================================
import { ConnectionState } from '../types';

interface PingResponse {
  type: string;
}

export default async function handlePing(_state: ConnectionState): Promise<PingResponse> {
  return {
    type: "pong"
  };
}



================================================
FILE: server/handlers/pull-item.ts
================================================
import { ConnectionState, PullItemMessage } from '../types';
import { generateItems } from '../llm/prompts';
import { createItem, moveItemLocation, findJunkItem } from '../state/item-store';
import { ITEM_IMAGES_SERVICE_CONFIG } from '../config';

interface PullItemResponse {
  type: string;
  body?: any;
}

async function generateNewItem(userId: string) {
  const resultData = await generateItems(1);
  if (!resultData) {
    throw new Error('No result from LLM');
  }

  const itemData = resultData.items[0];
  const id = crypto.randomUUID();

  // Fetch image from the item-images service
  try {
    const imageServiceUrl = `${ITEM_IMAGES_SERVICE_CONFIG.url}/image`;
    const description = itemData.icon;
    const response = await fetch(`${imageServiceUrl}?description=${encodeURIComponent(description)}`);

    if (!response.ok) {
      throw new Error(`Image service returned status ${response.status}`);
    }

    const imageData = await response.json();
    itemData.imageUrl = imageData.imageUrl;
  } catch (error) {
    console.error('Error fetching image from item-images service:', error);
  }

  const savedItem = await createItem(id, userId, itemData);
  return {
    story: resultData.story,
    item: savedItem
  };
}

export default async function handlePullItem(state: ConnectionState, _data: PullItemMessage): Promise<PullItemResponse> {
  if (!state.userId) {
    return {
      type: 'error',
      body: 'Authentication required'
    };
  }

  try {
    // 20% chance to generate a new item directly
    if (Math.random() < 0.2) {
      const result = await generateNewItem(state.userId);
      return {
        type: 'pulled-item',
        body: result
      };
    }

    // Try to find a junk item up to 5 times (increased to account for potential skips)
    for (let i = 0; i < 5; i++) {
      const junkItem = await findJunkItem();
      if (junkItem) {
        // Check if this item was previously owned by the current user
        if (junkItem.lastOwner === state.userId) {
          console.log(`Skipping item ${junkItem.id} as it was previously owned by user ${state.userId}`);
          continue; // Skip this item and try to find another one
        }
        
        // Move item from junk to user's inventory
        await moveItemLocation(junkItem.id, 'discarded', `${state.userId}:main`);
        return {
          type: 'pulled-item',
          body: {
            story: `Whoosh! The ${junkItem.name} flies out in a gentle arc.`,
            item: junkItem
          }
        };
      }
    }

    // If no junk item found, generate new one
    const result = await generateNewItem(state.userId);
    return {
      type: 'pulled-item',
      body: result
    };
  } catch (error) {
    console.error('Error generating item:', error);
    return {
      type: 'error',
      body: 'Failed to generate item'
    };
  }
}


================================================
FILE: server/handlers/sell-item.ts
================================================
import { moveItemLocation, locationForItemId, getItemById, updateItem } from '../state/item-store';
import { ConnectionState } from '../types';
import { appraiseItem } from '../llm/prompts';
import { incrementPersonaDetail } from '../state/user-store';

interface SellItemMessage {
  type: 'sell-item';
  body: {
    itemId: string;
  };
}

interface SellItemResponse {
  type: string;
  body?: any;
}

export default async function handleSellItem(state: ConnectionState, data: SellItemMessage): Promise<SellItemResponse> {
  if (!state.userId) {
    return {
      type: 'error',
      body: 'Authentication required'
    };
  }

  try {
    const currentLocation = await locationForItemId(data.body.itemId);

    if (!currentLocation) {
      return {
        type: 'error',
        body: 'Item not found'
      };
    }

    if (!currentLocation.startsWith(state.userId)) {
      return {
        type: 'error',
        body: 'Item not in your inventory'
      };
    }

    // Get the item details
    const item = await getItemById(data.body.itemId);
    if (!item) {
      return {
        type: 'error',
        body: 'Item not found'
      };
    }

    // Set the lastOwner field to the current user's ID
    await updateItem(data.body.itemId, { lastOwner: state.userId });

    // Use the LLM to appraise the item
    const appraisal = await appraiseItem(item);

    // Increment the player's gold with the sale amount
    const newGold = await incrementPersonaDetail(state.userId, 'gold', appraisal.appraisal.saleAmount || 0);

    // Move the item to the discarded location
    await moveItemLocation(data.body.itemId, currentLocation, 'discarded');
    
    return {
      type: 'item-sold',
      body: { 
        itemId: data.body.itemId,
        appraisal,
        gold: newGold
      }
    };
  } catch (error) {
    console.error('Error selling item:', error);
    return {
      type: 'error',
      body: 'Failed to sell item'
    };
  }
}


================================================
FILE: server/handlers/signin.ts
================================================
import { SigninMessage, ConnectionState } from '../types';
import { COGNITO_CONFIG } from '../config';
import { InitiateAuthCommand, GetUserCommand, CognitoIdentityProviderClient } from '@aws-sdk/client-cognito-identity-provider';

const cognitoClient = new CognitoIdentityProviderClient({
  region: COGNITO_CONFIG.region
});

interface SigninResponse {
  type: string;
  body?: any;
}

export default async function handleSignin(state: ConnectionState, data: SigninMessage): Promise<SigninResponse> {
  try {
    const { username, password } = data.body;

    if (!username) {
      return {
        type: "signin_failure",
        body: "`username` is required"
      };
    }

    if (!password) {
      return {
        type: "signin_failure",
        body: "`password` is required"
      };
    }

    // Authenticate with Cognito
    const authCommand = new InitiateAuthCommand({
      AuthFlow: 'USER_PASSWORD_AUTH',
      ClientId: COGNITO_CONFIG.clientId,
      AuthParameters: {
        USERNAME: username,
        PASSWORD: password
      }
    });

    const authResult = await cognitoClient.send(authCommand);

    // Get user details
    const userCommand = new GetUserCommand({
      AccessToken: authResult.AuthenticationResult?.AccessToken
    });

    const userResult = await cognitoClient.send(userCommand);

    // Get the user's sub (unique ID) from the attributes
    const subAttribute = userResult.UserAttributes?.find(attr => attr.Name === 'sub');
    if (!subAttribute?.Value) {
      throw new Error('Could not get user ID');
    }

    state.userId = subAttribute.Value;
    state.username = username;

    return {
      type: "signin_success",
      body: { 
        username, 
        userId: subAttribute.Value
      }
    };
  } catch (error: any) {
    console.error('Signin error:', error);
    return {
      type: "signin_failure",
      body: error.message
    };
  }
}



================================================
FILE: server/handlers/signup.ts
================================================
import { SignupMessage, ConnectionState } from '../types';
import { COGNITO_CONFIG } from '../config';
import { 
  SignUpCommand, 
  AdminConfirmSignUpCommand,
  CognitoIdentityProviderClient 
} from '@aws-sdk/client-cognito-identity-provider';

const cognitoClient = new CognitoIdentityProviderClient({
  region: COGNITO_CONFIG.region
});

interface SignupResponse {
  type: string;
  body?: any;
}

export default async function handleSignup(state: ConnectionState, data: SignupMessage): Promise<SignupResponse> {
  const { username, password } = data.body;

  if (!username) {
    return {
      type: "signup_failure",
      body: "`username` is required"
    };
  }

  if (!password) {
    return {
      type: "signup_failure",
      body: "`password` is required"
    };
  }

  try {
    // First, sign up the user
    const signUpCommand = new SignUpCommand({
      ClientId: COGNITO_CONFIG.clientId,
      Username: username,
      Password: password,
      UserAttributes: [
        {
          Name: 'email',
          Value: username
        },
        {
          Name: 'preferred_username',
          Value: username
        }
      ]
    });

    const signUpResult = await cognitoClient.send(signUpCommand);

    // Then, automatically confirm the user
    const confirmCommand = new AdminConfirmSignUpCommand({
      UserPoolId: COGNITO_CONFIG.userPoolId,
      Username: username
    });

    await cognitoClient.send(confirmCommand);

    state.userId = signUpResult.UserSub;
    state.username = username;

    return {
      type: "signup_success",
      body: { 
        username, 
        userId: signUpResult.UserSub,
        userConfirmed: true
      }
    };
  } catch (error: any) {
    return {
      type: "signup_failure",
      body: error.message
    };
  }
}



================================================
FILE: server/handlers/use-skill.ts
================================================
import { ConnectionState } from '../types';
import { getItemById, locationForItemId, createItem, moveItemLocation, updateItem } from '../state/item-store';
import { useSkillStream } from '../llm/prompts';
import { ITEM_IMAGES_SERVICE_CONFIG } from '../config';
import { ServerWebSocket } from 'bun';
import { formatMessage } from '../utils/message';

interface UseSkillMessage {
  type: 'use-skill';
  body: {
    toolId: string;
    toolSkillIndex: number;
    targetIds: string[];
  };
}

interface UseSkillResponse {
  type: string;
  body?: any;
}

export default async function handleUseSkill(state: ConnectionState, data: UseSkillMessage, ws: ServerWebSocket): Promise<UseSkillResponse> {
  if (!state.userId) {
    return {
      type: 'error',
      body: 'Authentication required'
    };
  }

  const { toolId, toolSkillIndex, targetIds } = data.body;

  if (!toolId) {
    return {
      type: 'error',
      body: '`toolId` required'
    };
  }

  if (toolSkillIndex === undefined || toolSkillIndex < 0) {
    return {
      type: 'error',
      body: '`toolSkillIndex` required and must be a non-negative number'
    };
  }

  if (!targetIds || !Array.isArray(targetIds)) {
    return {
      type: 'error',
      body: '`targetIds` required and must be an array, though it may be empty'
    };
  }

  try {
    // Check that the tool item exists and belongs to the user
    const toolLocation = await locationForItemId(toolId);
    if (!toolLocation) {
      return {
        type: 'error',
        body: `Tool item ${toolId} not found`
      };
    }

    const [toolUserId] = toolLocation.split(':');
    if (toolUserId !== state.userId) {
      return {
        type: 'error',
        body: `Can't use a tool that you don't own`
      };
    }

    // Get the tool item
    const toolItem = await getItemById(toolId);
    if (!toolItem) {
      return {
        type: 'error',
        body: `Tool item ${toolId} not found in database`
      };
    }

    // Check if the tool has the requested skill
    if (!toolItem.skills || !toolItem.skills[toolSkillIndex]) {
      return {
        type: 'error',
        body: `Tool item does not have a skill at index ${toolSkillIndex}`
      };
    }

    // Get all target items and verify ownership
    const targetItems = [];
    for (const targetId of targetIds) {
      const targetLocation = await locationForItemId(targetId);
      if (!targetLocation) {
        return {
          type: 'error',
          body: `Target item ${targetId} not found`
        };
      }

      const [targetUserId] = targetLocation.split(':');
      if (targetUserId !== state.userId) {
        return {
          type: 'error',
          body: `Can't use a skill on an item that you don't own`
        };
      }

      const targetItem = await getItemById(targetId);
      if (!targetItem) {
        return {
          type: 'error',
          body: `Target item ${targetId} not found in database`
        };
      }

      targetItems.push(targetItem);
    }

    // Track processed items and removed items
    const processedItems = [];
    const removedItemIds = [];
    let story = '';
    let pendingImageCount = 0;

    // Use the skill with streaming response
    useSkillStream(toolItem, toolSkillIndex, targetItems, {
      // Handle story chunks as they arrive
      onStory: async (storyChunk) => {
        story = storyChunk;
        // Send the story immediately to the client
        ws.send(formatMessage('skill-use-story', { story: storyChunk }));
      },
      
      // Handle output items as they arrive
      onOutputItem: async (item) => {
        // Helper function to handle image regeneration
        const regenerateImage = async (item: any, existingItem: any) => {
          if (item.icon && existingItem?.icon !== item.icon) {
            try {
              pendingImageCount++;
              const imageServiceUrl = `${ITEM_IMAGES_SERVICE_CONFIG.url}/image`;
              const description = item.icon;
              const response = await fetch(`${imageServiceUrl}?description=${encodeURIComponent(description)}`);

              if (response.ok) {
                const imageData = await response.json();
                item.imageUrl = imageData.imageUrl;
              }
            } catch (error) {
              console.error('Error fetching image from item-images service:', error);
            } finally {
              pendingImageCount--;
            }
          }

          if (!item.imageUrl && existingItem?.imageUrl) {
            item.imageUrl = existingItem.imageUrl;
          }
        };

        if (item.id === 'new-item') {
          // Create a new item
          const id = crypto.randomUUID();
          item.id = id;

          // Try to fetch an image for the new item if it has an icon
          if (item.icon) {
            try {
              pendingImageCount++;
              const imageServiceUrl = `${ITEM_IMAGES_SERVICE_CONFIG.url}/image`;
              const description = item.icon;
              const response = await fetch(`${imageServiceUrl}?description=${encodeURIComponent(description)}`);

              if (response.ok) {
                const imageData = await response.json();
                item.imageUrl = imageData.imageUrl;
              }
            } catch (error) {
              console.error('Error fetching image from item-images service:', error);
            } finally {
              pendingImageCount--;
            }
          }

          const savedItem = await createItem(id, state.userId, item, `workbench-results`);
          processedItems.push(savedItem);
          
          // Send new item to client
          ws.send(formatMessage('skill-use-new-item', { item: savedItem }));
        } else if (item.id === toolId) {
          // Handle tool update
          const existingItem = await getItemById(item.id);
          await regenerateImage(item, existingItem);
          
          const updatedTool = await updateItem(item.id, item);
          processedItems.push(updatedTool);
          
          // Send tool update to client
          ws.send(formatMessage('skill-use-tool-update', { tool: updatedTool }));
        } else {
          // Handle target item update
          const existingItem = await getItemById(item.id);
          await regenerateImage(item, existingItem);
          
          const updatedItem = await updateItem(item.id, item);
          
          // Move it to the workbench-results inventory
          const itemLocation = await locationForItemId(item.id);
          if (itemLocation && itemLocation !== `${state.userId}:workbench-results`) {
            await moveItemLocation(item.id, itemLocation, `${state.userId}:workbench-results`);
          }

          processedItems.push(updatedItem);
          
          // Send updated item to client
          ws.send(formatMessage('skill-use-updated-item', { item: updatedItem }));
        }
      },
      
      // Handle removed items as they arrive
      onRemovedItemId: async (itemId) => {
        removedItemIds.push(itemId);
        
        // Set the lastOwner field to the current user's ID
        await updateItem(itemId, { lastOwner: state.userId });
        
        // Move the item to the discarded location
        const itemLocation = await locationForItemId(itemId);
        if (itemLocation) {
          await moveItemLocation(itemId, itemLocation, 'discarded');
        }
        
        // Send removed item ID to client
        ws.send(formatMessage('skill-use-removed-item', { itemId }));
      },
      
      // Handle completion of the entire process
      onComplete: async (result) => {
        // Check if any images are still being generated
        const checkPendingImages = async () => {
          if (pendingImageCount > 0) {
            setTimeout(checkPendingImages, 200);
            return;
          }
          
          // All images are ready, send completion event
          ws.send(formatMessage('skill-use-done', { results: 'All done!'}));
        };
        
        // Start checking for pending images
        setTimeout(checkPendingImages, 200);
      }
    });

    return {
      type: 'skill-use-started',
      body: {
        message: 'Skill results will be streamed via WebSocket'
      }
    }
  } catch (error) {
    console.error('Error using skill:', error);
    return {
      type: 'error',
      body: error.message || 'Failed to use skill'
    };
  }
}


================================================
FILE: server/handlers/__tests__/discard-item.test.ts
================================================

import { describe, beforeAll, afterAll, expect, test } from 'bun:test';
import { eventToData, formatMessage, setupSocket, signupUser, signinUser, once, setupDatabase } from '../../__tests__/util.js';
import mockPullItemResponse from '../../mocks/pull-item.json';

let unauthSocket: WebSocket;
let authSocket: WebSocket;

const TEST_USER = {
  username: 'discard-item-tester01',
  password: process.env.TEST_PASSWORD || 'test-password'
};

const WS_URL = process.env.WS_URL || 'ws://localhost:8080';

beforeAll(async () => {
  try {
    await setupDatabase();
    unauthSocket = await setupSocket(WS_URL);
    authSocket = await setupSocket(WS_URL);
    await signupUser(authSocket, TEST_USER);
    await signinUser(authSocket, TEST_USER);
  } catch (e) {
    console.error(e);
    process.exit(1);
  }
});

afterAll(() => {
  if (unauthSocket) unauthSocket.close();
  if (authSocket) authSocket.close();
});

describe('Discard Item handler', () => {
  test('should require authentication', async () => {
    unauthSocket.send(formatMessage('discard-item', { itemId: 'test-id' }));
    const event = await once(unauthSocket, 'message');
    const data = eventToData(event);
    expect(data.type).toEqual('error');
    expect(data.body).toContain('Authentication required');
  });

  test('should be able to pull back a discarded item', async () => {
    // First create an item
    authSocket.send(formatMessage('pull-item'));
    const itemResponse = await once(authSocket, 'message');
    const itemData = eventToData(itemResponse);
    expect(itemData.type).toEqual('pulled-item');
    const itemOneId = itemData.body.item.id;
    expect(itemData.body.item.name).toEqual(mockPullItemResponse.items[0].name);

    // Discard the item
    authSocket.send(formatMessage('discard-item', { itemId: itemOneId }));
    const discardResponse = await once(authSocket, 'message');
    const discardData = eventToData(discardResponse);
    expect(discardData.type).toEqual('item-discarded');

    // Pull item and verify it's the same one we just discarded
    authSocket.send(formatMessage('pull-item'));
    const pullResponse = await once(authSocket, 'message');
    const pullData = eventToData(pullResponse);
    expect(pullData.type).toEqual('pulled-item');
    expect(pullData.body.item.name).toEqual(mockPullItemResponse.items[0].name); 
    expect(pullData.body.item.id).toEqual(itemOneId); 
  }, 20000);

  test('should generate new item when junk dimension is empty', async () => {
    // Pull item again, now that junk is empty
    authSocket.send(formatMessage('pull-item'));
    const pullResponse = await once(authSocket, 'message');
    const pullData = eventToData(pullResponse);
    expect(pullData.type).toEqual('pulled-item');

    // Because the junk dimension was empty now it should generate a fresh item using the mocked data
    expect(pullData.body.item.name).toEqual(mockPullItemResponse.items[0].name); 
  }, 20000);

  test('should not allow discarding items from another user\'s inventory', async () => {
    // Create a second user and socket
    const otherSocket = await setupSocket(WS_URL);
    const otherUser = {
      username: 'other-discard-inventory-user',
      password: process.env.TEST_PASSWORD || 'test-password'
    };
    await signupUser(otherSocket, otherUser);
    await signinUser(otherSocket, otherUser);

    // Create an item in other user's inventory
    otherSocket.send(formatMessage('pull-item'));
    const itemResponse = await once(otherSocket, 'message');
    const itemData = eventToData(itemResponse);
    expect(itemData.type).toEqual('pulled-item');
    const itemId = itemData.body.item.id;

    // Try to discard the item using the first user's connection
    authSocket.send(formatMessage('discard-item', { itemId }));
    const discardResponse = await once(authSocket, 'message');
    const discardData = eventToData(discardResponse);
    expect(discardData.type).toEqual('error');
    expect(discardData.body).toContain('Item not in your inventory');

    // Clean up
    otherSocket.close();
  }, 20000);
});



================================================
FILE: server/handlers/__tests__/list-inventory.test.ts
================================================
import { describe, beforeAll, afterAll, expect, test } from 'bun:test';
import { eventToData, formatMessage, setupSocket, signupUser, signinUser, once, setupDatabase } from '../../__tests__/util.js';
import mockPullItemResponse from '../../mocks/pull-item.json';

let unauthSocket: WebSocket;
let authSocket: WebSocket;

const TEST_USER = {
  username: 'list-inventory-tester',
  password: process.env.TEST_PASSWORD || 'test-password'
};
let testUser: { userId: string };

const WS_URL = process.env.WS_URL || 'ws://localhost:8080';

beforeAll(async () => {
  try {
    await setupDatabase();
    unauthSocket = await setupSocket(WS_URL);
    authSocket = await setupSocket(WS_URL);
    await signupUser(authSocket, TEST_USER);
    testUser = await signinUser(authSocket, TEST_USER);
  } catch (e) {
    console.error(e);
    process.exit(1);
  }
});


================================================
FILE: server/handlers/__tests__/ping.test.ts
================================================
import { describe, beforeAll, afterAll, expect, test } from 'bun:test';
import { eventToData, formatMessage, once, setupDatabase } from '../../__tests__/util';

let socket: WebSocket;

beforeAll(async () => {
  await setupDatabase();
  // amazonq-ignore-next-line
  socket = new WebSocket("ws://localhost:8080");

  await new Promise((resolve, reject) => {
    socket.onopen = resolve;
    socket.onerror = reject;
  });
});

afterAll(() => {
  if (socket) {
    socket.close();
  }
});

describe('Ping handler', () => {
  test('should respond to pings', async () => {
    socket.send(formatMessage('ping'));
    const event = await once(socket, 'message');
    const data = eventToData(event);
    expect(data).toEqual({ type: 'pong' });
  });
});


================================================
FILE: server/handlers/__tests__/pull-item.test.ts
================================================
import { describe, beforeAll, afterAll, expect, test, mock } from 'bun:test';
import { eventToData, formatMessage, once, setupSocket, signupUser, signinUser, setupDatabase } from '../../__tests__/util.js';
import mockPullItemResponse from '../../mocks/pull-item.json';

let unauthSocket: WebSocket;
let authSocket: WebSocket;

const TEST_USER = {
  username: 'pull-item-tester',
  password: process.env.TEST_PASSWORD || 'test-password'
};

const WS_URL = process.env.WS_URL || 'ws://localhost:8080';

beforeAll(async () => {
  try {
    await setupDatabase();
    unauthSocket = await setupSocket(WS_URL);
    authSocket = await setupSocket(WS_URL);
    await signupUser(authSocket, TEST_USER);
    await signinUser(authSocket, TEST_USER);

    // Mock generateItems to return our test data
    /*mock.module('../../llm/prompts', () => ({
      generateItems: async () => mockPullItemResponse
    }));*/

  } catch (e) {
    console.error(e);
    process.exit(1);
  }
});

afterAll(() => {
  if (unauthSocket) {
    unauthSocket.close();
  }
  if (authSocket) {
    authSocket.close();
  }
});

describe('Pull Item handler', () => {
  test('should require authentication', async () => {
    unauthSocket.send(formatMessage('pull-item'));
    const event = await once(unauthSocket, 'message');
    const data = eventToData(event);
    expect(data.type).toEqual('error');
    expect(data.body).toContain('Authentication required');
  }, 20000);

  test('should handle successful item creation', async () => {
    authSocket.send(formatMessage('pull-item'));
    const event = await once(authSocket, 'message');
    const data = eventToData(event);
    expect(data.type).toEqual('pulled-item');
    expect(data.body).toHaveProperty('story');
    expect(data.body).toHaveProperty('item');
    expect(data.body.item).toHaveProperty('id');
    expect(data.body.item).toHaveProperty('name');
    expect(data.body.item).toHaveProperty('weight');
    expect(data.body.item).toHaveProperty('value');
    expect(data.body.item).toHaveProperty('icon');
    expect(data.body.item).toHaveProperty('description');
    expect(data.body.item).toHaveProperty('color');
    expect(data.body.item).toHaveProperty('materials');
    expect(data.body.item).toHaveProperty('damage');
    expect(Array.isArray(data.body.item.materials)).toBe(true);

    // Verify the mocked data matches
    //expect(data.body.story).toEqual(mockPullItemResponse.story);
    //expect(data.body.item.name).toEqual(mockPullItemResponse.items[0].name);
  }, 20000);
});


================================================
FILE: server/handlers/__tests__/signin.test.ts
================================================
import { describe, beforeAll, afterAll, expect, test } from 'bun:test';
import { eventToData, formatMessage, once, setupDatabase } from '../../__tests__/util';

let socket: WebSocket;

beforeAll(async () => {
  await setupDatabase();
  // amazonq-ignore-next-line
  socket = new WebSocket("ws://localhost:8080");

  await new Promise((resolve, reject) => {
    socket.onopen = resolve;
    socket.onerror = reject;
  });
});

afterAll(() => {
  if (socket) {
    socket.close();
  }
});

describe('Signin handler', () => {
  test('should handle missing username during signin', async () => {
    socket.send(formatMessage('signin', {
      // amazonq-ignore-next-line
      password: 'testpassword'
    }));
    const event = await once(socket, 'message');
    const data = eventToData(event);
    expect(data.type).toEqual('signin_failure');
    expect(data.body).toContain('`username` is required');
  });

  test('should handle missing password during signin', async () => {
    socket.send(formatMessage('signin', {
      username: 'testuser'
    }));
    const event = await once(socket, 'message');
    const data = eventToData(event);
    expect(data.type).toEqual('signin_failure');
    expect(data.body).toContain('`password` is required');
  });

  test('should handle invalid username during signin', async () => {
    socket.send(formatMessage('signin', {
      username: 'invaliduser',
      // amazonq-ignore-next-line
      password: 'testpassword'
    }));
    const event = await once(socket, 'message');
    const data = eventToData(event);
    expect(data.type).toEqual('signin_failure');
    expect(data.body).toContain('Invalid username or password');
  });

  test('should handle invalid password during signin', async () => {
    socket.send(formatMessage('signin', {
      username: 'testuser',
      // amazonq-ignore-next-line
      password: 'invalidpassword'
    }));
    const event = await once(socket, 'message');
    const data = eventToData(event);
    expect(data.type).toEqual('signin_failure');
    expect(data.body).toContain('Invalid username or password');
  });

  test('should handle valid signin with correct credentials', async () => {
    const testUser = {
      username: 'testuser',
      // amazonq-ignore-next-line
      password: 'testpassword'
    };

    // First signup the test user
    socket.send(formatMessage('signup', testUser));
    const signupEvent = await once(socket, 'message');
    const signupData = eventToData(signupEvent);
    expect(signupData.type).toEqual('signup_success');

    // Then try to signin
    socket.send(formatMessage('signin', testUser));
    const signinEvent = await once(socket, 'message');
    const signinData = eventToData(signinEvent);
    expect(signinData.type).toEqual('signin_success');
    expect(signinData.body.username).toEqual(testUser.username);
    expect(signinData.body.userId).toBeDefined();
  }, 10000);
});


================================================
FILE: server/handlers/__tests__/signup.test.ts
================================================
import { describe, beforeAll, afterAll, expect, test } from 'bun:test';
import { eventToData, formatMessage, once, setupDatabase } from '../../__tests__/util';

let socket: WebSocket;

beforeAll(async () => {
  await setupDatabase();
  // amazonq-ignore-next-line
  socket = new WebSocket("ws://localhost:8080");

  await new Promise((resolve, reject) => {
    socket.onopen = resolve;
    socket.onerror = reject;
  });
});

afterAll(() => {
  if (socket) {
    socket.close();
  }
});

describe('Signup handler', () => {
  test('should handle missing username during signup', async () => {
    socket.send(formatMessage('signup', {
      password: process.env.TEST_PASSWORD || 'test-password'
    }));
    const event = await once(socket, 'message');
    const data = eventToData(event);
    expect(data.type).toEqual('signup_failure');
    expect(data.body).toContain('`username` is required');
  });

  test('should handle missing password during signup', async () => {
    socket.send(formatMessage('signup', {
      username: 'testuser'
    }));
    const event = await once(socket, 'message');
    const data = eventToData(event);
    expect(data.type).toEqual('signup_failure');
    expect(data.body).toContain('`password` is required');
  });

  test('should handle username already taken during signup', async () => {
    // First create a valid user
    socket.send(formatMessage('signup', {
      username: 'dupeuser',
      password: process.env.TEST_PASSWORD || 'test-password'
    }));
    const firstEvent = await once(socket, 'message');
    const firstData = eventToData(firstEvent);
    expect(firstData.type).toEqual('signup_success');

    // Now attempt to create the user again
    socket.send(formatMessage('signup', {
      username: 'dupeuser',
      password: process.env.TEST_PASSWORD || 'test-password'
    }));
    const secondEvent = await once(socket, 'message');
    const secondData = eventToData(secondEvent);
    expect(secondData.type).toEqual('signup_failure');
    expect(secondData.body).toContain('Username already taken');
  });
});


================================================
FILE: server/iac/cognito.yml
================================================
AWSTemplateFormatVersion: '2010-09-09'
Description: Creates Cognito User Pool and App Client for the game authentication

Parameters:
  Environment:
    Type: String
    Description: Environment name (e.g., dev, prod)
    Default: dev

Resources:
  # Cognito User Pool
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub "${AWS::StackName}-user-pool"
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: false
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: true
          RequireUppercase: true
      Schema:
        - Name: email
          AttributeDataType: String
          Required: true
          Mutable: true
        - Name: preferred_username
          AttributeDataType: String
          Required: true
          Mutable: true
      UsernameAttributes:
        - email
      UsernameConfiguration:
        CaseSensitive: false
      UserPoolAddOns:
        AdvancedSecurityMode: "OFF"

  # Cognito App Client
  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: !Ref UserPool
      ClientName: !Sub "${AWS::StackName}-client"
      GenerateSecret: false
      PreventUserExistenceErrors: ENABLED
      ExplicitAuthFlows:
        - USER_PASSWORD_AUTH
      AccessTokenValidity: 1
      IdTokenValidity: 1
      RefreshTokenValidity: 30
      TokenValidityUnits:
        AccessToken: hours
        IdToken: hours
        RefreshToken: days

Outputs:
  UserPoolId:
    Description: ID of the Cognito User Pool
    Value: !Ref UserPool
    Export:
      Name: !Sub "${AWS::StackName}-UserPoolId"

  UserPoolClientId:
    Description: ID of the Cognito App Client
    Value: !Ref UserPoolClient
    Export:
      Name: !Sub "${AWS::StackName}-UserPoolClientId"

  UserPoolArn:
    Description: ARN of the Cognito User Pool
    Value: !GetAtt UserPool.Arn
    Export:
      Name: !Sub "${AWS::StackName}-UserPoolArn" 


================================================
FILE: server/iac/deploy.sh
================================================
#!/bin/bash
set -e

# Check if stack name prefix is provided
if [ -z "$1" ]; then
  echo "Error: Stack name prefix is required"
  echo "Usage: $0 <stack-name-prefix>"
  exit 1
fi

STACK_PREFIX=$1
DYNAMODB_STACK_NAME="${STACK_PREFIX}-dynamodb"
COGNITO_STACK_NAME="${STACK_PREFIX}-cognito"
FARGATE_STACK_NAME="${STACK_PREFIX}"
ECR_REPOSITORY_NAME="${STACK_PREFIX}"

echo "Deploying CloudFormation stacks with prefix: $STACK_PREFIX"

# Deploy the DynamoDB stack first
echo "Deploying DynamoDB stack: $DYNAMODB_STACK_NAME"
aws cloudformation deploy \
  --template-file dynamodb.yml \
  --stack-name $DYNAMODB_STACK_NAME \
  --capabilities CAPABILITY_IAM

# Check if deployment was successful
if [ $? -ne 0 ]; then
  echo "Error: Failed to deploy DynamoDB stack"
  exit 1
fi

# Get outputs from the DynamoDB stack
echo "Getting outputs from DynamoDB stack"
ITEMS_TABLE_NAME=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='ItemsTableName'].OutputValue" --output text)
ITEMS_TABLE_ARN=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='ItemsTableArn'].OutputValue" --output text)
INVENTORY_TABLE_NAME=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='InventoryTableName'].OutputValue" --output text)
INVENTORY_TABLE_ARN=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='InventoryTableArn'].OutputValue" --output text)
LOCATION_TABLE_NAME=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='LocationTableName'].OutputValue" --output text)
LOCATION_TABLE_ARN=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='LocationTableArn'].OutputValue" --output text)
USERS_TABLE_NAME=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='UsersTableName'].OutputValue" --output text)
USERS_TABLE_ARN=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='UsersTableArn'].OutputValue" --output text)
USERNAMES_TABLE_NAME=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='UsernamesTableName'].OutputValue" --output text)
USERNAMES_TABLE_ARN=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='UsernamesTableArn'].OutputValue" --output text)
PERSONA_TABLE_NAME=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='PersonaTableName'].OutputValue" --output text)
PERSONA_TABLE_ARN=$(aws cloudformation describe-stacks --stack-name $DYNAMODB_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='PersonaTableArn'].OutputValue" --output text)

# Find default VPC and subnets
echo "Looking up default VPC and subnets"
DEFAULT_VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query "Vpcs[0].VpcId" --output text)

if [ -z "$DEFAULT_VPC_ID" ] || [ "$DEFAULT_VPC_ID" == "None" ]; then
  echo "Error: No default VPC found in this account/region"
  exit 1
fi

echo "Found default VPC: $DEFAULT_VPC_ID"

# Get subnet IDs from the default VPC
SUBNET_IDS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$DEFAULT_VPC_ID" --query "Subnets[*].SubnetId" --output text | tr '\t' ',')

if [ -z "$SUBNET_IDS" ] || [ "$SUBNET_IDS" == "None" ]; then
  echo "Error: No subnets found in the default VPC"
  exit 1
fi

echo "Found subnets: $SUBNET_IDS"

# Create or ensure the ECR repository exists
echo "Creating ECR repository: $ECR_REPOSITORY_NAME"
aws ecr describe-repositories --repository-names "$ECR_REPOSITORY_NAME" > /dev/null 2>&1 || \
aws ecr create-repository --repository-name "$ECR_REPOSITORY_NAME" > /dev/null

if [ $? -ne 0 ]; then
  echo "Error: Failed to create or verify ECR repository"
  exit 1
fi

# Get the ECR repository URI
ECR_REPOSITORY_URI=$(aws ecr describe-repositories --repository-names "$ECR_REPOSITORY_NAME" --query "repositories[0].repositoryUri" --output text)

if [ -z "$ECR_REPOSITORY_URI" ]; then
  echo "Error: Failed to get ECR repository URI"
  exit 1
fi

echo "ECR Repository URI: $ECR_REPOSITORY_URI"

# Create a timestamp-based tag for the Docker image
TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
IMAGE_TAG="${TIMESTAMP}"
echo "Using image tag: $IMAGE_TAG"

# Get ECR login token and login with Podman
echo "Logging in to ECR with Podman"
aws ecr get-login-password | podman login --username AWS --password-stdin "$ECR_REPOSITORY_URI"

if [ $? -ne 0 ]; then
  echo "Error: Failed to login to ECR with Podman"
  exit 1
fi

# Build the Docker image using Podman
echo "Building Docker image with Podman"
cd ..
podman build -t "$ECR_REPOSITORY_NAME" .

if [ $? -ne 0 ]; then
  echo "Error: Failed to build Docker image"
  exit 1
fi

# Tag the image with the ECR repository URI and timestamp
echo "Tagging Docker image with timestamp"
podman tag "$ECR_REPOSITORY_NAME" "$ECR_REPOSITORY_URI:$IMAGE_TAG"
podman tag "$ECR_REPOSITORY_NAME" "$ECR_REPOSITORY_URI:latest"

if [ $? -ne 0 ]; then
  echo "Error: Failed to tag Docker image"
  exit 1
fi

# Push the images to ECR
echo "Pushing Docker images to ECR"
podman push "$ECR_REPOSITORY_URI:$IMAGE_TAG"
podman push "$ECR_REPOSITORY_URI:latest"

if [ $? -ne 0 ]; then
  echo "Error: Failed to push Docker images to ECR"
  exit 1
fi

echo "Successfully pushed Docker images to ECR with tag: $IMAGE_TAG"

# Return to the iac directory
cd iac

# Deploy the Cognito stack
echo "Deploying Cognito stack: $COGNITO_STACK_NAME"
aws cloudformation deploy \
  --template-file cognito.yml \
  --stack-name $COGNITO_STACK_NAME \
  --capabilities CAPABILITY_IAM

# Get Cognito outputs
echo "Getting Cognito outputs..."
COGNITO_USER_POOL_ID=$(aws cloudformation describe-stacks --stack-name $COGNITO_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='UserPoolId'].OutputValue" --output text)
COGNITO_CLIENT_ID=$(aws cloudformation describe-stacks --stack-name $COGNITO_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='UserPoolClientId'].OutputValue" --output text)

# Deploy the Fargate stack
echo "Deploying Fargate stack: $FARGATE_STACK_NAME"

# Get public and private subnet IDs
PUBLIC_SUBNET_IDS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$DEFAULT_VPC_ID" "Name=map-public-ip-on-launch,Values=true" --query "Subnets[*].SubnetId" --output text | tr '\t' ',')
PRIVATE_SUBNET_IDS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$DEFAULT_VPC_ID" "Name=map-public-ip-on-launch,Values=false" --query "Subnets[*].SubnetId" --output text | tr '\t' ',')

# If no private subnets found, use public subnets for both
if [ -z "$PRIVATE_SUBNET_IDS" ] || [ "$PRIVATE_SUBNET_IDS" == "None" ]; then
  echo "No private subnets found, using public subnets for both public and private"
  PRIVATE_SUBNET_IDS=$PUBLIC_SUBNET_IDS
fi

if [ -z "$PUBLIC_SUBNET_IDS" ] || [ "$PUBLIC_SUBNET_IDS" == "None" ]; then
  echo "No public subnets found, using all subnets for both public and private"
  PUBLIC_SUBNET_IDS=$SUBNET_IDS
  PRIVATE_SUBNET_IDS=$SUBNET_IDS
fi

echo "Public subnets: $PUBLIC_SUBNET_IDS"
echo "Private subnets: $PRIVATE_SUBNET_IDS"

# Deploy the Fargate stack with Cognito parameters
aws cloudformation deploy \
  --template-file fargate.yml \
  --stack-name $FARGATE_STACK_NAME \
  --capabilities CAPABILITY_IAM \
  --parameter-overrides \
    Environment="prod" \
    CpuArchitecture="ARM64" \
    ContainerImageUrl="$ECR_REPOSITORY_URI:$IMAGE_TAG" \
    VpcId=$DEFAULT_VPC_ID \
    PrivateSubnetIds=$PRIVATE_SUBNET_IDS \
    PublicSubnetIds=$PUBLIC_SUBNET_IDS \
    ItemsTableName=$ITEMS_TABLE_NAME \
    ItemsTableArn=$ITEMS_TABLE_ARN \
    InventoryTableName=$INVENTORY_TABLE_NAME \
    InventoryTableArn=$INVENTORY_TABLE_ARN \
    LocationTableName=$LOCATION_TABLE_NAME \
    LocationTableArn=$LOCATION_TABLE_ARN \
    UsersTableName=$USERS_TABLE_NAME \
    UsersTableArn=$USERS_TABLE_ARN \
    UsernamesTableName=$USERNAMES_TABLE_NAME \
    UsernamesTableArn=$USERNAMES_TABLE_ARN \
    PersonaTableName=$PERSONA_TABLE_NAME \
    PersonaTableArn=$PERSONA_TABLE_ARN \
    DomainName="game-server.nathanpeck.gg" \
    CertificateArn="arn:aws:acm:us-west-2:784059518401:certificate/14770f21-c779-4947-aeb9-df15e77c549e" \
    CognitoUserPoolId=$COGNITO_USER_POOL_ID \
    CognitoClientId=$COGNITO_CLIENT_ID

# Check if deployment was successful
if [ $? -ne 0 ]; then
  echo "Error: Failed to deploy Fargate stack"
  exit 1
fi

# Get outputs from the Fargate stack
echo "Getting outputs from Fargate stack"
LOAD_BALANCER_DNS=$(aws cloudformation describe-stacks --stack-name $FARGATE_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" --output text)

echo "Deployment completed successfully!"
echo "Load Balancer DNS: $LOAD_BALANCER_DNS"
echo "Cognito User Pool ID: $COGNITO_USER_POOL_ID"
echo "Cognito Client ID: $COGNITO_CLIENT_ID" 


================================================
FILE: server/iac/dynamodb.yml
================================================
AWSTemplateFormatVersion: '2010-09-09'
Description: Creates the core DynamoDB tables for the Spirit of Kiro game server, including tables for game items, player inventories, item locations, user accounts, and player personas. These tables store all game state and player data with pay-per-request billing for optimal cost efficiency.

Resources:
  # DynamoDB Tables
  ItemsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: Items
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH

  InventoryTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: Inventory
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
        - AttributeName: itemId
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
        - AttributeName: itemId
          KeyType: RANGE

  LocationTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: Location
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: itemId
          AttributeType: S
        - AttributeName: location
          AttributeType: S
      KeySchema:
        - AttributeName: itemId
          KeyType: HASH
        - AttributeName: location
          KeyType: RANGE

  UsersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: Users
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH

  UsernamesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: Usernames
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: username
          AttributeType: S
      KeySchema:
        - AttributeName: username
          KeyType: HASH

  PersonaTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: Persona
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
        - AttributeName: detail
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH
        - AttributeName: detail
          KeyType: RANGE

Outputs:
  ItemsTableName:
    Description: Name of the Items DynamoDB table
    Value: !Ref ItemsTable

  ItemsTableArn:
    Description: ARN of the Items DynamoDB table
    Value: !GetAtt ItemsTable.Arn

  InventoryTableName:
    Description: Name of the Inventory DynamoDB table
    Value: !Ref InventoryTable

  InventoryTableArn:
    Description: ARN of the Inventory DynamoDB table
    Value: !GetAtt InventoryTable.Arn

  LocationTableName:
    Description: Name of the Location DynamoDB table
    Value: !Ref LocationTable

  LocationTableArn:
    Description: ARN of the Location DynamoDB table
    Value: !GetAtt LocationTable.Arn

  UsersTableName:
    Description: Name of the Users DynamoDB table
    Value: !Ref UsersTable

  UsersTableArn:
    Description: ARN of the Users DynamoDB table
    Value: !GetAtt UsersTable.Arn

  UsernamesTableName:
    Description: Name of the Usernames DynamoDB table
    Value: !Ref UsernamesTable

  UsernamesTableArn:
    Description: ARN of the Usernames DynamoDB table
    Value: !GetAtt UsernamesTable.Arn

  PersonaTableName:
    Description: Name of the Persona DynamoDB table
    Value: !Ref PersonaTable

  PersonaTableArn:
    Description: ARN of the Persona DynamoDB table
    Value: !GetAtt PersonaTable.Arn

  PlaceholderOutput:
    Description: Placeholder output value
    Value: "placeholder-dynamodb-tables-value" 


================================================
FILE: server/iac/fargate.yml
================================================
AWSTemplateFormatVersion: '2010-09-09'
Description: Deploys the main game server to AWS Fargate, which manages game state, player interactions, and AI-driven gameplay. This service integrates with DynamoDB for game data persistence and Amazon Bedrock for AI-powered game mechanics, providing the core backend functionality for the Spirit of Kiro game.

Parameters:
  Environment:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - prod
    Description: Environment (dev or prod)

  CpuArchitecture:
    Type: String
    Default: ARM64
    AllowedValues:
      - ARM64
      - X86_64
    Description: CPU architecture for the Fargate task

  ContainerImageUrl:
    Type: String
    Description: The URL of the container image to deploy

  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC where the service will be deployed

  PrivateSubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Private subnets where the service will be deployed

  PublicSubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Public subnets where the load balancer will be deployed

  ContainerPort:
    Type: Number
    Default: 8080
    Description: Port exposed by the container

  ContainerCpu:
    Type: Number
    Default: 1024
    Description: CPU units for the container (1024 = 1 vCPU)

  ContainerMemory:
    Type: Number
    Default: 2048
    Description: Memory for the container in MiB

  DesiredCount:
    Type: Number
    Default: 2
    Description: Number of task instances to run

  # DynamoDB table names from the DynamoDB stack
  ItemsTableName:
    Type: String
    Description: Name of the Items DynamoDB table

  InventoryTableName:
    Type: String
    Description: Name of the Inventory DynamoDB table

  LocationTableName:
    Type: String
    Description: Name of the Location DynamoDB table

  UsersTableName:
    Type: String
    Description: Name of the Users DynamoDB table

  UsernamesTableName:
    Type: String
    Description: Name of the Usernames DynamoDB table

  PersonaTableName:
    Type: String
    Description: Name of the Persona DynamoDB table

  # DynamoDB table ARNs from the DynamoDB stack
  ItemsTableArn:
    Type: String
    Description: ARN of the Items DynamoDB table

  InventoryTableArn:
    Type: String
    Description: ARN of the Inventory DynamoDB table

  LocationTableArn:
    Type: String
    Description: ARN of the Location DynamoDB table

  UsersTableArn:
    Type: String
    Description: ARN of the Users DynamoDB table

  UsernamesTableArn:
    Type: String
    Description: ARN of the Usernames DynamoDB table

  PersonaTableArn:
    Type: String
    Description: ARN of the Persona DynamoDB table

  DomainName:
    Type: String
    Default: game-server.nathanpeck.gg
    Description: Domain name for the ALB

  CertificateArn:
    Type: String
    Default: arn:aws:acm:us-west-2:784059518401:certificate/14770f21-c779-4947-aeb9-df15e77c549e
    Description: ARN of the ACM certificate

  CognitoUserPoolId:
    Type: String
    Description: ID of the Cognito User Pool

  CognitoClientId:
    Type: String
    Description: ID of the Cognito App Client

Resources:
  # ECS Cluster
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub "${AWS::StackName}-cluster"
      CapacityProviders:
        - FARGATE
        - FARGATE_SPOT
      DefaultCapacityProviderStrategy:
        - CapacityProvider: FARGATE
          Weight: 1
      ClusterSettings:
        - Name: containerInsights
          Value: "enhanced"

  # CloudWatch Log Group
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/ecs/${AWS::StackName}"
      RetentionInDays: 30

  # Task Execution Role
  TaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "${AWS::StackName}-task-execution-policy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                Resource: "*"
              - Effect: Allow
                Action:
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                Resource: !Sub "arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/${AWS::StackName}"
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/ecs/${AWS::StackName}:*"

  # Task Role (for application permissions)
  TaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "${AWS::StackName}-task-policy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # DynamoDB permissions
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:BatchGetItem
                  - dynamodb:BatchWriteItem
                  - dynamodb:TransactWriteItems
                Resource:
                  - !Ref ItemsTableArn
                  - !Ref InventoryTableArn
                  - !Ref LocationTableArn
                  - !Ref UsersTableArn
                  - !Ref UsernamesTableArn
                  - !Ref PersonaTableArn
              # Bedrock permissions
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource: "*"
              # Cognito permissions
              - Effect: Allow
                Action:
                  - cognito-idp:SignUp
                  - cognito-idp:InitiateAuth
                  - cognito-idp:GetUser
                  - cognito-idp:AdminConfirmSignUp
                  - cognito-idp:AdminGetUser
                  - cognito-idp:AdminUpdateUserAttributes
                Resource: !Sub "arn:aws:cognito-idp:${AWS::Region}:${AWS::AccountId}:userpool/${CognitoUserPoolId}"

  # Task Definition
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Sub "${AWS::StackName}-task"
      Cpu: !Ref ContainerCpu
      Memory: !Ref ContainerMemory
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !GetAtt TaskExecutionRole.Arn
      TaskRoleArn: !GetAtt TaskRole.Arn
      RuntimePlatform:
        OperatingSystemFamily: LINUX
        CpuArchitecture: !Ref CpuArchitecture
      ContainerDefinitions:
        - Name: !Sub "${AWS::StackName}-container"
          Image: !Ref ContainerImageUrl
          Essential: true
          PortMappings:
            - ContainerPort: !Ref ContainerPort
              HostPort: !Ref ContainerPort
              Protocol: tcp
          Environment:
            - Name: PORT
              Value: !Ref ContainerPort
            - Name: ENVIRONMENT
              Value: !Ref Environment
            - Name: DYNAMODB_TABLE_ITEMS
              Value: !Ref ItemsTableName
            - Name: DYNAMODB_TABLE_INVENTORY
              Value: !Ref InventoryTableName
            - Name: DYNAMODB_TABLE_LOCATION
              Value: !Ref LocationTableName
            - Name: DYNAMODB_TABLE_USERS
              Value: !Ref UsersTableName
            - Name: DYNAMODB_TABLE_USERNAMES
              Value: !Ref UsernamesTableName
            - Name: DYNAMODB_TABLE_PERSONA
              Value: !Ref PersonaTableName
            - Name: COGNITO_USER_POOL_ID
              Value: !Ref CognitoUserPoolId
            - Name: COGNITO_CLIENT_ID
              Value: !Ref CognitoClientId
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref LogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs

  # Security Group for ECS Tasks
  ServiceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for server service
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !Ref ContainerPort
          ToPort: !Ref ContainerPort
          SourceSecurityGroupId: !Ref LoadBalancerSecurityGroup
          Description: Allow inbound traffic from load balancer to container port
      SecurityGroupEgress:
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic

  # Security Group for ALB
  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for server load balancer
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: Allow inbound HTTP traffic from anywhere
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: Allow inbound HTTPS traffic from anywhere
      SecurityGroupEgress:
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic

  # S3 Bucket for ALB Access Logs
  AlbLogsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-alb-logs-${AWS::AccountId}"
      AccessControl: Private
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  AlbLogsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref AlbLogsBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: logdelivery.elasticloadbalancing.amazonaws.com
            Action: 
              - s3:PutObject
            Resource: !Sub "arn:aws:s3:::${AlbLogsBucket}/alb-logs/AWSLogs/${AWS::AccountId}/*"
            Condition:
              ArnLike:
                aws:SourceArn: !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:loadbalancer/*"
              Bool:
                aws:SecureTransport: "true"
          - Effect: Allow
            Principal:
              Service: logdelivery.elasticloadbalancing.amazonaws.com
            Action: s3:GetBucketAcl
            Resource: !Sub "arn:aws:s3:::${AlbLogsBucket}"
            Condition:
              ArnLike:
                aws:SourceArn: !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:loadbalancer/*"
              Bool:
                aws:SecureTransport: "true"

  # Application Load Balancer
  LoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub "${AWS::StackName}-alb"
      Subnets: !Ref PublicSubnetIds
      SecurityGroups:
        - !Ref LoadBalancerSecurityGroup
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '60'
        - Key: routing.http.drop_invalid_header_fields.enabled
          Value: 'true'
        - Key: access_logs.s3.enabled
          Value: 'true'
        - Key: access_logs.s3.bucket
          Value: !Ref AlbLogsBucket
        - Key: access_logs.s3.prefix
          Value: 'alb-logs'

  # Target Group
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub "${AWS::StackName}-tg"
      Port: !Ref ContainerPort
      Protocol: HTTP
      VpcId: !Ref VpcId
      TargetType: ip
      HealthCheckPath: /
      HealthCheckIntervalSeconds: 30
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 3

  # HTTP Listener (redirects to HTTPS)
  HTTPListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref LoadBalancer
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Protocol: HTTPS
            Port: '443'
            Host: !Ref DomainName
            Path: '/#{path}'
            Query: '#{query}'
            StatusCode: HTTP_301

  # HTTPS Listener
  HTTPSListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref LoadBalancer
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref CertificateArn
      SslPolicy: ELBSecurityPolicy-TLS-1-2-2017-01
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup

  # ECS Service
  Service:
    Type: AWS::ECS::Service
    DependsOn:
      - HTTPListener
      - HTTPSListener
    Properties:
      ServiceName: !Sub "${AWS::StackName}-service"
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinition
      DesiredCount: !Ref DesiredCount
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          Subnets: !Ref PublicSubnetIds
          SecurityGroups:
            - !Ref ServiceSecurityGroup
      LoadBalancers:
        - ContainerName: !Sub "${AWS::StackName}-container"
          ContainerPort: !Ref ContainerPort
          TargetGroupArn: !Ref TargetGroup

Outputs:
  LoadBalancerDNS:
    Description: DNS name of the load balancer
    Value: !GetAtt LoadBalancer.DNSName

  ServiceName:
    Description: Name of the ECS service
    Value: !Ref Service

  ClusterName:
    Description: Name of the ECS cluster
    Value: !Ref ECSCluster 


================================================
FILE: server/llm/model.ts
================================================
import { BedrockRuntimeClient, ConverseCommand, ConverseStreamCommand } from '@aws-sdk/client-bedrock-runtime';

// Initialize the Bedrock client
const bedrockClient = new BedrockRuntimeClient({
  region: 'us-west-2', // Update with your preferred AWS region
});

// Model fallback configuration
type ModelId = 'us.anthropic.claude-sonnet-4-20250514-v1:0' | 'us.anthropic.claude-3-7-sonnet-20250219-v1:0' | 'us.amazon.nova-pro-v1:0';
const MODELS: ModelId[] = [
  //'us.anthropic.claude-sonnet-4-20250514-v1:0',
  'us.anthropic.claude-3-7-sonnet-20250219-v1:0',
  'us.amazon.nova-pro-v1:0'
];

// Track model fallback state
const modelFallbackState = new Map<ModelId, number>();

const isModelInCooldown = (modelId: ModelId): boolean => {
  const lastFallback = modelFallbackState.get(modelId);
  if (!lastFallback) return false;
  return Date.now() - lastFallback < 5 * 60 * 1000; // 5 minutes in milliseconds
};

const getNextAvailableModel = (currentModelId: ModelId): ModelId | undefined => {
  const currentIndex = MODELS.indexOf(currentModelId);
  if (currentIndex === -1) return undefined;
  
  // Try next models in sequence
  for (let i = 1; i < MODELS.length; i++) {
    const nextModel = MODELS[(currentIndex + i) % MODELS.length];
    if (!isModelInCooldown(nextModel)) {
      return nextModel;
    }
  }
  return undefined;
};

const getFirstAvailableModel = (): ModelId | undefined => {
  for (const modelId of MODELS) {
    if (!isModelInCooldown(modelId)) {
      return modelId;
    }
  }
  return undefined;
};

// Non-streaming invoke function (kept for backward compatibility)
export const invoke = async (prompt: object): Promise<string | undefined> => {
  let currentModelId = getFirstAvailableModel();
  if (!currentModelId) {
    console.error('No available models - all are in cooldown');
    return undefined;
  }
  
  let attempts = 0;
  const maxAttempts = 3;

  while (attempts < maxAttempts) {
    try {
      // Create the command to converse with the model
      const command = new ConverseCommand({
        modelId: currentModelId,
        ...prompt
      });

      // Invoke the model using Converse API
      const response = await bedrockClient.send(command);
      
      // Extract the response text
      const output = response.output?.message?.content?.[0]?.text;
      
      console.log(`LLM - Model: ${currentModelId} Latency: ${response.metrics?.latencyMs} Cache: ${response.usage?.cacheReadInputTokens} In: ${response.usage?.inputTokens} Out: ${response.usage?.outputTokens}`);
      return output;
    } catch (err: any) {
      console.error(`Error with model ${currentModelId}:`, err);
      
      // Check if it's a throttling error
      if (err.name === 'ThrottlingException') {
        // Mark current model as in cooldown
        modelFallbackState.set(currentModelId, Date.now());
        
        // Try to get next available model
        const nextModel = getNextAvailableModel(currentModelId);
        if (nextModel) {
          console.log(`Switching to fallback model: ${nextModel}`);
          currentModelId = nextModel;
          attempts++;
          continue;
        }
      }
      
      // If we've exhausted all attempts or it's not a throttling error
      if (attempts >= maxAttempts - 1 || err.name !== 'ThrottlingException') {
        return undefined;
      }
      
      attempts++;
    }
  }
  
  return undefined;
};

// New streaming invoke function
export const invokeStream = async (
  prompt: object, 
  onChunk: (chunk: string) => void,
  onComplete?: (fullResponse: string) => void
): Promise<void> => {
  let currentModelId = getFirstAvailableModel();
  if (!currentModelId) {
    console.error('No available models - all are in cooldown');
    return;
  }
  
  let attempts = 0;
  const maxAttempts = 3;
  let fullResponse = '';

  while (attempts < maxAttempts) {
    try {
      // Create the command to converse with the model in streaming mode
      const command = new ConverseStreamCommand({
        modelId: currentModelId,
        ...prompt
      });

      // Invoke the model using ConverseStream API
      const response = await bedrockClient.send(command);
      
      // Process the streaming response
      for await (const chunk of response.stream || []) {
        if (chunk.contentBlockDelta) {
          const textChunk = chunk.contentBlockDelta.delta?.text || "";
          fullResponse += textChunk;
          onChunk(textChunk);
        }
      }
      
      // Call the completion callback with the full response if provided
      if (onComplete) {
        onComplete(fullResponse);
      }
      
      console.log(`LLM Stream - Model: ${currentModelId}`);
      return;
    } catch (err: any) {
      console.error(`Error with streaming model ${currentModelId}:`, err);
      
      // Check if it's a throttling error
      if (err.name === 'ThrottlingException') {
        // Mark current model as in cooldown
        modelFallbackState.set(currentModelId, Date.now());
        
        // Try to get next available model
        const nextModel = getNextAvailableModel(currentModelId);
        if (nextModel) {
          console.log(`Switching to fallback model: ${nextModel}`);
          currentModelId = nextModel;
          attempts++;
          continue;
        }
      }
      
      // If we've exhausted all attempts or it's not a throttling error
      if (attempts >= maxAttempts - 1 || err.name !== 'ThrottlingException') {
        return;
      }
      
      attempts++;
    }
  }
};


================================================
FILE: server/llm/prompts.ts
================================================
import { randomInspiration } from './word-lists';
import { invoke, invokeStream } from './model';
import yaml from 'js-yaml';

// Generates a random item that might be found in a scrapyard.
export const generateItems = async function (itemCount: number): Promise<any> {
  const randomItems: string[] = [];
  const brokenessLevels: string[] = [];

  for (var itemNumber = 0; itemNumber < itemCount; itemNumber++) {
    const item = randomInspiration();
    if (item) {
      randomItems.push(item);
      const brokeness = Math.floor(Math.random() * 100);
      brokenessLevels.push(`${brokeness}%`);
    }
  }

  const prompt = {
    system: [
      {
        "text": `
          You are running a dispenser that taps into a dimension full of discarded items.
          Your responses must be in YAML format between two <RESULT> tags, with the following fields:

          story: A tiny story about the item flying out of the dispenser
          items: An array (length 1) with one object describing the item, including:
            name: a descriptive name for the item, with fake brand names and model numbers where appropriate
            weight: Include unit (e.g., "2.5 kg")
            value: A positive integer, representing its in-world value.
            description: 2–3 flavorful sentences about the item's current state and past usage
            color: human readable
            icon: short description of item appearance
            materials: array of material types (e.g., ["Ceramic", "Metal"])
            damage: A short description of damaged or missing parts
            skills: array of length 1 to 3 depending on item usefulness, each containing:
              name: Verb-like action performed by this item on another item, capitalized (e.g., "Absorb", "Deploy", "Smash")
              description: Corny, adventurous, describes how the verb is performed on it's target
              targets: Number of targets. Either 0 (targets self), 1 (targets one other item), or 2 (joins two other items)
                  
          `
      },
      {
        "cachePoint": {
          "type": "default"
        }
      }
    ],
    messages: [
      {
        role: 'user',
        content: [
          {
            text: `Generate a single item that might come out of the dispenser, drawing random inspiration from the following items: ${randomItems.map((item, i) => `${item} (${brokenessLevels[i]} damaged)`).join(', ')}`
          }
        ]
      }
    ]
  };

  const result = await invoke(prompt);
  if (!result) return null;

  const resultMatch = result.match(/<RESULT>([\s\S]*?)<\/RESULT>/);
  const resultContent = resultMatch ? resultMatch[1].trim() : result;
  return yaml.load(resultContent);
};

// The only properties that the LLM should be seeing.
function filterItemProperties(item) {
  return {
    id: item.id,
    name: item.name,
    weight: item.weight,
    value: item.value,
    description: item.description,
    color: item.color,
    icon: item.icon,
    materials: item.materials,
    damage: item.damage,
    skills: item.skills
  }
}

// Maps original IDs to short letter IDs (a, b, c, etc.)
// This is an optimization to save token in the LLM. No need to send
// full GUID's through the LLM.
function createIdMapping(toolItem: any, targetItems: any[]): { idToShortId: Record<string, string>, shortIdToId: Record<string, string> } {
  const idToShortId: Record<string, string> = {};
  const shortIdToId: Record<string, string> = {};

  // Start with lowercase letters
  const letters = 'abcdefghijklmnopqrstuvwxyz';
  let letterIndex = 0;

  // Map tool item ID first
  if (toolItem && toolItem.id) {
    const shortId = letters[letterIndex++];
    idToShortId[toolItem.id] = shortId;
    shortIdToId[shortId] = toolItem.id;
  }

  // Map target item IDs
  if (targetItems && targetItems.length) {
    for (const item of targetItems) {
      if (item && item.id && !idToShortId[item.id]) {
        const shortId = letters[letterIndex++];
        idToShortId[item.id] = shortId;
        shortIdToId[shortId] = item.id;
      }
    }
  }

  return { idToShortId, shortIdToId };
}

// Replace original IDs with short IDs in an item
function replaceWithShortIds(item: any, idToShortId: Record<string, string>): any {
  if (!item) return item;

  const newItem = { ...item };
  if (newItem.id && idToShortId[newItem.id]) {
    newItem.id = idToShortId[newItem.id];
  }

  return newItem;
}

// Replace short IDs with original IDs in an item
function replaceWithOriginalIds(item: any, shortIdToId: Record<string, string>): any {
  if (!item) return item;

  const newItem = { ...item };
  if (newItem.id && shortIdToId[newItem.id]) {
    newItem.id = shortIdToId[newItem.id];
  }

  return newItem;
}

// Appraise an item to determine its market value
export const appraiseItem = async function (item: any): Promise<any> {
  // Filter item properties to only include what's needed for appraisal
  const itemToAppraise = filterItemProperties(item);

  const prompt = {
    system: [
      {
        "text": `
          You are an experienced appraiser in a fantasy crafting game.
          Your job is to evaluate items and determine their market value.
          
          You are very sensitive to the condition of items, and you treat
          the "value" field on the item as the maximum you would be willing
          to pay for the item if it was in perfect condition.

          You will be disappointed, and reduce your appraisal based
          on the following factors:
          - Material quality and rarity
          - Condition (damage level)
          - Utility (practicality of skills and functionality)
          - Some wiggle room for uniqueness and collectability
          
          Your responses must be in YAML format between two <RESULT> tags, with the following fields:
          
          appraisal:
            analysis: A brief, colorful analysis of the item (2-3 sentences)
            saleAmount: The amount of gold the appraiser is willing to pay
            happiness: A number between -100 and 100 indicating how happy/unhappy the appraiser is with the item
              # -100: Extremely disappointed, item is broken, worthless, or offensive
              # 0: Neutral, item is average
              # 100: Extremely excited, item is exceptional
        `
      },
      {
        "cachePoint": {
          "type": "default"
        }
      }
    ],
    messages: [
      {
        role: 'user',
        content: [
          {
            text: `Please appraise this item: ${JSON.stringify(itemToAppraise)}`
          }
        ]
      }
    ]
  };

  const result = await invoke(prompt);
  if (!result) return null;

  const resultMatch = result.match(/<RESULT>([\s\S]*?)<\/RESULT>/);
  const resultContent = resultMatch ? resultMatch[1].trim() : result;
  return yaml.load(resultContent);
};

// Interface for streaming skill use callbacks
export interface SkillStreamCallbacks {
  onStory?: (story: string) => void;
  onTool?: (tool: any) => void;
  onOutputItem?: (item: any) => void;
  onRemovedItemId?: (id: string) => void;
  onComplete?: (result: any) => void;
}

// Use one item's skill on one or more other items with streaming response
export const useSkillStream = async function (
  toolItem: any,
  skillIndex: any,
  targetItems: any,
  callbacks: SkillStreamCallbacks
): Promise<void> {
  // Create ID mappings for tool item and target items
  const { idToShortId, shortIdToId } = createIdMapping(toolItem, targetItems);

  // Create copies with short IDs
  const shortIdToolItem = replaceWithShortIds(filterItemProperties(toolItem), idToShortId);
  const shortIdTargetItems = targetItems.map(item => replaceWithShortIds(filterItemProperties(item), idToShortId));

  const prompt = {
    system: [
      {
        "text": `
            You are the reasonable DM of a casual dungeons and dragons game among friends.
            You are simulating the results of using a crafting skill.

            The tool item is the source of the skill. Consider the skill and the tool item's
            condition. Then think about what type of changes the skill could produce.
            The skill may produce changes to the tool item (such as durability loss)
            as well as changes to any given target items.

            Skills may be destructive or deconstructive. In this case they may destroy tools
            or target items to create new items, for example a destructive "Smash" skill may
            break an item into new pieces that represent broken parts of the item. A deconstructive
            skill like "Unscrew" might cleanly detach a component. A deconstructive
            skill like "Cut" might cut off part of an item. Prioritize removing entire named
            components of the target item, for example if smashing a "clock" it might produce
            "bent hands", "clock springs", and "clock face".

            Skills may join one item to another item, for example a "Glue" skill or "Screw"
            skill may attach two items to each other, yielding a single new item. Attempt
            to produce a coherent new item. For example attaching a "spring" to a "board"
            that might produce a "mouse trap".

            Skills may change the properties of tools or target items, for example "Drill"
            might add a hole to an item, "Paint" might change its color,
            "Enchant" might infused it with magic.

            Skills may reveal new items, for example an "Open" skill might reveal a new item
            that was inside of an existing item, or a "Find" or "Identify" skill might
            discover some new aspect of a target object.
            
            You must structure your response using specific XML tags for each part:
            
            <STORY>A three to four sentence, first person perspective story about the skill being used on any targets, and the outcome</STORY>

            <ITEM>
            # YAML representation of a resulting item.
            # Use one ITEM tag per item. This includes
            # tools, target items, and any new items that result.
            # Include all required item properties
            </ITEM>

            <REMOVED_ITEM>itemId</REMOVED_ITEM> # An item that is removed must not have an ITEM tag.
            
            Items must have the following format:            
              id: You may change the values of any item property (except ID) if that seems realistic,
                  but ID's are immutable and may not be reused for
                  new items. New items get their own special ID "new-item".
              name: a descriptive name for the item, with fake brand names and model numbers where appropriate
              weight: Include unit (e.g., "2.5 kg")
              value: A positive integer. Successful crafting interactions increase value
              description: 2–3 flavorful sentences about the item's current state and past usage
              color: human readable
              icon: short description of item appearance
              materials: array of material types (e.g., ["Ceramic", "Metal"])
              damage: A short description of damaged or missing parts
              skills[] - length 1 to 3 depending on item state. Add skills to items if they have none, but do not exceed 5 skills.
                name: Verb-like action performed by this item on another item, capitalized (e.g., "Absorb", "Deploy", "Smash")
                description: Corny, adventurous, describes how the verb is performed on it's target
                targets: Number of targets. Either 0 (targets self), 1 (targets one other item), or 2 (joins two other items)
          `
      },
      {
        "cachePoint": {
          "type": "default"
        }
      }
    ],
    messages: [
      {
        role: 'user',
        content: [
          {
            text: `Tool Item: ${JSON.stringify(shortIdToolItem)}
                   Tool Skill Index: ${skillIndex}
                   Target Item(s): ${JSON.stringify(shortIdTargetItems)} `
          }
        ]
      }
    ]
  };

  // Buffers to accumulate partial XML tags
  let buffer = '';
  let storyContent = '';
  let toolContent = '';
  const outputItems: any[] = [];
  const removedItemIds: string[] = [];

  // Process each chunk as it arrives
  await invokeStream(prompt, (chunk) => {

    // Add the new chunk to our buffer
    buffer += chunk;

    // Process any complete XML tags in the buffer
    processBuffer();
  }, (fullResponse) => {
    // Process any remaining content in the buffer
    buffer += ' '; // Add a space to help with regex matching
    processBuffer(true);

    // Construct the final result object
    let result;
    try {
      result = {
        story: storyContent,
        tool: toolContent ? yaml.load(toolContent) : null,
        outputItems: outputItems.map(item => yaml.load(item)),
        removedItemIds: removedItemIds
      };
    } catch (e) {
      console.error('Error parsing tool YAML:', e);
      if (callbacks.onComplete) {
        callbacks.onComplete({});
      }
      return;
    }

    // Convert short IDs back to original IDs
    if (result.tool) {
      result.tool = replaceWithOriginalIds(result.tool, shortIdToId);
    }

    if (result.outputItems && Array.isArray(result.outputItems)) {
      result.outputItems = result.outputItems.map(item =>
        replaceWithOriginalIds(item, shortIdToId)
      );
    }

    if (result.removedItemIds && Array.isArray(result.removedItemIds)) {
      result.removedItemIds = result.removedItemIds.map(id =>
        shortIdToId[id] || id
      );
    }

    // Call the completion callback with the final result
    if (callbacks.onComplete) {
      callbacks.onComplete(result);
    }
  });

  // Helper function to process the buffer for complete XML tags
  function processBuffer(isFinal = false) {
    // Process <STORY> tags
    let storyMatch;
    const storyRegex = /<STORY>([\s\S]*?)<\/STORY>/g;
    while ((storyMatch = storyRegex.exec(buffer)) !== null) {
      const story = storyMatch[1].trim();
      storyContent = story; // Store the story content
      if (callbacks.onStory) {
        callbacks.onStory(story);
      }
      // Remove the processed tag from the buffer
      buffer = buffer.replace(storyMatch[0], '');
    }

    // Process <ITEM> tags
    let itemMatch;
    const itemRegex = /<ITEM>([\s\S]*?)<\/ITEM>/g;
    while ((itemMatch = itemRegex.exec(buffer)) !== null) {
      const itemYaml = itemMatch[1].trim();
      outputItems.push(itemYaml); // Store the output item YAML
      if (callbacks.onOutputItem) {
        try {
          const item = yaml.load(itemYaml);
          // Convert short IDs back to original IDs before callback
          const itemWithOriginalIds = replaceWithOriginalIds(item, shortIdToId);
          callbacks.onOutputItem(itemWithOriginalIds);
        } catch (e) {
          console.error('Error parsing output item YAML:', e);
        }
      }
      // Remove the processed tag from the buffer
      buffer = buffer.replace(itemMatch[0], '');
    }

    // Process <REMOVED_ITEM> tags
    let removedMatch;
    const removedRegex = /<REMOVED_ITEM>(.*?)<\/REMOVED_ITEM>/g;
    while ((removedMatch = removedRegex.exec(buffer)) !== null) {
      const itemId = removedMatch[1].trim();
      removedItemIds.push(itemId); // Store the removed item ID
      if (callbacks.onRemovedItemId) {
        // Convert short ID back to original ID before callback
        const originalId = shortIdToId[itemId] || itemId;
        callbacks.onRemovedItemId(originalId);
      }
      // Remove the processed tag from the buffer
      buffer = buffer.replace(removedMatch[0], '');
    }

    // If this is the final processing and we still have content in the buffer,
    // try to extract any partial tags or remaining content
    if (isFinal && buffer.trim()) {
      console.log('Remaining buffer content:', buffer);
    }
  }
};


================================================
FILE: server/llm/word-lists/accessories.js
================================================
const items = [
  "Anklet",
  "Armlet",
  "Backpack",
  "Bandana",
  "Belt",
  "Beret",
  "Bolo tie",
  "Bonnet",
  "Bowtie",
  "Bracelet",
  "Brooch",
  "Cane",
  "Cardigan",
  "Choker",
  "Clutch",
  "Collar pin",
  "Crown",
  "Cufflinks",
  "Cummerbund",
  "Diadem",
  "Duffle bag",
  "Durag",
  "Ear cuffs",
  "Earmuffs",
  "Earrings",
  "Eyeglasses",
  // amazonq-ignore-next-line
  // amazonq-ignore-next-line
  "Fanny pack",
  "Fascinator",
  "Fedora",
  "Fingerless gloves",
  "Fishnet stockings",
  "Gaiters",
  "Glasses",
  "Gloves",
  "Hairpin",
  "Handbag",
  "Handkerchief",
  "Hat",
  "Headband",
  "Insoles",
  "Jewelry",
  "Keychain",
  "Kippah",
  "Lapel pin",
  "Leg warmers",
  "Mittens",
  "Muff",
  "Necklace",
  "Nose ring",
  "Over-the-knee socks",
  "Panama hat",
  "Parasol",
  "Pendant",
  "Pocket square",
  "Pocket watch",
  "Purse",
  "Quartz watch",
  "Quilted handbag",
  "Ring",
  "Sash",
  "Scarf",
  "Shawl",
  "Sunglasses",
  "Suspenders",
  "Tiara",
  "Tie",
  "Tights",
  "Toe rings",
  "Umbrella",
  "Veil",
  "Vest",
  "Visor",
  "Waistcoat",
  "Wallet chain",
  "Watch",
  "Wristlet",
  "Yarmulke",
  "Zirconia earrings"
]
export default items;


================================================
FILE: server/llm/word-lists/adhesives.js
================================================
const items = [
  "Acrylic adhesive",
  "Animal glue",
  "Barge cement",
  "Bookbinding glue",
  "Carpenter's glue",
  "Caulk",
  "Cement glue",
  "Contact cement",
  "Craft glue",
  "Cyanoacrylate",
  "Double-sided tape",
  "Duct tape",
  "Electrical tape",
  "Epoxy",
  "Fabric glue",
  "Foam tape",
  "Gaffer tape",
  "Gorilla glue",
  "Hide glue",
  "Hot glue",
  "Instant adhesive",
  "Latex adhesive",
  "Liquid nails",
  "Masking tape",
  "Metal epoxy",
  "Mounting tape",
  "Mucilage",
  "Neoprene adhesive",
  "Paper glue",
  "Paste",
  "PVA glue",
  "Resin adhesive",
  "Rubber cement",
  "Sealant",
  "Silicone adhesive",
  "Spray adhesive",
  "Starch paste",
  "Sticky tack",
  "Super glue",
  "Tape",
  "Thermoplastic adhesive",
  "Tile adhesive",
  "Transparent tape",
  "Two-part epoxy",
  "Vinyl adhesive",
  "Waterproof glue",
  "Washi tape",
  "Welding adhesive",
  "Wood glue"
]
export default items;


================================================
FILE: server/llm/word-lists/car-parts.js
================================================
const items = [
  "accelerator",
  "air conditioner",
  "air conditioning",
  "air filter",
  "air vent",
  "airbag",
  "alarm",
  "all-wheel drive",
  "alternator",
  "antenna",
  "anti-lock brakes",
  "armrest",
  "auto",
  "automatic transmission",
  "automobile",
  "axle",
  "baby car seat",
  "baby seat",
  "back-up lights",
  "battery",
  "bench seat",
  "bonnet",
  "brake light",
  "brake pedal",
  "brakes",
  "bucket seat",
  "bumper",
  "camshaft",
  "car",
  "carburetor",
  "catalytic converter",
  "chassis",
  "child car seat",
  "chrome trim",
  "clutch",
  "computer",
  "console",
  "cooling system",
  "crankshaft",
  "cruise control",
  "cylinder",
  "dashboard",
  "defroster",
  "diesel engine",
  "differential",
  "dip stick",
  "door",
  "door handle",
  "drive belt",
  "drive shaft",
  "driver's seat",
  "emergency brake",
  "emergency lights",
  "emissions",
  "engine",
  "engine block",
  "exhaust pipe",
  "exhaust system",
  "fan belt",
  "fender",
  "filter",
  "floor mat",
  "fog light",
  "four-wheel drive",
  "frame",
  "fuel",
  "fuel cap",
  "fuel gauge",
  "fuse",
  "gas",
  "gas gauge",
  "gas pedal",
  "gas tank",
  "gasket",
  "gasoline",
  "gauge",
  "gear shift",
  "gear stick",
  "gearbox",
  "glove compartment",
  "GPS",
  "grille",
  "hand brake",
  "headlamp",
  "headlight",
  "headrest",
  "heater",
  "high-beam headlights",
  "hood",
  "horn",
  "hubcap",
  "hybrid",
  "ignition",
  "instrument panel",
  "interior light",
  "internal combustion engine",
  "jack",
  "key",
  "license plate",
  "lights",
  "lock",
  "low-beam headlights",
  "lug bolt",
  "lug nut",
  "manifold",
  "manual transmission",
  "mat",
  "mirror",
  "moon roof",
  "motor",
  "mud flap",
  "muffler",
  "navigation system",
  "odometer",
  "oil",
  "oil filter",
  "oil tank",
  "parking brake",
  "parking lights",
  "passenger seat",
  "pedal",
  "piston",
  "power brakes",
  "power steering",
  "power window switch",
  "radiator",
  "radio",
  "rag top",
  "rear window defroster",
  "rear-view mirror",
  "reverse light",
  "rims",
  "roof",
  "roof rack",
  "rotary engine",
  "seat",
  "seat belt",
  "shift",
  "shock absorber",
  "side airbags",
  "side mirror",
  "spare tire",
  "spark plug",
  "speaker",
  "speedometer",
  "spoiler",
  "starter",
  "steering column",
  "steering wheel",
  "sun visor",
  "sunroof",
  "suspension",
  "tachometer",
  "tailgate",
  "temperature gauge",
  "thermometer",
  "tire",
  "trailer hitch",
  "transmission",
  "trim",
  "trip computer",
  "trunk",
  "turbo charger",
  "turn signal",
  "undercarriage",
  "unleaded gas",
  "valve",
  "vents",
  "visor",
  "warning light",
  "wheel",
  "wheel well",
  "window",
  "windshield",
  "windshield wiper"
]
export default items;


================================================
FILE: server/llm/word-lists/clothing.js
================================================
const items = [
  "abaya",
  "anorak",
  "apparel",
  "apron",
  "ascot tie",
  "attire",
  "balaclava",
  "ball gown",
  "bandanna",
  "baseball cap",
  "bathing suit",
  "battledress",
  "beanie",
  "bedclothes",
  "bell-bottoms",
  "belt",
  "beret",
  "Bermuda shorts",
  "bib",
  "blazer",
  "blouse",
  "boa",
  "bonnet",
  "boot",
  "bow",
  "bow tie",
  "bracelet",
  "buckle",
  "button",
  "button-down shirt",
  "caftan",
  "camouflage",
  "cap",
  "cap and gown",
  "cape",
  "capris",
  "cardigan",
  "cloak",
  "clogs",
  "clothes",
  "clothing",
  "coat",
  "collar",
  "corset",
  "costume",
  "coveralls",
  "cowboy boots",
  "cowboy hat",
  "cravat",
  "crown",
  "cuff",
  "cuff links",
  "culottes",
  "cummerbund",
  "dashiki",
  "dinner jacket",
  "dirndl",
  "drawers",
  "dress",
  "dress shirt",
  "duds",
  "dungarees",
  "earmuffs",
  "earrings",
  "elastic",
  "evening gown",
  "fashion",
  "fatigues",
  "fedora",
  "fez",
  "flak jacket",
  "flannel nightgown",
  "flannel shirt",
  "flip-flops",
  "formal wear",
  "frock",
  "fur",
  "fur coat",
  "gabardine",
  "gaiters",
  "galoshes",
  "garb",
  "garment",
  "gear",
  "getup",
  "gilet",
  "glasses",
  "gloves",
  "gown",
  "halter top",
  "handbag",
  "handkerchief",
  "hat",
  "Hawaiian shirt",
  "hazmat suit",
  "headscarf",
  "helmet",
  "hem",
  "high heels",
  "hoodie",
  "hook and eye",
  "hose",
  "hospital gown",
  "houndstooth",
  "housecoat",
  "jacket",
  "jeans",
  "jersey",
  "jewelry",
  "jumper",
  "jumpsuit",
  "kerchief",
  "khakis",
  "kilt",
  "kimono",
  "kit",
  "knickers",
  "lab coat",
  "lapel",
  "leather jacket",
  "leg warmers",
  "leggings",
  "leotard",
  "life jacket",
  "loafers",
  "mittens",
  "moccasins",
  "muffler",
  "muumuu",
  "neckerchief",
  "necklace",
  "nightgown",
  "nightshirt",
  "outerwear",
  "outfit",
  "overalls",
  "overcoat",
  "overshirt",
  "pajamas",
  "panama hat",
  "pants",
  "pantsuit",
  "pantyhose",
  "parka",
  "pea coat",
  "peplum",
  "petticoat",
  "pinafore",
  "pleat",
  "pocket",
  "pocketbook",
  "polo shirt",
  "poncho",
  "poodle skirt",
  "pork pie hat",
  "pullover",
  "pumps",
  "purse",
  "raincoat",
  "ring",
  "robe",
  "rugby shirt",
  "sandals",
  "sari",
  "sarong",
  "scarf",
  "school uniform",
  "scrubs",
  "shawl",
  "sheath dress",
  "shift",
  "shirt",
  "shoe",
  "shorts",
  "shoulder pads",
  "shrug",
  "singlet",
  "skirt",
  "slacks",
  "slip",
  "slippers",
  "smock",
  "snaps",
  "sneakers",
  "sock",
  "sombrero",
  "spacesuit",
  "Stetson hat",
  "stockings",
  "stole",
  "suit",
  "sun hat",
  "sunbonnet",
  "sundress",
  "sunglasses",
  "suspenders",
  "sweater",
  "sweatpants",
  "sweatshirt",
  "sweatsuit",
  "swimsuit",
  "T-shirt",
  "tam",
  "tank top",
  "threads",
  "tiara",
  "tie",
  "tie clip",
  "tights",
  "toga",
  "togs",
  "top",
  "top coat",
  "top hat",
  "train",
  "trench coat",
  "trousers",
  "trunks",
  "tube top",
  "tunic",
  "turban",
  "turtleneck",
  "turtleneck shirt",
  "tutu",
  "tux",
  "tuxedo",
  "tweed jacket",
  "twill",
  "twin set",
  "umbrella",
  "uniform",
  "veil",
  "Velcro",
  "vest",
  "vestments",
  "visor",
  "waders",
  "waistcoat",
  "wear",
  "wedding gown",
  "Wellingtons",
  "wetsuit",
  "white tie",
  "wig",
  "windbreaker",
  "woolens",
  "wrap",
  "yoke",
  "zipper"
];
export default items;


================================================
FILE: server/llm/word-lists/containers.js
================================================
const items = [
  "amphora",
  "attaché case",
  "backpack",
  "bag",
  "baggage",
  "barrel",
  "basin",
  "basket",
  "beaker",
  "bin",
  "bottle",
  "bowl",
  "box",
  "briefcase",
  "bucket",
  "cabinet",
  "can",
  "canister",
  "canteen",
  "carafe",
  "carrier",
  "carryall",
  "carton",
  "case",
  "cask",
  "casket",
  "chest",
  "coffer",
  "compote",
  "cone",
  "container",
  "cooler",
  "crate",
  "crock",
  "cruet",
  "cube",
  "depository",
  "dish",
  "drawer",
  "drum",
  "enclosure",
  "envelope",
  "ewer",
  "file folder",
  "flask",
  "folder",
  "garbage can",
  "glass",
  "goblet",
  "grocery bag",
  "hamper",
  "handbag",
  "holder",
  "hopper",
  "hutch",
  "ice bucket",
  "jar",
  "jug",
  "knapsack",
  "locker",
  "luggage",
  "lunchbox",
  "milk crate",
  "packet",
  "pail",
  "pan",
  "paper bag",
  "plastic bag",
  "plate",
  "pocket",
  "pod",
  "pot",
  "pouch",
  "purse",
  "rack",
  "receptacle",
  "sack",
  "saddlebag",
  "satchel",
  "saucer",
  "stein",
  "suitcase",
  "test tube",
  "tin",
  "tote",
  "trash bin",
  "tray",
  "trunk",
  "tub",
  "tube",
  "tun",
  "tureen",
  "urn",
  "vase",
  "vat",
  "vault",
  "vesicle",
  "vessel",
  "vial",
  "wastebasket",
  "water bottle"
]
export default items;


================================================
FILE: server/llm/word-lists/cooking-items.js
================================================
const items = [
  "apron",
  "baking pan",
  "baking sheet",
  "barbecue grill",
  "baster",
  "basting brush",
  "blender",
  "bread basket",
  "bread knife",
  "Bundt pan",
  "butcher block",
  "cake pan",
  "can opener",
  "carafe",
  "casserole pan",
  "charcoal grill",
  "cheese cloth",
  "coffee maker",
  "coffee pot",
  "colander",
  "convection oven",
  "cookbook",
  "cookie cutter",
  "cookie press",
  "cookie sheet",
  "cooling rack",
  "corer",
  "crepe pan",
  "crock",
  "crock pot",
  "cupcake pan",
  "custard cup",
  "cutlery",
  "cutting board",
  "Dutch oven",
  "egg beater",
  "egg poacher",
  "egg timer",
  "espresso machine",
  "fondue pot",
  "food processor",
  "fork",
  "frying pan",
  "garlic press",
  "gelatin mold",
  "grater",
  "griddle",
  "grill pan",
  "grinder",
  "hamburger press",
  "hand mixer",
  "honey pot",
  "ice bucket",
  "ice cream scoop",
  "icing spatula",
  "infuser",
  "jar opener",
  "jellyroll pan",
  "juicer",
  "kettle",
  "knife",
  "ladle",
  "lasagne pan",
  "lid",
  "mandolin",
  "measuring cup",
  "measuring spoon",
  "microwave oven",
  "mixing bowl",
  "mold",
  "mortar and pestle",
  "muffin pan",
  "nut cracker",
  "oven",
  "oven mitts",
  "pan",
  "parchment paper",
  "paring knife",
  "pastry bag",
  "peeler",
  "pepper mill",
  "percolator",
  "pie pan",
  "pitcher",
  "pizza cutter",
  "pizza stone",
  "platter",
  "poacher",
  "popcorn popper",
  "pot",
  "pot holder",
  "poultry shears",
  "pressure cooker",
  "quiche pan",
  "raclette grill",
  "ramekin",
  "refrigerator",
  "rice cooker",
  "ricer",
  "roaster",
  "roasting pan",
  "rolling pin",
  "salad bowl",
  "salad spinner",
  "salt shaker",
  "sauce pan",
  "scissors",
  "sharpening steel",
  "shears",
  "sieve",
  "skewer",
  "skillet",
  "slicer",
  "slow cooker",
  "souffle dish",
  "spice rack",
  "spoon",
  "steak knife",
  "steamer",
  "stockpot",
  "stove",
  "strainer",
  "tablespoon",
  "tart pan",
  "tea infuser",
  "teakettle",
  "teaspoon",
  "thermometer",
  "toaster",
  "toaster oven",
  "tongs",
  "trivet",
  "utensils",
  "vegetable bin",
  "vegetable peeler",
  "waffle iron",
  "water filter",
  "whisk",
  "wok",
  "yogurt maker",
  "zester"
]
export default items;


================================================
FILE: server/llm/word-lists/food-ingredients.js
================================================
const items = [
  "Almond",
  "Apple",
  "Avocado",
  "Bacon",
  "Banana",
  "Basil",
  "Bean",
  "Beef",
  "Bell pepper",
  "Blueberry",
  "Bread",
  "Broccoli",
  "Butter",
  "Cabbage",
  "Carrot",
  "Cauliflower",
  "Celery",
  "Cheese",
  "Cherry",
  "Chicken",
  "Chickpea",
  "Chili",
  "Chocolate",
  "Cilantro",
  "Cinnamon",
  "Coconut",
  "Coffee",
  "Corn",
  "Cucumber",
  "Cumin",
  "Egg",
  "Eggplant",
  "Flour",
  "Garlic",
  "Ginger",
  "Grape",
  "Honey",
  "Kale",
  "Kiwi",
  "Lemon",
  "Lentil",
  "Lettuce",
  "Lime",
  "Mango",
  "Maple syrup",
  "Milk",
  "Mint",
  "Mushroom",
  "Mustard",
  "Noodle",
  "Oat",
  "Olive",
  "Onion",
  "Orange",
  "Oregano",
  "Paprika",
  "Parsley",
  "Peach",
  "Peanut",
  "Pear",
  "Peas",
  "Pepper",
  "Pineapple",
  "Potato",
  "Pumpkin",
  "Quinoa",
  "Radish",
  "Rice",
  "Rosemary",
  "Saffron",
  "Salmon",
  "Salt",
  "Sesame",
  "Shrimp",
  "Spinach",
  "Strawberry",
  "Sugar",
  "Sweet potato",
  "Thyme",
  "Tofu",
  "Tomato",
  "Tuna",
  "Turmeric",
  "Vanilla",
  "Vinegar",
  "Walnut",
  "Watermelon",
  "Yeast",
  "Yogurt",
  "Zucchini",
  // New ingredients
  "Arugula",
  "Asparagus",
  "Bok choy",
  "Brussels sprouts",
  "Butternut squash",
  "Cashew",
  "Chard",
  "Chia seeds",
  "Coconut milk",
  "Cranberry",
  "Dates",
  "Dill",
  "Dragon fruit",
  "Edamame",
  "Fennel",
  "Figs",
  "Flax seeds",
  "Goji berries",
  "Grapefruit",
  "Green beans",
  "Hazelnut",
  "Hemp seeds",
  "Jackfruit",
  "Jalapeño",
  "Kombu",
  "Leek",
  "Lemon grass",
  "Lime leaves",
  "Macadamia",
  "Miso",
  "Mung bean",
  "Nori",
  "Okra",
  "Papaya",
  "Pecan",
  "Pine nuts",
  "Pomegranate",
  "Pumpkin seeds",
  "Radicchio",
  "Raspberry",
  "Red cabbage",
  "Rhubarb",
  "Sage",
  "Seaweed",
  "Shallot",
  "Snow peas",
  "Sorrel",
  "Soy sauce",
  "Star anise",
  "Sunflower seeds",
  "Tamarind",
  "Tarragon",
  "Tempeh",
  "Truffle",
  "Turnip",
  "Wasabi",
  "Water chestnut",
  "Wheat germ",
  "Wild rice",
  "Yam",
  "Za'atar",
  "Zucchini blossoms",
  "Acai berry",
  "Amaranth",
  "Arrowroot",
  "Bamboo shoots",
  "Barley",
  "Bay leaves",
  "Blackberry",
  "Buckwheat",
  "Cardamom",
  "Carob",
  "Cassava",
  "Chayote",
  "Chestnut",
  "Chicory",
  "Coconut oil",
  "Collard greens",
  "Coriander",
  "Couscous",
  "Curry leaves",
  "Daikon",
  "Dulse",
  "Elderberry",
  "Endive",
  "Fenugreek",
  "Fiddlehead",
  "Garbanzo beans",
  "Ghee",
  "Ginger root",
  "Grape leaves",
  "Guava",
  "Horseradish",
  "Jicama",
  "Kale sprouts",
  "Kelp",
  "Kohlrabi",
  "Kumquat",
  "Lotus root",
  "Lychee",
  "Mango powder",
  "Marjoram",
  "Millet",
  "Mizuna",
  "Mulberry",
  "Nasturtium",
  "Nectarine",
  "Nigella seeds",
  "Oyster mushroom",
  "Passion fruit",
  "Persimmon",
  "Pistachio",
  "Plantain",
  "Purslane",
  "Quince",
  "Ramps",
  "Red currant",
  "Rutabaga",
  "Salsify",
  "Sapote",
  "Savory",
  "Scallion",
  "Sorghum",
  "Soursop",
  "Spelt",
  "Sprouts",
  "Squash blossoms",
  "Sumac",
  "Taro",
  "Tatsoi",
  "Ugli fruit",
  "Wakame",
  "Watercress",
  "Wheat berries",
  "Yuzu"
]

export default items;


================================================
FILE: server/llm/word-lists/household-items.js
================================================
const items = [
  "air conditioner",
  "alarm clock",
  "answering machine",
  "barbecue grill",
  "BBQ grill",
  "blender",
  "blow dryer",
  "burglar alarm",
  "calculator",
  "camera",
  "can opener",
  "CD player",
  "ceiling fan",
  "cell phone",
  "clock",
  "clothes dryer",
  "clothes washer",
  "coffee grinder",
  "coffee maker",
  "computer",
  "convection oven",
  "copier",
  "crock-pot",
  "curling iron",
  "dishwasher",
  "doorbell",
  "dryer",
  "edger",
  "electric blanket",
  "electric drill",
  "electric fan",
  "electric guitar",
  "electric keyboard",
  "electric pencil sharpener",
  "electric razor",
  "electric toothbrush",
  "espresso maker",
  "fan",
  "fax machine",
  "fire alarm",
  "fire extinguisher",
  "fireplace",
  "flashlight",
  "flatscreen TV",
  "food processor",
  "freezer",
  "furnace",
  "garage door",
  "garbage disposal",
  "GPS",
  "grill",
  "hair clippers",
  "hair dryer",
  "headphones",
  "heater",
  "hood",
  "hot plate",
  "humidifier",
  "ice cream maker",
  "iron",
  "juice",
  "kerosene heater",
  "lamp",
  "lantern",
  "laptop",
  "lawn mower",
  "leaf blower",
  "light",
  "microwave oven",
  "mixer",
  "mousetrap",
  "MP3 player",
  "oven",
  "percolator",
  "pressure cooker",
  "printer",
  "radio",
  "range",
  "record player",
  "refrigerator",
  "rotisserie",
  "scale",
  "scanner",
  "sewing machine",
  "smoke detector",
  "stapler",
  "stereo",
  "stove",
  "telephone",
  "television",
  "timer",
  "toaster",
  "toaster oven",
  "torch",
  "trash compactor",
  "trimmer",
  "TV",
  "vacuum cleaner",
  "vaporizer",
  "VCR",
  "video camera",
  "video game machine",
  "waffle iron",
  "walkie-talkie",
  "washing machine",
  "watch",
  "water heater"
]
export default items;


================================================
FILE: server/llm/word-lists/index.js
================================================
import accessories from './accessories';
import adhesives from './adhesives';
import carParts from './car-parts';
import clothing from './clothing';
import containers from './containers';
import cookingItems from './cooking-items';
import foodIngredients from './food-ingredients';
import householdItems from './household-items';
import liquids from './liquids';
import magical from './magical';
import tools from './tools';
import toys from './toys';
import themes from './themes';

var allItems = [];

allItems = allItems.concat(accessories);
allItems = allItems.concat(adhesives);
allItems = allItems.concat(clothing);
allItems = allItems.concat(containers);
allItems = allItems.concat(cookingItems);
allItems = allItems.concat(foodIngredients);
allItems = allItems.concat(householdItems);
allItems = allItems.concat(liquids);
allItems = allItems.concat(magical);
allItems = allItems.concat(tools);
allItems = allItems.concat(toys);

export const randomInspiration = function () {
  return themes[Math.floor(Math.random() * themes.length)] + ' ' +
         allItems[Math.floor(Math.random() * allItems.length)];
}



================================================
FILE: server/llm/word-lists/liquids.js
================================================
const items = [
  "Acetone",
  "Acid",
  "Alcohol",
  "Almond milk",
  "Ammonia",
  "Antifreeze",
  "Balsamic vinegar",
  "Bleach",
  "Blood",
  "Brake fluid",
  "Brandy",
  "Champagne",
  "Chlorine",
  "Coconut milk",
  "Coffee",
  "Cola",
  "Coolant",
  "Corn syrup",
  "Cough syrup",
  "Cream",
  "Detergent",
  "Diesel",
  "Disinfectant",
  "Dish soap",
  "Ether",
  "Ethanol",
  "Fuel",
  "Gasoline",
  "Glycerin",
  "Honey",
  "Hot sauce",
  "Hydrogen peroxide",
  "Ink",
  "Isopropyl alcohol",
  "Juice",
  "Kerosene",
  "Lava",
  "Lemonade",
  "Liquid nitrogen",
  "Liquid soap",
  "Maple syrup",
  "Mercury",
  "Milk",
  "Mineral oil",
  "Motor oil",
  "Mouthwash",
  "Mud",
  "Nail polish",
  "Nail polish remover",
  "Oil",
  "Olive oil",
  "Paint",
  "Paint thinner",
  "Perfume",
  "Propane",
  "Rainwater",
  "Rubbing alcohol",
  "Rum",
  "Saliva",
  "Saltwater",
  "Shampoo",
  "Soda",
  "Soy milk",
  "Soy sauce",
  "Sunscreen",
  "Tea",
  "Tequila",
  "Toner",
  "Turpentine",
  "Varnish",
  "Vinegar",
  "Vodka",
  "Water",
  "Whiskey",
  "Wine",
  "Wiper fluid"
]
export default items;


================================================
FILE: server/llm/word-lists/magical.js
================================================
const items = [
  "Amulet of protection",
  "Ancient grimoire",
  "Arcane crystal",
  "Astral compass",
  "Bag of holding",
  "Bewitched mirror",
  "Blessed chalice",
  "Bottled fairy",
  "Celestial map",
  "Charmed locket",
  "Crystal ball",
  "Cursed dagger",
  "Dragon scale",
  "Dreamcatcher",
  "Elemental orb",
  "Enchanted armor",
  "Enchanted quill",
  "Ethereal dust",
  "Fairy dust",
  "Flying carpet",
  "Fortune telling cards",
  "Genie lamp",
  "Ghost lantern",
  "Glowing mushroom",
  "Goblin trinket",
  "Golden compass",
  "Healing potion",
  "Invisibility cloak",
  "Levitation boots",
  "Lich's phylactery",
  "Lucky coin",
  "Magic beans",
  "Magic wand",
  "Mana crystal",
  "Mermaid's tear",
  "Moonstone",
  "Mystic hourglass",
  "Necromancer's staff",
  "Oracle bones",
  "Phoenix feather",
  "Potion of flight",
  "Resurrection stone",
  "Rune stone",
  "Scrying bowl",
  "Seer's crystal",
  "Shrunken head",
  "Siren's shell",
  "Soul gem",
  "Spell book",
  "Spirit bottle",
  "Staff of power",
  "Talisman",
  "Teleportation scroll",
  "Time turner",
  "Unicorn horn",
  "Vial of dragon blood",
  "Voodoo doll",
  "Warlock's pendant",
  "Witch's broom",
  "Wizard hat",
  "Wizard's staff"
]
export default items;


================================================
FILE: server/llm/word-lists/themes.js
================================================
const themes = [
  "sci-fi",
  "retro",
  "medieval",
  "creepy",
  "cool",
  "silly",
  "steampunk",
  "cyberpunk",
  "fantasy",
  "futuristic",
  "ancient",
  "magical",
  "spooky",
  "cute",
  "elegant",
  "rustic",
  "industrial",
  "tropical",
  "winter",
  "summer",
  "spring",
  "autumn",
  "space",
  "underwater",
  "desert",
  "jungle",
  "arctic",
  "volcanic",
  "celestial",
  "gothic",
  "romantic",
  "western",
  "military",
  "post-apocalyptic",
  "prehistoric",
  "mythological",
  "pirate",
  "ninja",
  "victorian",
  "renaissance",
  "baroque",
  "art deco",
  "minimalist",
  "maximalist",
  "abstract",
  "geometric",
  "organic",
  "metallic",
  "crystal",
  "wooden",
  "stone",
  "neon",
  "pastel",
  "monochrome",
  "rainbow",
  "glitch",
  "pixel",
  "retro-gaming",
  "8-bit",
  "16-bit",
  "vaporwave",
  "synthwave",
  "dieselpunk",
  "biopunk",
  "atompunk",
  "solarpunk",
  "clockpunk",
  "nightmare",
  "dreamlike",
  "surreal",
  "cartoon",
  "anime",
  "chibi",
  "kawaii",
  "horror",
  "cosmic horror",
  "lovecraftian",
  "zombie",
  "vampire",
  "werewolf",
  "fairy tale",
  "holiday",
  "festive",
  "circus",
  "carnival",
  "sports",
  "racing",
  "musical",
  "dystopian",
  "utopian",
  "digital",
  "holographic",
  "robotic",
  "aquatic",
  "ethereal",
  "mystical",
  "haunted",
  "enchanted",
  "whimsical",
  "runic",
  "arcane",
  "mechanical",
  "botanical",
  "crystalline",
  "cosmic",
  "stellar",
  "nebular",
  "galactic",
  "dimensional",
  "psychedelic",
  "iridescent",
  "luminous",
  "shadowy",
  "prismatic",
  "elemental",
  "alchemical",
  "technological",
  "retro-futuristic",
  "neo-classical",
  "brutalist",
  "art nouveau",
  "grunge",
  "punk",
  "noir",
  "pulp",
  "high fantasy",
  "low fantasy",
  "urban fantasy",
  "heroic",
  "mythic",
  "legendary",
  "fabled",
  "folklore",
  "fairytale",
  "storybook",
  "animated",
  "hand-drawn",
  "claymation",
  "stop-motion",
  "isometric",
  "miniature",
  "toy-like",
  "doll-like",
  "paper craft",
  "origami",
  "mosaic",
  "stained glass",
  "neon-noir",
  "dark academia",
  "cottagecore",
  "dungeon",
  "labyrinthine",
  "floating islands",
  "subterranean",
  "astral",
  "interdimensional"
];
export default themes;


================================================
FILE: server/llm/word-lists/tools.js
================================================
const items = [
  // Cutting Tools
  "adze",
  "angle grinder",
  "axe",
  "bolt cutter",
  "cable cutter",
  "chainsaw",
  "chisel",
  "circular saw",
  "clippers",
  "coping saw",
  "cutters",
  "glass cutter",
  "grinder",
  "hacksaw",
  "handsaw",
  "jigsaw",
  "knife",
  "machete",
  "pipe cutter",
  "pruning shears",
  "razor",
  "reciprocating saw",
  "saw",
  "scalpel",
  "scissors",
  "sheet metal shears",
  "sickle",
  "snips",
  "tin snips",
  "utility knife",
  "wire cutter",
  "band saw",
  "cable saw",
  "circular saw blade",
  "diamond blade",
  "glass breaker",
  "glass saw",
  "hacksaw blade",
  "hole punch",
  "jigsaw blade",
  "keyhole saw",
  "masonry saw",
  "metal cutting saw",
  "pipe saw",
  "reciprocating saw blade",
  "rotary saw",
  "saw blade",
  "scoring knife",
  "tile cutter",
  "wire saw",
  "wood splitter",
  "bolt cropper",
  "cable stripper",
  "diamond saw",
  "drywall saw",
  "fiberglass cutter",
  "foam cutter",
  "hole saw",
  "kerfing saw",
  "miter saw",
  "oscillating tool",
  "panel saw",
  "plunge saw",
  "pole saw",
  "radial arm saw",
  "scroll saw",
  "table saw",
  "track saw",
  "undercut saw",
  "veneer saw",

  // Measuring and Layout Tools
  "calipers",
  "chalk line",
  "feeler gauge",
  "laser level",
  "level",
  "measuring tape",
  "plumb bob",
  "ruler",
  "square",
  "stud finder",
  "yard stick",
  "combination square",
  "framing square",
  "speed square",
  "thread gauge",

  // Fastening Tools
  "Allen wrench",
  "bolt",
  "brad",
  "hex wrench",
  "nail",
  "nut",
  "pin",
  "rivet",
  "screw",
  "screwdriver",
  "spanner",
  "staple",
  "tack",
  "wrench",
  "monkey wrench",
  "Phillips screwdriver",
  "lug wrench",
  "anchor bolt",
  "binding post",
  "carriage bolt",
  "clamp screw",
  "coach screw",
  "concrete screw",
  "deck screw",
  "drywall screw",
  "eye bolt",
  "flat head screw",
  "hanger bolt",
  "hex bolt",
  "lag bolt",
  "machine screw",
  "pan head screw",
  "security screw",
  "self-tapping screw",
  "set screw",
  "socket head screw",
  "thumb screw",
  "toggle bolt",
  "wing nut",
  "wing screw",
  "wood screw",
  "zip tie",
  "cable tie",
  "hog ring",
  "hog ring pliers",
  "rivet nut",
  "snap rivet",
  "split rivet",
  "threaded insert",
  "threaded rod",
  "U-bolt",
  "wire rope clip",

  // Power Tools
  "air compressor",
  "arc welder",
  "brad nailer",
  "die grinder",
  "drill",
  "drill press",
  "electric drill",
  "flux core welder",
  "impact driver",
  "impact wrench",
  "mig welder",
  "nail gun",
  "paint sprayer",
  "plasma cutter",
  "power drill",
  "pressure washer",
  "rivet gun",
  "router",
  "sander",
  "soldering iron",
  "spot welder",
  "torch",
  "oxy-acetylene torch",

  // Gripping and Holding Tools
  "bench vise",
  "clamp",
  "locking pliers",
  "needle-nose pliers",
  "pincer",
  "pliers",
  "snap ring pliers",
  "toggle clamp",
  "tongs",
  "vise",

  // Electrical Tools
  "battery tester",
  "circuit tester",
  "digital multimeter",
  "electrical tape",
  "voltage tester",
  "fish tape",

  // Joining and Adhesive Tools
  "glue",
  "glue gun",
  "welding helmet",
  "duct tape",
  "epoxy",
  "hot glue",
  "liquid nails",
  "super glue",
  "wood glue",

  // Finishing and Surface Tools
  "brush",
  "file set",
  "metal file",
  "putty knife",
  "rasp",
  "roller",
  "sand paper",
  "scraper",
  "sponge",
  "squeegee",
  "wire brush",
  "wood rasp",

  // Lifting and Moving Tools
  "block and tackle",
  "chain hoist",
  "engine hoist",
  "hydraulic jack",
  "lever",
  "pulley",
  "ratchet strap",
  "rope",

  // Specialized Tools
  "anvil",
  "bevel",
  "blowtorch",
  "countersink",
  "crimping tool",
  "crowbar",
  "deburring tool",
  "edger",
  "extension cord",
  "flaring tool",
  "grease gun",
  "heat gun",
  "jig",
  "lathe",
  "magnetic pickup tool",
  "mallet",
  "metal detector",
  "miter box",
  "pitchfork",
  "portable generator",
  "pry bar",
  "reamer",
  "sharpener",
  "shovel",
  "sledgehammer",
  "socket set",
  "spade",
  "spear",
  "tiller",
  "tire iron",
  "toolbox",
  "torque wrench",
  "trowel",
  "vacuum pump",
  "wedge",
  "workbench",
  "bolt extractor",
  "center punch",
  "dremel",
  "hand seamer",
  "hole saw",
  "laser thermometer",
  "multitool",
  "nibbler",
  "pipe threader",
  "plumb line",
  "rotary tool",
  "tap wrench",
  "tube cutter",
  "wood chisel"
]
export default items;


================================================
FILE: server/llm/word-lists/toys.js
================================================
const items = [
  "action figure",
  "ball",
  "blocks",
  "board game",
  "doll",
  "puzzle",
  "teddy bear",
  "video game",
  "yo-yo",
  "arts and crafts",
  "baby doll",
  "badminton set",
  "baseball",
  "basketball",
  "bath toys",
  "bike",
  "building blocks",
  "chalk",
  "checkers",
  "chess set",
  "climbing toy",
  "coloring books",
  "construction toys",
  "crayons",
  "croquet set",
  "darts",
  "dice",
  "doll house",
  "dominoes",
  "dress-up clothes",
  "educational toys",
  "fidget toys",
  "finger paints",
  "football",
  "frisbee",
  "game console",
  "hopscotch",
  "hula hoop",
  "jigsaw puzzle",
  "jump rope",
  "kite",
  "lego",
  "magic kit",
  "marbles",
  "modeling clay",
  "musical instruments",
  "nerf guns",
  "painting set",
  "play dough",
  "play tent",
  "playing cards",
  "plush toy",
  "pool table",
  "pretend play toys",
  "puppets",
  "puzzle",
  "racket sports",
  "radio control toys",
  "remote control car",
  "ride-on toys",
  "rocking horse",
  "roller blades",
  "roller skates",
  "sand box",
  "scooter",
  "slinky",
  "soccer ball",
  "spinning top",
  "stuffed animals",
  "swing set",
  "tea set",
  "train set",
  "tricycle",
  "video game console",
  "walkie talkies",
  "water toys",
  "xylophone"
];

export default items;



================================================
FILE: server/mocks/describe-equipment.json
================================================
"A mighty figure stands before you, their ethereal Viking beard flowing and braiding itself in an unseen wind, the silvery spectral strands reaching down to their chest even as you watch it grow. In their hand, they clutch the chrome-and-runes ValhallaMix 3000, its blue-tinged dwarven steel beaters catching the light like miniature axes. The air around them thrums with ancient kitchen-magic, punctuated by the occasional spark from the mixer's runic dials and the faint echo of distant war chants. Their eyes hold the determined gleam of a culinary warrior, and a light dusting of flour on their apocalypse-weathered clothing suggests they've recently emerged victorious from battle with some bread dough, no doubt producing perfectly boat-shaped loaves worthy of Odin's feast hall."


================================================
FILE: server/mocks/pull-item.json
================================================
{
  "story": "The portal crackles with interdimensional static before belching out a cloud of flour dust. Through the haze tumbles what appears to be a possessed kitchen appliance, its beaters spinning lazily and trailing wisps of otherworldly energy.",
  "items": [{
      "name": "ValhallaMix 3000 Battle Mixer",
      "weight": "4.2 lbs",
      "value": 245,
      "icon": "mixer",
      "description": "A hand mixer that seems to have been enchanted by ancient Norse kitchen magic. The chrome body features runic engravings that pulse with a faint blue glow, and the beaters are forged from what appears to be dwarven steel. Small sparks occasionally shoot from the speed settings which are labeled in Elder Futhark.",
      "color": "Chrome and Battle-Scarred Bronze",
      "materials": ["enchanted metal", "dwarven steel", "runic crystal"],
      "damage": "Speed setting 3 causes dimensional rifts, right beater slightly bent from fighting frost giants",
      "skills": [
          {
              "name": "Whisk of the Valkyries",
              "description": "Summons a spectral choir of Valkyries to help whip cream or beat eggs while singing epic ballads about your baking prowess"
          },
          {
              "name": "Ragnarök Roll",
              "description": "Violently mixes ingredients while creating a small localized thunder storm, guaranteed to make the fluffiest meringue in the nine realms"
          }
      ]
  }]
}


================================================
FILE: server/state/item-store.ts
================================================
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, QueryCommand, BatchGetCommand, TransactWriteCommand, GetCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';
import { DYNAMODB_CONFIG } from '../config';

const client = new DynamoDBClient(DYNAMODB_CONFIG);
const docClient = DynamoDBDocumentClient.from(client);
const TABLE_NAME = DYNAMODB_CONFIG.tables.items;
const INVENTORY_TABLE = DYNAMODB_CONFIG.tables.inventory;
const LOCATION_TABLE = DYNAMODB_CONFIG.tables.location;

export interface ItemResponse {
  id: string;
  [key: string]: any;
}

export async function listInventoryItems(inventoryId: string) {
  // First get inventory references
  const command = new QueryCommand({
    TableName: INVENTORY_TABLE,
    KeyConditionExpression: 'id = :id',
    ExpressionAttributeValues: {
      ':id': inventoryId
    }
  });

  const result = await docClient.send(command);
  const inventoryRefs = result.Items || [];

  // If no items, return empty array
  if (inventoryRefs.length === 0) {
    return [];
  }

  // DynamoDB BatchGet has a limit of 100 items per request
  const batchSize = 100;
  const items: ItemResponse[] = [];

  // Process items in batches
  for (let i = 0; i < inventoryRefs.length; i += batchSize) {
    const batch = inventoryRefs.slice(i, i + batchSize);
    const batchKeys = batch.map(ref => ({
      id: ref.itemId
    }));

    const batchCommand = new BatchGetCommand({
      RequestItems: {
        [TABLE_NAME]: {
          Keys: batchKeys
        }
      }
    });

    const batchResult = await docClient.send(batchCommand);
    if (batchResult.Responses?.[TABLE_NAME]) {
      items.push(...(batchResult.Responses[TABLE_NAME] as ItemResponse[]));
    }
  }

  return items;
}

export async function locationForItemId(itemId: string): Promise<string | null> {
  const locationCommand = new QueryCommand({
    TableName: LOCATION_TABLE,
    KeyConditionExpression: 'itemId = :itemId',
    ExpressionAttributeValues: {
      ':itemId': itemId
    }
  });

  const locationResult = await docClient.send(locationCommand);
  return locationResult.Items?.[0]?.location || null;
}

export async function createItem(id: string, userId: string, itemData: any, inventory?: string) {
  const inventoryName = inventory || 'main';
  const inventoryId = `${userId}:${inventoryName}`;

  const command = new TransactWriteCommand({
    TransactItems: [
      {
        Put: {
          TableName: TABLE_NAME,
          Item: {
            id,
            userId,
            ...itemData,
            createdAt: new Date().toISOString()
          }
        }
      },
      {
        Put: {
          TableName: INVENTORY_TABLE,
          Item: {
            id: inventoryId,
            itemId: id,
            createdAt: new Date().toISOString()
          }
        }
      },
      {
        Put: {
          TableName: LOCATION_TABLE,
          Item: {
            itemId: id,
            location: inventoryId,
            createdAt: new Date().toISOString()
          }
        }
      }
    ]
  });

  await docClient.send(command);
  return { id, ...itemData };
}

export async function findJunkItem(): Promise<ItemResponse | null> {
  // Generate random UUID to use as start key
  const randomId = crypto.randomUUID();

  const command = new QueryCommand({
    TableName: INVENTORY_TABLE,
    KeyConditionExpression: 'id = :id',
    ExpressionAttributeValues: {
      ':id': 'discarded'
    },
    ExclusiveStartKey: {
      id: 'discarded',
      itemId: randomId
    },
    Limit: 1
  });

  const result = await docClient.send(command);
  if (!result.Items || result.Items.length === 0) {
    return null;
  }

  // Get the actual item data
  const itemCommand = new GetCommand({
    TableName: TABLE_NAME,
    Key: {
      id: result.Items[0].itemId
    }
  });

  const itemResult = await docClient.send(itemCommand);
  return itemResult.Item as ItemResponse;
}

export async function moveItemLocation(itemId: string, oldLocation: string, newLocation: string) {
  const command = new TransactWriteCommand({
    TransactItems: [
      {
        Delete: {
          TableName: INVENTORY_TABLE,
          Key: {
            id: oldLocation,
            itemId: itemId
          }
        }
      },
      {
        Put: {
          TableName: INVENTORY_TABLE,
          Item: {
            id: newLocation,
            itemId: itemId,
            createdAt: new Date().toISOString()
          }
        }
      },
      {
        Delete: {
          TableName: LOCATION_TABLE,
          Key: {
            itemId: itemId,
            location: oldLocation
          }
        }
      },
      {
        Put: {
          TableName: LOCATION_TABLE,
          Item: {
            itemId: itemId,
            location: newLocation,
            createdAt: new Date().toISOString()
          }
        }
      }
    ]
  });

  await docClient.send(command);
  return true;
}

export async function getItemById(itemId: string): Promise<ItemResponse | null> {
  const command = new GetCommand({
    TableName: TABLE_NAME,
    Key: {
      id: itemId
    }
  });

  const result = await docClient.send(command);
  return result.Item as ItemResponse || null;
}

export async function updateItem(itemId: string, itemData: any): Promise<ItemResponse> {
  // First get the existing item to preserve certain fields
  const existingItem = await getItemById(itemId);

  if (!existingItem) {
    throw new Error(`Item with id ${itemId} not found`);
  }

  // Create update expression and attribute values
  const updateExpressions: string[] = [];
  const expressionAttributeNames: Record<string, string> = {};
  const expressionAttributeValues: Record<string, any> = {};

  // Process each property in the itemData
  Object.entries(itemData).forEach(([key, value]) => {
    // Skip id, userId, and createdAt as we want to preserve these
    if (key === 'id' || key === 'userId' || key === 'createdAt') {
      return;
    }

    const attributeName = `#${key}`;
    const attributeValue = `:${key}`;

    updateExpressions.push(`${attributeName} = ${attributeValue}`);
    expressionAttributeNames[attributeName] = key;
    expressionAttributeValues[attributeValue] = value;
  });

  // If there's nothing to update, return the existing item
  if (updateExpressions.length === 0) {
    return existingItem;
  }

  const updateExpression = `SET ${updateExpressions.join(', ')}`;

  const command = new UpdateCommand({
    TableName: TABLE_NAME,
    Key: { id: itemId },
    UpdateExpression: updateExpression,
    ExpressionAttributeNames: expressionAttributeNames,
    ExpressionAttributeValues: expressionAttributeValues,
    ReturnValues: 'ALL_NEW'
  });

  const result = await docClient.send(command);

  // Return the updated item
  return result.Attributes as ItemResponse;
}


================================================
FILE: server/state/user-store.ts
================================================
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, PutCommand, GetCommand, UpdateCommand, QueryCommand } from '@aws-sdk/lib-dynamodb';
import { DYNAMODB_CONFIG } from '../config';

const client = new DynamoDBClient(DYNAMODB_CONFIG);
const docClient = DynamoDBDocumentClient.from(client);

const USERS_TABLE = DYNAMODB_CONFIG.tables.users;
const USERNAMES_TABLE = DYNAMODB_CONFIG.tables.usernames;
const PERSONA_TABLE = DYNAMODB_CONFIG.tables.persona;

export async function createUser(userId: string, username: string, hashedPassword: string) {
  // First check if username exists
  const usernameCommand = new GetCommand({
    TableName: USERNAMES_TABLE,
    Key: {
      username
    }
  });

  const usernameResult = await docClient.send(usernameCommand);
  if (usernameResult.Item) {
    throw new Error('Username already taken');
  }

  // Create user and username entries
  const userCommand = new PutCommand({
    TableName: USERS_TABLE,
    Item: {
      userId,
      username,
      password: hashedPassword,
      createdAt: new Date().toISOString()
    }
  });

  const usernameCreateCommand = new PutCommand({
    TableName: USERNAMES_TABLE,
    Item: {
      username,
      userId,
      createdAt: new Date().toISOString()
    }
  });

  await Promise.all([
    docClient.send(userCommand),
    docClient.send(usernameCreateCommand)
  ]);

  return { userId, username };
}

export async function getUser(username: string) {
  // First get userId from username
  const usernameCommand = new GetCommand({
    TableName: USERNAMES_TABLE,
    Key: {
      username
    }
  });

  const usernameResult = await docClient.send(usernameCommand);
  if (!usernameResult.Item) {
    return null;
  }

  // Then get full user data
  const userCommand = new GetCommand({
    TableName: USERS_TABLE,
    Key: {
      userId: usernameResult.Item.userId
    }
  });

  const userResult = await docClient.send(userCommand);
  return userResult.Item;
}

export async function savePersonaDetail(userId: string, detail: string, value: string) {
  const command = new PutCommand({
    TableName: PERSONA_TABLE,
    Item: {
      userId,
      detail,
      value,
      createdAt: new Date().toISOString()
    }
  });

  await docClient.send(command);
  return true;
}

export async function incrementPersonaDetail(userId: string, detail: string, amount: number): Promise<number> {
  const command = new UpdateCommand({
    TableName: PERSONA_TABLE,
    Key: {
      userId,
      detail
    },
    UpdateExpression: 'SET #value = if_not_exists(#value, :zero) + :amount',
    ExpressionAttributeNames: {
      '#value': 'value'
    },
    ExpressionAttributeValues: {
      ':amount': amount,
      ':zero': 0
    },
    ReturnValues: 'UPDATED_NEW'
  });

  const result = await docClient.send(command);
  return parseInt(result.Attributes?.value || '0', 10);
}

export async function getPersonaDetails(userId: string): Promise<Record<string, string>> {
  const command = new QueryCommand({
    TableName: PERSONA_TABLE,
    KeyConditionExpression: 'userId = :userId',
    ExpressionAttributeValues: {
      ':userId': userId
    }
  });

  const result = await docClient.send(command);
  const details: Record<string, string> = {};
  
  if (result.Items) {
    for (const item of result.Items) {
      details[item.detail] = item.value;
    }
  }
  
  return details;
}


================================================
FILE: server/utils/message.ts
================================================
export function formatMessage(messageType, params?: any) {
  const outgoing = {
    type: messageType,
    body: params
  };
  const body = JSON.stringify(outgoing);

  if (messageType != 'pong') { 
    console.log(`< ${messageType} - ${body.length}`);
  }
  return body;
}


================================================
FILE: server/utils/password.ts
================================================
export async function hashPassword(password: string): Promise<string> {
    const hash = await Bun.password.hash(password, {
        algorithm: "bcrypt",
        cost: 10 // number of rounds
    });
    return hash;
}

export async function verifyPassword(password: string, hash: string): Promise<boolean> {
    return Bun.password.verify(password, hash);
}



================================================
FILE: server/utils/__tests__/password.test.ts
================================================
import { describe, expect, test } from 'bun:test';
import { hashPassword, verifyPassword } from '../password';

describe('Password utils', () => {
  test('should hash password', async () => {
    // amazonq-ignore-next-line
    const password = 'testpassword';
    const hash = await hashPassword(password);
    expect(hash).not.toBe(password);
  });

  test('should verify password', async () => {
    // amazonq-ignore-next-line
    const password = 'testpassword';
    const hash = await hashPassword(password);
    const verified = await verifyPassword(password, hash);
    expect(verified).toBe(true);
  });

  test('should reject incorrect password', async () => {
    // amazonq-ignore-next-line
    const correctPassword = 'testpassword';
    const wrongPassword = 'wrongpassword';
    const hash = await hashPassword(correctPassword);
    const verified = await verifyPassword(wrongPassword, hash);
    expect(verified).toBe(false);
  });
});



================================================
FILE: .kiro/steering/product.md
================================================
# Product Overview

Spirit of Kiro is an infinite crafting workshop game that demonstrates AI-powered game development. The game features:

- **Infinite Item Generation**: Every item is unique with AI-generated names, descriptions, damage values, and quirks
- **Dynamic Crafting System**: Transform, combine, and improve items using realistic crafting mechanics powered by AI
- **Intelligent Appraisal**: AI-driven item valuation system for selling crafted goods
- **Real-time Multiplayer**: WebSocket-based client-server architecture for responsive gameplay

## Core Game Loop
1. Pull random items from the dispenser
2. Craft and modify items at the workbench using AI-powered transformations
3. Store items in inventory chest or sell them to the appraiser
4. Repeat with increasingly valuable and complex items

## AI Integration
The game heavily leverages AWS Bedrock models (Nova Pro, Claude Sonnet 3.7/4) for:
- Item generation and descriptions
- Crafting logic and transformations
- Item appraisal and pricing
- Image generation via Nova Canvas

This project serves as a demonstration of best practices for AI-assisted development and showcases how AI can power core game mechanics.


================================================
FILE: .kiro/steering/structure.md
================================================
# Project Structure

## Root Level Organization
```
├── client/           # Vue.js frontend application
├── server/           # Bun WebSocket server
├── item-images/      # Separate service for AI image generation
├── docs/             # Project documentation
├── scripts/          # Deployment and setup scripts
├── docker/           # Docker configuration and data
└── launch.ts         # Development launcher script
```

## Client Structure (`client/`)
- **src/components/**: Vue components for game UI elements (GameGrid, PlayerCharacter, etc.)
- **src/systems/**: Game logic systems (physics, inventory, socket communication)
- **src/stores/**: Pinia state management (game.ts)
- **src/views/**: Page-level Vue components (GameView, SignInView)
- **src/utils/**: Utility functions (physics, items, world initialization)
- **src/assets/**: Static assets (images, CSS, game sprites)
- **iac/**: Infrastructure as Code for client deployment

## Server Structure (`server/`)
- **handlers/**: WebSocket message handlers (pull-item, sell-item, etc.)
- **llm/**: AI integration (model.ts, prompts.ts, word-lists/)
- **state/**: Data persistence layer (item-store.ts, user-store.ts)
- **utils/**: Server utilities (password hashing, message formatting)
- **iac/**: Infrastructure as Code for server deployment
- **__tests__/**: Unit tests with Bun test framework

## Item Images Service (`item-images/`)
- **handlers/**: HTTP request handlers for image generation
- **lib/**: Core image generation logic
- **state/**: Vector database and Redis client integration
- **iac/**: Infrastructure as Code for image service deployment

## Key Architectural Patterns

### Frontend Systems Architecture
The client uses a system-based architecture where independent systems communicate via events:
- **Socket System**: Manages WebSocket communication
- **Physics System**: Handles collision detection and movement
- **Game Object System**: Tracks on-screen objects
- **Item/Inventory Systems**: Manage game items and storage

### Message-Driven Communication
- WebSocket messages follow consistent naming patterns (kebab-case)
- Server handlers are organized by message type
- Event-driven frontend updates maintain reactive state

### Infrastructure as Code
Each service has its own `iac/` directory containing:
- CloudFormation YAML templates
- Deployment scripts
- Environment-specific configurations

### Testing Structure
- Server tests in `__tests__/` directories alongside source code
- Client tests use Vitest with Vue Test Utils
- Test configuration in respective package.json files

## File Naming Conventions
- **kebab-case**: For file names, component names, and message types
- **camelCase**: For JavaScript/TypeScript variables and functions
- **PascalCase**: For Vue components and TypeScript interfaces
- **.ts/.js extensions**: TypeScript preferred, JavaScript for legacy word lists


================================================
FILE: .kiro/steering/tech.md
================================================
# Technology Stack

## Runtime & Build System
- **Bun**: Primary JavaScript runtime for both client and server development
- **Docker/Podman**: Containerized development environment with compose orchestration
- **TypeScript**: Used throughout the codebase for type safety

## Frontend (Client)
- **Vue.js 3**: Component-based UI framework using Composition API
- **Pinia**: State management for reactive game state
- **Vite**: Build tool and development server
- **Vue Router**: Client-side routing
- **Vitest**: Unit testing framework

## Backend (Server)
- **Bun WebSocket Server**: Real-time bidirectional communication
- **AWS SDK**: Integration with AWS services
- **Sharp**: Image processing library
- **Redis**: Caching and session management

## AWS Services
- **Amazon Bedrock**: AI model integration (Nova Pro, Claude Sonnet 3.7/4, Nova Canvas, Titan Text Embeddings v2)
- **DynamoDB**: Game state and inventory persistence
- **Amazon Cognito**: User authentication and authorization
- **S3 + CloudFront**: Asset storage and content delivery
- **MemoryDB**: Vector database for image matching

## Development Commands

### Root Level
```bash
# Start both client and server in development mode
bun dev

# Install dependencies across all packages
bun install
```

### Client Commands
```bash
cd client
bun run dev          # Start development server
bun run build        # Production build
bun run preview      # Preview production build
bun run test:unit    # Run unit tests
bun run lint         # Lint and fix code
bun run format       # Format code with Prettier
```

### Server Commands
```bash
cd server
bun --watch server.ts           # Start server with hot reload
bun test                        # Run tests with JUnit output
bun run bootstrap-dynamodb      # Setup local DynamoDB tables
```

### Infrastructure Setup
```bash
# Deploy Cognito resources
./scripts/deploy-cognito.sh game-auth

# Start containerized stack
podman compose build && podman compose up --watch

# Bootstrap local DynamoDB (first time only)
podman exec server bun run /app/bootstrap-local-dynamodb.js
```

## Code Quality
- **ESLint**: Linting with Vue and TypeScript configurations
- **Prettier**: Code formatting
- **TypeScript**: Strict type checking enabled
- **Vitest**: Unit testing with coverage reporting

